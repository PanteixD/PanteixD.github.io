<!DOCTYPE html>
<html>
<head>
<title>Tiny Civilization Evolved</title>
<meta charset="UTF-8">
<style>
  /* --- General Styles --- */
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; text-align: center; display: flex; flex-direction: column; align-items: center; background-color: #e8eff5; margin: 0; padding: 20px; color: #333; }
  h1 { color: #2c3e50; margin-bottom: 10px; }

  /* Language Switcher */
  #language-switcher { position: absolute; top: 15px; left: 15px; z-index: 10; }
  #language-switch-button { padding: 8px 12px; font-size: 14px; background-color: #5dade2; color: white; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: background-color 0.2s ease; }
  #language-switch-button:hover { background-color: #3498db; }


  /* --- Unit Display Bar --- */
  #unit-display-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 10px; margin-bottom: 15px; min-height: 40px; background-color: #dde8f0; border-radius: 8px; border: 1px solid #c8d6e1; flex-wrap: wrap; }
  .unit-icon { width: 35px; height: 35px; border: 2px solid #adb5bd; background-color: #ced4da; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; cursor: pointer; transition: all 0.2s ease; position: relative; }
  .unit-icon:hover { border-color: #495057; background-color: #e9ecef; transform: scale(1.05); }
  .unit-icon.selected { border-color: #007bff; box-shadow: 0 0 8px rgba(0, 123, 255, 0.5); transform: scale(1.1); }
  .unit-icon[data-unit-type="pawn"] { background-color: #3498db; color: white; }
  .unit-icon[data-unit-type="worker"] { background-color: #e67e22; color: white; }
  .unit-icon[data-unit-type="scout"] { background-color: #1abc9c; color: white; }

  /* --- Alert Message --- */
  #alert-message { padding: 10px 20px; margin-top: 10px; border-radius: 8px; background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; font-weight: bold; text-align: center; opacity: 0; transition: opacity 0.5s ease-in-out; max-width: 550px; width: 90%; box-sizing: border-box; position: relative; left: 50%; transform: translateX(-50%); display: none; z-index: 20; }
  #alert-message.show { display: block; opacity: 1; }

  /* --- Game Layout --- */
  #game-container { display: flex; justify-content: center; align-items: flex-start; margin-top: 20px; flex-wrap: wrap; gap: 20px; background-color: #ffffff; padding: 30px; border-radius: 16px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); max-width: 1400px; width: 100%; position: relative; }
  #left-container, #right-panel { display: flex; flex-direction: column; align-items: stretch; gap: 15px; flex: 1; min-width: 250px; }
  #middle-controls { display: flex; flex-direction: column; align-items: stretch; gap: 10px; flex: 0 0 auto; width: 150px; }
  #middle-controls button { margin-top: 0; }
  #grid-area { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; min-width: 585px; }
  #grid { display: grid; grid-template-columns: repeat(10, 55px); grid-template-rows: repeat(10, 55px); gap: 5px; padding: 15px; background-color: #b0bec5; border-radius: 12px; border: 1px solid #90a4ae; margin-bottom: 10px; position: relative; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

  /* --- Tiles --- */
  .tile { width: 55px; height: 55px; border: 1px solid #cfd8dc; display: flex; align-items: center; justify-content: center; font-size: 28px; font-weight: normal; cursor: pointer; overflow: hidden; border-radius: 8px; transition: background-color 0.2s ease-in-out; background-color: #eceff1; color: #555; position: relative; line-height: 1; }
  .tile:not(.unknown):hover { transform: scale(1.05); box-shadow: 0 0 8px rgba(0, 0, 0, 0.1); z-index: 1; }
  .tile.unknown { background-color: #78909c; cursor: default; border-color: #546e7a; color: #cfd8dc; opacity: 0.85; }
  .tile.unknown:hover { transform: none; box-shadow: none; z-index: 0; }
  .unit-marker { border-radius: 50%; width: 70%; height: 70%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: white; position: absolute; z-index: 2; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); pointer-events: none; }
  .unit-marker.pawn { background-color: #3498db; } .unit-marker.worker { background-color: #e67e22; } .unit-marker.scout { background-color: #1abc9c; }
  .unit-marker.selected { outline: 3px solid #007bff; outline-offset: 2px; }

  /* Resource & Building Styles */
  .tile.grass { background-color: #aed581; color: #38761d; border-color: #9ccc65; }
  .tile.tree { background-color: #c8e6c9; color: #2e7d32; border-color: #a5d6a7; font-size: 32px; }
  .tile.stone { background-color: #95a5a6; color: #fff; }
  .tile.flint { background-color: #7f8c8d; color: #fff; }
  .tile.water { background-color: #5dade2; cursor: not-allowed; border-color: #3498db; }
  .tile.sand { background-color: #f7dc6f; color: #9a7d0a; border-color: #f1c40f; }
  .tile.house, .tile.farm, .tile.mine, .tile.quarry, .tile.warehouse { text-align: center; line-height: 55px; font-weight: bold; font-size: 10px; }
  .tile.farm { background-color: #f1c40f; color: #333; }
  .tile.mine { background-color: #607d8b; color: white; }
  .tile.house { background-color: #8e44ad; color: white; }
  .tile.quarry { background-color: #a1887f; color: white; border-color: #795548;}
  .tile.warehouse { background-color: #7f8c8d; color: white; border-color: #62757f; }

  /* Highlight Style */
  .highlight { background-color: rgba(52, 152, 219, 0.2) !important; border: 1px solid #3498db !important; }

  /* --- Buttons --- */
  button { padding: 12px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 8px; background-color: #3498db; color: white; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); font-weight: 600; }
  button:hover:not(:disabled) { background-color: #2980b9; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); transform: translateY(-1px); }
  button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  button:disabled { background-color: #bdc3c7; cursor: default; opacity: 0.7; }
  #action-button { background-color: #e67e22; margin-top: 5px; }
  #action-button:hover:not(:disabled) { background-color: #d35400; }
  /* Panel toggle buttons */
  #middle-controls button { background-color: #9b59b6; } #middle-controls button:hover:not(:disabled) { background-color: #8e44ad; }
  #middle-controls #tutorial-button { background-color: #f39c12; } #middle-controls #tutorial-button:hover:not(:disabled) { background-color: #e67e22; }
  #middle-controls #research-button { background-color: #2980b9; } #middle-controls #research-button:hover:not(:disabled) { background-color: #1f618d; }
  #middle-controls #buildings-button { background-color: #16a085; } #middle-controls #buildings-button:hover:not(:disabled) { background-color: #117a65; }
  #middle-controls #units-button { background-color: #27ae60; } #middle-controls #units-button:hover:not(:disabled) { background-color: #229954; }
  #middle-controls #upgrade-button { background-color: #c0392b; } #middle-controls #upgrade-button:hover:not(:disabled) { background-color: #a93226; }
  #middle-controls #logs-button { background-color: #34495e; } #middle-controls #logs-button:hover:not(:disabled) { background-color: #2c3e50; }
  #middle-controls #save-button { background-color: #2ecc71; } #middle-controls #save-button:hover:not(:disabled) { background-color: #27ae60; }
  #middle-controls #load-button { background-color: #f1c40f; } #middle-controls #load-button:hover:not(:disabled) { background-color: #d4ac0d; }
  /* Buttons within panels */
  .panel-content li button { background-color: #f1c40f; color: #333; padding: 8px 15px; font-size: 14px; width: auto; display: inline-block; margin-right: 5px; }
  .panel-content li button:hover:not(:disabled) { background-color: #f39c12; }
  .research-item button { background-color: #2ecc71; margin-bottom: 5px; }
  .research-item button:hover:not(:disabled) { background-color: #27ae60; }
  .research-item.completed button { background-color: #95a5a6; filter: grayscale(80%); cursor: default; }
  .research-item.completed button:hover:not(:disabled) { background-color: #95a5a6; }
  .research-item.completed .research-info { opacity: 0.7; }
  #units-list li button { background-color: #27ae60; color: white; } /* Unit deploy buttons */
  #units-list li button:hover:not(:disabled) { background-color: #229954; }
  #upgrade-info button { background-color: #c0392b; color: white; padding: 6px 10px; font-size: 13px; width: 100%; box-sizing: border-box; margin-top: 5px; border-radius: 5px; display: block; }
  #upgrade-info button:hover:not(:disabled) { background-color: #a93226; }

  /* --- Panels --- */
  .panel { text-align: left; background-color: #fdfefe; padding: 20px; border-radius: 12px; border: 1px solid #e4e9ed; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); max-height: 350px; overflow-y: auto; display: none; }
  #inventory { display: block; max-height: none; overflow-y: visible; }
  #logs-panel { max-height: 250px; }
  .panel h2 { font-size: 20px; color: #2c3e50; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
  .panel ul { list-style-type: none; padding: 0; margin: 0; }
  .panel li { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
  .panel li:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
  .panel p.description { font-size: 13px; color: #777; margin-top: 0; margin-bottom: 0; }

  /* Specific Panel Styles */
  #inventory p { font-size: 16px; color: #555; margin-bottom: 8px; line-height: 1.4; } #inventory span { font-weight: bold; color: #333; }
  #tech-tree h3 { font-size: 18px; color: #3498db; margin-bottom: 10px; }
   .research-item .research-info { margin-top: 5px; font-size: 13px; color: #555; }
   .research-item .research-cost { font-weight: bold; margin-bottom: 3px; margin-top: 0; }
   .research-item .description { margin-top: 0; margin-bottom: 0; }
   .panel-content .building-cost { font-size: 13px; font-weight: bold; color: #777; margin-top: 4px; margin-bottom: 2px; }
   .panel-content #buildings-list .description { margin-top: 2px; }

  #logs-list { list-style-type: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.5; color: #555; margin-top: 10px; }
  #logs-list li { padding: 4px 0; border-bottom: 1px dashed #eee; white-space: pre-wrap; } #logs-list li:last-child { border-bottom: none; }
  #logs-list .log-time { display: inline-block; width: 50px; color: #888; margin-right: 5px; }
  #log-search-input { width: 100%; padding: 8px 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 14px; }
  #log-filter-container { display: block; margin-bottom: 10px; font-size: 14px; color: #555; }
  #log-filter-checkbox { margin-right: 5px; vertical-align: middle; }

  /* --- Other UI --- */
  #colony-name-display { font-size: 22px; color: #2c3e50; font-weight: bold; margin-bottom: 0; text-align: left; padding: 10px; background-color: #ecf0f1; border-radius: 8px; }
  #resource-name { margin-top: 15px; font-size: 16px; font-weight: bold; color: #7f8c8d; min-height: 20px; text-align: left; }
  /* Containers for right panel static info */
  #unit-biome-display-container, #unit-coords-display-container, #unit-exp-display-container, #research-points-display-container, #research-status-display {
       font-size: 16px; font-weight: bold; text-align: left;
       padding: 10px; border-radius: 8px; margin-bottom: 10px;
   }
  #unit-biome-display-container { color: #16a085; background-color: #e8f8f5; } #unit-biome-display-container span { font-weight: normal; color: #117a65; text-transform: capitalize; }
  #unit-coords-display-container { color: #34495e; background-color: #ecf0f1; } #unit-coords-display-container span { font-weight: normal; color: #2c3e50; }
  #unit-exp-display-container { color: #e67e22; background-color: #fef5e7; } #unit-exp-display-container span { font-weight: normal; color: #d35400; }
  #research-points-display-container { color: #8e44ad; background-color: #f3eaf7; /* Moved up */ margin-bottom: 5px; /* Reduced bottom margin */ }
  #research-status-display { /* Moved up */
        font-size: 14px; font-weight: bold; color: #27ae60;
        min-height: 18px; padding: 5px 10px; background-color: #e8f8f5;
        border-radius: 6px; border: 1px solid #a3e4d7;
        margin-top: 0; /* Removed top margin */
        margin-bottom: 10px; /* Keep bottom margin before logs */
    }
  #upgrade-info { /* Style kept same, position relative to others changes */
        margin-top: 10px; text-align: left; background-color: #f9ebea;
        padding: 15px; border-radius: 8px; border: 1px solid #f5b7b1; min-height: 50px;
    }
  #upgrade-info h4 { font-size: 15px; margin-top: 0; margin-bottom: 10px; color: #a93226; border-bottom: 1px solid #e6b0aa; padding-bottom: 5px;}
  #upgrade-info p { font-size: 13px; color: #555; margin-top: 5px; }

  /* --- Progress Bars --- */
  .research-progress-container { width: 100%; height: 10px; border: 1px solid #bdc3c7; margin-top: 5px; border-radius: 5px; background-color: #ecf0f1; overflow: hidden; display: none; align-items: center; }
  .research-progress-bar { width: 0%; height: 100%; border-radius: 4px 0 0 4px; transition: width 0.3s ease-in-out; }

  /* --- Tutorial Modal Styles --- */
  #tutorial-modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
  #tutorial-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 650px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); text-align: left; }
  #tutorial-content h2 { text-align: center; color: #2c3e50; margin-top: 0; padding-bottom: 15px; border-bottom: 1px solid #eee; }
  #tutorial-steps { list-style-type: decimal; margin-left: 20px; padding-left: 15px; font-size: 15px; line-height: 1.6; color: #333; }
  #tutorial-steps li { margin-bottom: 12px; }
  #tutorial-steps code { background-color: #ecf0f1; padding: 2px 5px; border-radius: 4px; font-family: Consolas, monospace; color: #e67e22; font-weight: bold; }
  #close-tutorial-button { display: block; margin: 20px auto 0 auto; background-color: #e74c3c; padding: 10px 25px; }
  #close-tutorial-button:hover { background-color: #c0392b; }

  /* Tooltip Base Style */
  [data-tooltip] { position: relative; cursor: help; }
  [data-tooltip]::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px); background-color: rgba(50, 50, 50, 0.9); color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; pointer-events: none; }
  [data-tooltip]:hover::after { opacity: 1; visibility: visible; }

</style>
</head>
<body>
  <!-- Language Switch Button -->
  <div id="language-switcher">
      <button id="language-switch-button" title="Switch Language / Changer de langue"></button>
  </div>

  <h1>Tiny Civilization Evolved</h1>
  <div id="unit-display-bar"></div>

  <div id="game-container">
    <!-- === LEFT CONTAINER === -->
    <div id="left-container">
      <div id="colony-name-display">Colony Name</div>
      <div id="inventory">
        <h2>Inventory</h2>
        <!-- Inventory items will be generated by JS -->
      </div>
      <button id="action-button" style="display: none;">Gather Resource</button>
      <div id="resource-name"></div>
    </div>

    <!-- === MIDDLE CONTROLS === -->
    <div id="middle-controls">
         <button id="tutorial-button" data-panel-target="tutorial-modal">Tutorial</button>
         <button id="research-button" data-panel-target="tech-tree">Research</button>
         <button id="buildings-button" data-panel-target="buildings-list">Buildings</button>
         <button id="units-button" data-panel-target="units-panel">Units</button>
         <button id="upgrade-button" data-panel-target="upgrade-info">Upgrades</button>
         <button id="logs-button" data-panel-target="logs-panel">Logs</button>
         <button id="save-button">Save Game</button>
         <button id="load-button">Load Game</button>
         <input type="file" id="load-file-input" accept=".json" style="display: none;">
    </div>

    <!-- === GRID AREA === -->
    <div id="grid-area">
        <div id="grid" class="grid"></div>
        <div id="alert-message"></div>
    </div>

    <!-- === RIGHT CONTAINER === -->
    <div id="right-panel">
       <div id="unit-biome-display-container">Biome: <span id="unit-biome">Unknown</span></div>
       <div id="unit-coords-display-container">Coords: <span id="unit-coords">(-, -)</span></div>
       <div id="unit-exp-display-container">Exp: <span id="unit-exp">0</span></div>
       <!-- Research Info Moved Here -->
       <div id="research-points-display-container">Research Points: <span id="research-points">0</span></div>
       <div id="research-status-display"></div>

       <!-- Logs Panel -->
       <div id="logs-panel" class="panel">
           <h2>Event Logs</h2>
           <input type="text" id="log-search-input" placeholder="Search logs...">
           <div id="log-filter-container">
               <label><input type="checkbox" id="log-filter-checkbox"> Hide gather/cost messages</label>
           </div>
           <ul id="logs-list"></ul>
       </div>

       <!-- Other Toggleable Panels -->
       <div id="upgrade-info" class="panel">
           <h4>Unit Upgrades</h4>
           <div class="panel-content">
               <p>Select a unit to see upgrades.</p>
           </div>
       </div>
       <div id="tech-tree" class="panel">
         <h2>Tech Tree</h2>
         <div class="panel-content">
             <h3>Primitive Age</h3>
             <ul id="primitive-tech-list"></ul>
         </div>
       </div>
       <div id="buildings-list" class="panel">
           <h2>Buildings</h2>
           <div class="panel-content">
               <ul></ul>
           </div>
       </div>
       <div id="units-panel" class="panel">
           <h2>Available Units</h2>
           <div class="panel-content">
               <ul id="units-list"></ul> <!-- Deploy buttons regenerated here -->
           </div>
       </div>
       <!-- Static displays moved up -->
    </div>
  </div>

  <!-- === TUTORIAL MODAL === -->
  <div id="tutorial-modal" style="display: none;">
      <div id="tutorial-content">
          <h2 id="tutorial-title">How to Play (Basics)</h2>
          <ol id="tutorial-steps">
              <!-- Steps will be populated by JS -->
          </ol>
          <button id="close-tutorial-button">Close</button>
      </div>
  </div>

  <!-- Unit Choice Modal Removed -->


  <script>
    // --- Simplex Noise Library (Minimized) ---
    var SimplexNoise=(function(){var F2=0.5*(Math.sqrt(3.0)-1.0);var G2=(3.0-Math.sqrt(3.0))/6.0;var F3=1.0/3.0;var G3=1.0/6.0;var F4=(Math.sqrt(5.0)-1.0)/4.0;var G4=(5.0-Math.sqrt(5.0))/20.0;function Alea(){var s0=0;var s1=0;var s2=0;var c=1;var mash=Mash();s0=mash(' ');s1=mash(' ');s2=mash(' ');for(var i=0;i<arguments.length;i++){s0-=mash(arguments[i]);if(s0<0){s0+=1;} s1-=mash(arguments[i]);if(s1<0){s1+=1;} s2-=mash(arguments[i]);if(s2<0){s2+=1;}} mash=null;var random=function(){var t=2091639*s0+c*2.3283064365386963e-10;s0=s1;s1=s2;return s2=t-(c=t|0);};random.uint32=function(){return random()*0x100000000;};random.fract53=function(){return random()+(random()*0x200000|0)*1.1102230246251565e-16;};random.version='Alea 0.9';random.args=arguments;return random;} function Mash(){var n=0xefc8249d;var mash=function(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;} return(n>>>0)*2.3283064365386963e-10;};mash.version='Mash 0.9';return mash;} function SimplexNoise(random){if(!random)random=Math.random;this.p=new Uint8Array(256);this.perm=new Uint8Array(512);this.permMod12=new Uint8Array(512);for(var i=0;i<256;i++){this.p[i]=i;} for(i=0;i<255;i++){var r=i+~~(random()*(256-i));var aux=this.p[i];this.p[i]=this.p[r];this.p[r]=aux;} for(i=0;i<512;i++){this.perm[i]=this.p[i&255];this.permMod12[i]=this.perm[i]%12;}} SimplexNoise.prototype={grad3:new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),noise2D:function(xin,yin){var permMod12=this.permMod12;var perm=this.perm;var grad3=this.grad3;var n0=0;var n1=0;var n2=0;var s=(xin+yin)*F2;var i=Math.floor(xin+s);var j=Math.floor(yin+s);var t=(i+j)*G2;var X0=i-t;var Y0=j-t;var x0=xin-X0;var y0=yin-Y0;var i1,j1;if(x0>y0){i1=1;j1=0;}else{i1=0;j1=1;} var x1=x0-i1+G2;var y1=y0-j1+G2;var x2=x0-1.0+2.0*G2;var y2=y0-1.0+2.0*G2;var ii=i&255;var jj=j&255;var t0=0.5-x0*x0-y0*y0;if(t0>=0){var gi0=permMod12[ii+perm[jj]]*3;t0*=t0;n0=t0*t0*(grad3[gi0]*x0+grad3[gi0+1]*y0);} var t1=0.5-x1*x1-y1*y1;if(t1>=0){var gi1=permMod12[ii+i1+perm[jj+j1]]*3;t1*=t1;n1=t1*t1*(grad3[gi1]*x1+grad3[gi1+1]*y1);} var t2=0.5-x2*x2-y2*y2;if(t2>=0){var gi2=permMod12[ii+1+perm[jj+1]]*3;t2*=t2;n2=t2*t2*(grad3[gi2]*x2+grad3[gi2+1]*y2);} return 70.0*(n0+n1+n2);},};SimplexNoise.create=function(seed){if(seed){return new SimplexNoise(new Alea(seed));}else{return new SimplexNoise(Math.random);}};return SimplexNoise;})();
    // --- End Simplex Noise Library ---

    // --- DOM Element References (Cached) ---
    const DOMElements = {
        grid: document.getElementById('grid'), actionButton: document.getElementById('action-button'),
        inventoryDisplay: document.getElementById('inventory'),
        middleControls: document.getElementById('middle-controls'),
        techTree: document.getElementById('tech-tree'), buildingsList: document.getElementById('buildings-list'),
        unitsPanel: document.getElementById('units-panel'), logsPanel: document.getElementById('logs-panel'),
        upgradeInfoDisplay: document.getElementById('upgrade-info'), logsList: document.getElementById('logs-list'),
        logSearchInput: document.getElementById('log-search-input'), logFilterCheckbox: document.getElementById('log-filter-checkbox'),
        resourceNameDisplay: document.getElementById('resource-name'),
        researchPointsDisplayContainer: document.getElementById('research-points-display-container'), // Reference container now
        researchPointsDisplay: document.getElementById('research-points'),
        researchStatusDisplay: document.getElementById('research-status-display'), colonyNameDisplay: document.getElementById('colony-name-display'),
        alertMessageElement: document.getElementById('alert-message'), unitDisplayBar: document.getElementById('unit-display-bar'),
        unitBiomeDisplayContainer: document.getElementById('unit-biome-display-container'), // Reference container
        unitBiomeDisplay: document.getElementById('unit-biome'),
        unitCoordsDisplayContainer: document.getElementById('unit-coords-display-container'), // Reference container
        unitCoordsDisplay: document.getElementById('unit-coords'),
        unitExpDisplayContainer: document.getElementById('unit-exp-display-container'), // Reference container
        unitExpDisplay: document.getElementById('unit-exp'), loadFileInput: document.getElementById('load-file-input'),
        languageSwitchButton: document.getElementById('language-switch-button'),
        tutorialModal: document.getElementById('tutorial-modal'), tutorialTitle: document.getElementById('tutorial-title'),
        tutorialStepsList: document.getElementById('tutorial-steps'), closeTutorialButton: document.getElementById('close-tutorial-button'),
        primitiveTechList: document.getElementById('primitive-tech-list'), buildingsListUl: document.querySelector('#buildings-list ul'),
        unitsListUl: document.getElementById('units-list'), upgradeInfoContent: document.querySelector('#upgrade-info .panel-content'),
        saveButton: document.getElementById('save-button'), loadButton: document.getElementById('load-button')
        // unitChoiceModal removed
    };

    // --- Game Configuration ---
    const gameConfig = {
        gridSize: 10, viewCenterOffset: 5, revealRadiusBase: 2,
        maxLogEntries: 50, alertDuration: 3000,
        baseInventoryCapacity: { wood: 50, pebble: 50, flint: 30, wheat: 20, coal: 20, iron: 10, copper: 10, nickel: 10, zinc: 10 },
        eventChance: 0.01,
        expPerBuild: 3, expPerResearchComplete: 10, expPerEventDiscovery: 5,
        productionIntervals: { wheat: 5, coal: 7, quarry: 12 },
        noiseScales: { biome: 30.0, feature: 15.0, water: 40.0 },
        noiseThresholds: { biomeDesert: 0.3, lake: -0.3, treeForest: -0.1, flintForest: 0.0, stoneForest: 0.15 },
        desertStoneChance: 0.06,
        maxStartRegenAttempts: 10,
        units: {
            pawn: { nameKey: 'unitPawn', icon: 'P', build: ['house'], move: 1, revealRadius: 2, researchBonus: 1, upgrades: ['movement1', 'autoGather'] },
            worker: { nameKey: 'unitWorker', icon: 'W', build: ['farm', 'mine', 'quarry', 'warehouse'], move: 1, revealRadius: 2, researchBonus: 0, upgrades: ['movement1', 'autoGather', 'buildSpeed1'] },
            scout: { nameKey: 'unitScout', icon: 'S', build: [], move: 3, revealRadius: 3, researchBonus: 0, upgrades: ['movement1', 'autoGather'] }
        },
        buildings: {
            // House provides capacity again
            house: { nameKey: 'buildingHouse', cost: { wood: 10, pebble: 5 }, provides: { housingCapacity: 1 }, unlockedBy: 'settlement' },
            farm: { nameKey: 'buildingFarm', cost: { wood: 3 }, produces: { resource: 'wheat', interval: 'wheat' }, requires: 'worker', unlockedBy: 'agriculture' },
            mine: { nameKey: 'buildingMine', cost: { pebble: 5, wood: 2 }, produces: { resource: 'coal', interval: 'coal' }, requires: 'worker', unlockedBy: 'mining' },
            quarry: { nameKey: 'buildingQuarry', cost: { pebble: 15, wood: 5 }, produces: { resource: ['iron', 'copper', 'nickel', 'zinc'], interval: 'quarry' }, requires: 'worker', unlockedBy: 'masonry' },
            warehouse: { nameKey: 'buildingWarehouse', cost: { wood: 15, pebble: 10 }, provides: { capacityBonus: 50 }, unlockedBy: 'storage' }
        },
        tech: {
            settlement: { nameKey: 'researchSettlement', cost: 15, unlocks: ['house'], requires: [], age: 'primitive', color: '#8e44ad' },
            agriculture: { nameKey: 'researchAgriculture', cost: 10, unlocks: ['farm'], requires: [], age: 'primitive', color: '#aed581' },
            mining: { nameKey: 'researchMining', cost: 15, unlocks: ['mine'], requires: ['agriculture'], age: 'primitive', color: '#7f8c8d' },
            masonry: { nameKey: 'researchMasonry', cost: 20, unlocks: ['quarry'], requires: ['mining'], age: 'primitive', color: '#bcaaa4' },
            storage: { nameKey: 'researchStorage', cost: 25, unlocks: ['warehouse'], requires: ['masonry'], age: 'primitive', color: '#7f8c8d' },
            exploration: { nameKey: 'researchExploration', cost: 15, unlocks: ['scout'], requires: ['settlement'], age: 'primitive', color: '#1abc9c'}
        },
        upgrades: {
            movement1: { nameKey: 'upgradeMovement1', cost: 10, effect: { moveBonus: 1 }, maxLevel: 1 },
            autoGather: { nameKey: 'upgradeAutoGather', cost: 15, effect: { autoGather: true }, maxLevel: 1 },
        },
        resources: [
             { id: 'wood', nameKey: 'wood' }, { id: 'pebble', nameKey: 'pebble' }, { id: 'flint', nameKey: 'flint' },
             { id: 'wheat', nameKey: 'wheat' }, { id: 'coal', nameKey: 'coal' },
             { id: 'iron', nameKey: 'iron' }, { id: 'copper', nameKey: 'copper' }, { id: 'nickel', nameKey: 'nickel' }, { id: 'zinc', nameKey: 'zinc' }
        ]
    };

    // --- Game State Variables ---
    let gameState = {
        units: [], nextUnitId: 0, selectedUnitId: null,
        inventory: {}, inventoryCapacity: {},
        researchPoints: 0, activeResearch: null, completedTech: new Set(),
        housingCapacity: 0, // Renamed from maxWorkers/removed unitChoice
        selectedBuilding: null,
        productionProgress: { wheat: 0, coal: 0, quarry: 0 },
        colonyName: "New Colony", currentLanguage: 'en', eventLogs: [],
        viewOffsetX: 0, viewOffsetY: 0, worldData: {}, revealedTiles: new Set(),
        highlightEnabled: false, alertTimeout: null, gameInitialized: false
    };

    // --- Noise Generators ---
    let noise = { biome: null, feature: null, water: null };

    // --- Translations ---
    const translations = {
        en: {
            // ... (most keys same as before) ...
            researchSettlement: "Settlement", researchSettlementDesc: "Unlocks Houses (Housing Capacity +1).", // Updated
            researchExploration: "Exploration", researchExplorationDesc: "Allows Scouts to be deployed via Houses. Requires Settlement.", // Updated
            buildingHouse: "House", buildingHouseDesc: "Increases Housing Capacity by 1.", // Updated
            unitsPanelTitle: "Deploy Units", // Renamed slightly
            noUnitsAvailablePanel: "Research tech and build Houses to enable unit deployment.", // More specific
            deployUnitButton: "Deploy {0}", // Re-added use
            deployUnitRequiresTech: "Deploy {0} (Requires {1})", // Re-added use
            deployUnitRequiresHouse: "Deploy {0} (Requires Housing Capacity)", // Updated text
            deployUnitMax: "Max",
            alertMaxUnits: "Maximum Housing Capacity reached. Build more Houses.", // New alert key
            // Tutorial Updates
            tutorialTitle: "How to Play (Basics)",
            tutorialStep1: "Select your starting <code>Pawn</code> (blue 'P').",
            tutorialStep2: "Move by clicking an adjacent empty land tile.",
            tutorialStep3: "Move onto a <code>Tree</code> (🌳) or <code>Stone</code>.",
            tutorialStep4: "Click <code>Gather Resource</code> to collect Wood/Pebbles.",
            tutorialStep5: "Inventory starts empty. Gather resources. Note capacity limits.",
            tutorialStep6: "Click <code>Research</code>.",
            tutorialStep7: "Click <code>Settlement</code> to research it.",
            tutorialStep8: "Once done, click <code>Buildings</code>.",
            tutorialStep9: "Click <code>House</code>.",
            tutorialStep10: "Click an empty <code>Grass</code> tile near your Pawn to build.",
            tutorialStep11: "Houses increase <code>Housing Capacity</code>.", // Updated
            tutorialStep12: "Click <code>Units</code> (middle column).", // Updated
            tutorialStep13: "The <code>Deploy Worker</code> button should now be enabled (if you have capacity). Click it.", // Updated
            tutorialStep14: "A Worker ('W') appears near a House. They build Farms, Mines, etc. (after research).", // Updated
            tutorialStep15: "Research <code>Exploration</code>, then deploy a <code>Scout</code> ('S') via the Units panel (if you have housing capacity).", // Updated
            tutorialStep16: "Units gain <code>Exp</code>. Click <code>Upgrades</code> to spend Exp.",
        },
        fr: {
            // ... (most keys same as before - NEED THOROUGH UPDATE) ...
            researchSettlement: "Colonisation", researchSettlementDesc: "Débloque Maisons (Capacité Logement +1).", // Updated fr
            researchExploration: "Exploration", researchExplorationDesc: "Permet aux Éclaireurs d'être déployés via Maisons. Nécessite Colonisation.", // Updated fr
            buildingHouse: "Maison", buildingHouseDesc: "Augmente la Capacité de Logement de 1.", // Updated fr
            unitsPanelTitle: "Déployer Unités", // Updated fr
            noUnitsAvailablePanel: "Recherchez tech et construisez Maisons pour déployer.", // Updated fr
            deployUnitButton: "Déployer {0}", // Updated fr
            deployUnitRequiresTech: "Déployer {0} (Requiert {1})", // Updated fr
            deployUnitRequiresHouse: "Déployer {0} (Requiert Capacité Logement)", // Updated fr
            deployUnitMax: "Max",
            alertMaxUnits: "Capacité maximale de Logement atteinte. Construisez plus de Maisons.", // New alert key fr
            // Tutorial Updates fr (Need translation)
            tutorialTitle: "Comment Jouer (Bases)",
            tutorialStep1: "Sélectionnez votre <code>Colon</code> (bleu 'P').",
            tutorialStep2: "Déplacez-vous sur une case terrestre adjacente vide.",
            tutorialStep3: "Allez sur un <code>Arbre</code> (🌳) ou <code>Roche</code>.",
            tutorialStep4: "Cliquez <code>Récolter Ressource</code>.",
            tutorialStep5: "L'inventaire est vide au début. Récoltez. Notez les limites.",
            tutorialStep6: "Cliquez <code>Recherche</code>.",
            tutorialStep7: "Cliquez <code>Colonisation</code>.",
            tutorialStep8: "Une fois finie, cliquez <code>Bâtiments</code>.",
            tutorialStep9: "Cliquez <code>Maison</code>.",
            tutorialStep10: "Cliquez sur une case <code>Herbe</code> vide près du Colon.",
            tutorialStep11: "Les Maisons augmentent la <code>Capacité Logement</code>.", // Updated fr
            tutorialStep12: "Cliquez <code>Unités</code> (colonne milieu).", // Updated fr
            tutorialStep13: "Le bouton <code>Déployer Ouvrier</code> devrait être actif (si capacité). Cliquez.", // Updated fr
            tutorialStep14: "Un Ouvrier ('O') apparaît près d'une Maison. Ils construisent Fermes, etc.", // Updated fr
            tutorialStep15: "Recherchez <code>Exploration</code>, puis déployez un <code>Éclaireur</code> ('É') via le panneau Unités (si capacité logement).", // Updated fr
            tutorialStep16: "Unités gagnent <code>Exp</code>. Cliquez <code>Améliorations</code>.",
        }
        // Add other language keys here...
    };


    // --- Helper Functions ---
    const getLang = () => translations[gameState.currentLanguage] || translations.en;
    const getLangMsg = (key, args = []) => {
        let msg = getLang()[key] || key;
        args.forEach((arg, index) => {
            const translatedArg = getLang()[arg] !== undefined ? getLang()[arg] : arg;
            msg = msg.replace(`{${index}}`, translatedArg);
        });
        return msg;
    };
    const getFormattedTime = () => { const n = new Date(); return `${n.getHours().toString().padStart(2, '0')}:${n.getMinutes().toString().padStart(2, '0')}`; };

    function showAlert(messageKey, duration = gameConfig.alertDuration, logIt = true, args = []) {
        clearTimeout(gameState.alertTimeout);
        const message = getLangMsg(messageKey, args);
        if (logIt) {
            const timeString = getFormattedTime();
            const storedArgs = args.map(arg => (typeof arg === 'number' || typeof arg === 'boolean' || arg === null) ? arg : String(arg));
            gameState.eventLogs.push({ time: timeString, messageKey: messageKey, args: storedArgs, rendered: message });
            if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift();
            if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay();
        }
        DOMElements.alertMessageElement.textContent = message;
        DOMElements.alertMessageElement.style.display = 'block';
        void DOMElements.alertMessageElement.offsetWidth;
        DOMElements.alertMessageElement.classList.add('show');
        gameState.alertTimeout = setTimeout(() => {
            DOMElements.alertMessageElement.classList.remove('show');
             DOMElements.alertMessageElement.addEventListener('transitionend', function handleTransitionEnd() {
                 if (! DOMElements.alertMessageElement.classList.contains('show')) {
                      DOMElements.alertMessageElement.style.display = 'none';
                 }
             }, {once: true});
        }, duration);
    }

    function updateLogsDisplay() {
        DOMElements.logsList.innerHTML = '';
        const searchTerm = DOMElements.logSearchInput.value.toLowerCase();
        const hideFiltered = DOMElements.logFilterCheckbox.checked;
        const filteredLogs = gameState.eventLogs.filter(log => {
            const currentRendered = log.rendered || getLangMsg(log.messageKey, log.args);
            const messageLower = currentRendered.toLowerCase();
            const searchMatch = messageLower.includes(searchTerm);
            if (!searchMatch) return false;
            if (hideFiltered) {
                const isGather = log.messageKey === 'alertGathered' || log.messageKey === 'alertGatheredQuarry' || log.messageKey === 'alertGatheredEvent';
                const isCost = log.messageKey === 'alertNotEnoughResources';
                const isExp = log.messageKey === 'logGainedExp' || log.messageKey === 'logGainedExpResearch' || log.messageKey === 'logGainedExpEvent';
                const isStorage = log.messageKey === 'alertStorageFull';
                if (isGather || isCost || isExp || isStorage) return false;
            }
            return true;
        });
        const fragment = document.createDocumentFragment();
        for (let i = filteredLogs.length - 1; i >= 0; i--) {
            const log = filteredLogs[i];
            const logEntry = document.createElement('li');
            const timeSpan = document.createElement('span'); timeSpan.className = 'log-time'; timeSpan.textContent = `[${log.time}]`;
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(document.createTextNode(` ${log.rendered || getLangMsg(log.messageKey, log.args)}`));
            fragment.appendChild(logEntry);
        }
        DOMElements.logsList.appendChild(fragment);
    }

    function initializeGridDOM() { /* ... (no changes) ... */
        const fragment = document.createDocumentFragment();
        for (let gy = 0; gy < gameConfig.gridSize; gy++) {
            for (let gx = 0; gx < gameConfig.gridSize; gx++) {
                const tile = document.createElement('div'); tile.className = 'tile'; tile.dataset.gridX = gx; tile.dataset.gridY = gy; fragment.appendChild(tile);
            }
        }
        DOMElements.grid.innerHTML = ''; DOMElements.grid.appendChild(fragment);
     }

    // --- World Generation & Visibility ---
    function getTileData(worldX, worldY) { return gameState.worldData[worldY]?.[worldX]; }
    function setTileData(worldX, worldY, data) { if (!gameState.worldData[worldY]) gameState.worldData[worldY] = {}; gameState.worldData[worldY][worldX] = data; }
    function generateTileContent(worldX, worldY) { /* ... (no changes) ... */
        const coordString = `${worldX},${worldY}`; if (getTileData(worldX, worldY)) { gameState.revealedTiles.add(coordString); return getTileData(worldX, worldY); } gameState.revealedTiles.add(coordString); let type = 'unknown'; let biome = 'forest'; const biomeNoiseVal = noise.biome.noise2D(worldX / gameConfig.noiseScales.biome, worldY / gameConfig.noiseScales.biome); if (biomeNoiseVal >= gameConfig.noiseThresholds.biomeDesert) { biome = 'desert'; } const waterNoiseVal = noise.water.noise2D(worldX / gameConfig.noiseScales.water, worldY / gameConfig.noiseScales.water); if (waterNoiseVal < gameConfig.noiseThresholds.lake) { type = 'water'; } else { const featureNoiseVal = noise.feature.noise2D(worldX / gameConfig.noiseScales.feature, worldY / gameConfig.noiseScales.feature); if (biome === 'forest') { if (featureNoiseVal < gameConfig.noiseThresholds.treeForest) type = 'tree'; else if (featureNoiseVal < gameConfig.noiseThresholds.flintForest) type = 'flint'; else if (featureNoiseVal < gameConfig.noiseThresholds.stoneForest) type = 'stone'; else type = 'grass'; } else { type = 'sand'; if (Math.random() < gameConfig.desertStoneChance) type = 'stone'; } let isNearWater = false; for (let dy = -1; dy <= 1; dy++) { for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const neighborWaterNoise = noise.water.noise2D((worldX + dx) / gameConfig.noiseScales.water, (worldY + dy) / gameConfig.noiseScales.water); if (neighborWaterNoise < gameConfig.noiseThresholds.lake) { isNearWater = true; break; } } if (isNearWater) break; } if (isNearWater && type !== 'water') { type = 'sand'; } } if (Math.abs(worldX - 5) <= 1 && Math.abs(worldY - 5) <= 1) { type = 'grass'; biome = 'forest'; } if (worldX === 5 && worldY === 5) { type = 'grass'; biome = 'forest'; } const data = { type: type, building: null, biome: biome }; setTileData(worldX, worldY, data); return data;
    }
    function revealArea(centerX, centerY, radius) { /* ... (no changes) ... */
        let newlyRevealed = false; for (let dy = -radius; dy <= radius; dy++) { for (let dx = -radius; dx <= radius; dx++) { if (Math.sqrt(dx * dx + dy * dy) > radius) continue; const wx = centerX + dx; const wy = centerY + dy; const coordString = `${wx},${wy}`; if (!gameState.revealedTiles.has(coordString)) { generateTileContent(wx, wy); newlyRevealed = true; } } } return newlyRevealed;
     }

    // --- Update Functions ---
    function updateGrid() { /* ... (no changes) ... */
        const tiles = DOMElements.grid.querySelectorAll('.tile'); const lang = getLang(); const fragment = document.createDocumentFragment(); tiles.forEach(tile => { const existingMarker = tile.querySelector('.unit-marker'); if (existingMarker) existingMarker.remove(); tile.className = 'tile'; tile.textContent = ''; tile.title = ''; tile.classList.remove('highlight', 'unknown'); }); tiles.forEach(tile => { const gx = parseInt(tile.dataset.gridX); const gy = parseInt(tile.dataset.gridY); const worldX = gx + gameState.viewOffsetX; const worldY = gy + gameState.viewOffsetY; const coordString = `${worldX},${worldY}`; const isRevealed = gameState.revealedTiles.has(coordString); if (!isRevealed) { tile.classList.add('unknown'); } else { const data = getTileData(worldX, worldY); let tileTitle = lang.emptyTile; if (data) { tile.classList.add(data.type); tile.classList.add(`biome-${data.biome}`); if (data.building) { const buildingInfo = gameConfig.buildings[data.building]; tile.classList.add(data.building); tile.textContent = (buildingInfo?.nameKey ? lang[buildingInfo.nameKey] : data.building).substring(0, 4).toUpperCase(); tileTitle = lang[buildingInfo?.nameKey] || data.building; } else if (data.type === 'tree') { tile.textContent = '🌳'; tileTitle = lang.tileResourceTree; } else if (data.type === 'stone') { tileTitle = lang.tileResourceStone; } else if (data.type === 'flint') { tileTitle = lang.tileResourceFlint; } else if (data.type === 'water') { tileTitle = lang.water; } else if (data.type === 'sand') { tileTitle = lang.sand; } else if (data.type === 'grass') { tileTitle = lang.grass; } else { tileTitle = lang.emptyTile; } tile.title = tileTitle; } else { tile.classList.add('unknown'); console.warn(`Tile data missing for revealed tile at ${worldX}, ${worldY}`); } } }); gameState.units.forEach(unit => { const unitGridX = unit.worldX - gameState.viewOffsetX; const unitGridY = unit.worldY - gameState.viewOffsetY; if (unitGridX >= 0 && unitGridX < gameConfig.gridSize && unitGridY >= 0 && unitGridY < gameConfig.gridSize) { const tile = DOMElements.grid.querySelector(`.tile[data-grid-x="${unitGridX}"][data-grid-y="${unitGridY}"]`); if (tile && !tile.classList.contains('unknown')) { const unitInfo = gameConfig.units[unit.type]; const marker = document.createElement('div'); marker.className = `unit-marker ${unit.type}`; marker.textContent = unitInfo?.icon || unit.type.charAt(0).toUpperCase(); const translatedUnitType = lang[unitInfo?.nameKey] || unit.type; if (unit.id === gameState.selectedUnitId) { marker.classList.add('selected'); } tile.appendChild(marker); tile.title = tile.title && tile.title !== lang.emptyTile ? `${translatedUnitType} (${unit.id}) - ${tile.title}` : `${translatedUnitType} (${unit.id})`; } } }); const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId); if (gameState.highlightEnabled && selectedUnit) { const unitInfo = gameConfig.units[selectedUnit.type]; const unitGridX = selectedUnit.worldX - gameState.viewOffsetX; const unitGridY = selectedUnit.worldY - gameState.viewOffsetY; if (unitGridX >= 0 && unitGridX < gameConfig.gridSize && unitGridY >= 0 && unitGridY < gameConfig.gridSize) { let maxMove = unitInfo?.move || 1; if (selectedUnit.upgrades?.movement1) maxMove += gameConfig.upgrades.movement1.effect.moveBonus; tiles.forEach(tile => { const targetGridX = parseInt(tile.dataset.gridX); const targetGridY = parseInt(tile.dataset.gridY); const targetWorldX = targetGridX + gameState.viewOffsetX; const targetWorldY = targetGridY + gameState.viewOffsetY; const dist = Math.abs(targetGridX - unitGridX) + Math.abs(targetGridY - unitGridY); if (dist > 0 && dist <= maxMove && !tile.classList.contains('unknown')) { const targetData = getTileData(targetWorldX, targetWorldY); const targetOccupied = gameState.units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY); if (!targetOccupied && targetData?.type !== 'water') { tile.classList.add('highlight'); } } }); } } checkResource();
     }
    function updateInventoryDisplay() { /* ... (no changes) ... */
        const fragment = document.createDocumentFragment(); const lang = getLang(); const title = DOMElements.inventoryDisplay.querySelector('h2'); DOMElements.inventoryDisplay.innerHTML = ''; DOMElements.inventoryDisplay.appendChild(title); gameConfig.resources.forEach(resInfo => { const p = document.createElement('p'); const currentAmount = gameState.inventory[resInfo.id] || 0; const capacity = gameState.inventoryCapacity[resInfo.id] || 0; p.innerHTML = `${lang[resInfo.nameKey] || resInfo.id}: <span id="${resInfo.id}-count">${currentAmount}</span> / ${capacity}`; fragment.appendChild(p); }); DOMElements.inventoryDisplay.appendChild(fragment);
     }
    function updateResource(resourceId, amount) { /* ... (no changes) ... */
        const currentAmount = gameState.inventory[resourceId] || 0; const capacity = gameState.inventoryCapacity[resourceId] || 0; const newAmount = Math.max(0, currentAmount + amount); if (amount > 0 && newAmount > capacity) { gameState.inventory[resourceId] = capacity; if (currentAmount < capacity) { showAlert('alertStorageFull', 2000, true, [resourceId]); } return false; } else if (amount < 0 && newAmount < 0) { console.warn(`Attempted to spend more ${resourceId} than available.`); return false; } else { gameState.inventory[resourceId] = newAmount; updateInventoryDisplay(); return true; }
     }
    function canAfford(cost) { /* ... (no changes) ... */
        return Object.entries(cost).every(([resourceId, amount]) => (gameState.inventory[resourceId] || 0) >= amount);
     }
    function spendResources(cost) { /* ... (no changes) ... */
        if (!canAfford(cost)) return false; Object.entries(cost).forEach(([resourceId, amount]) => { updateResource(resourceId, -amount); }); return true;
     }
    function updateResearchPointsDisplay() { DOMElements.researchPointsDisplay.textContent = gameState.researchPoints; }
    function updateUnitInfoDisplay() { /* ... (no changes) ... */
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId); const lang = getLang(); if (selectedUnit) { DOMElements.unitCoordsDisplay.textContent = `(${selectedUnit.worldX}, ${selectedUnit.worldY})`; const tileData = getTileData(selectedUnit.worldX, selectedUnit.worldY); DOMElements.unitBiomeDisplay.textContent = tileData ? (lang[tileData.biome] || tileData.biome) : lang.unknownTile; DOMElements.unitExpDisplay.textContent = selectedUnit.exp || 0; } else { DOMElements.unitCoordsDisplay.textContent = `(-, -)`; DOMElements.unitBiomeDisplay.textContent = lang.unknownTile; DOMElements.unitExpDisplay.textContent = '0'; } DOMElements.upgradeInfoContent.innerHTML = ''; const upgradeTitle = document.createElement('h4'); upgradeTitle.textContent = lang.upgradeSectionTitle; DOMElements.upgradeInfoContent.appendChild(upgradeTitle); if (selectedUnit) { const unitConf = gameConfig.units[selectedUnit.type]; let upgradesAdded = 0; (unitConf.upgrades || []).forEach(upgradeId => { const upgradeConf = gameConfig.upgrades[upgradeId]; if (!upgradeConf) return; const currentLevel = selectedUnit.upgrades?.[upgradeId] || 0; if (currentLevel < upgradeConf.maxLevel) { const cost = upgradeConf.cost; const upgradeButton = document.createElement('button'); upgradeButton.dataset.upgradeType = upgradeId; upgradeButton.textContent = `${getLangMsg(upgradeConf.nameKey)} (${cost} Exp)`; upgradeButton.disabled = selectedUnit.exp < cost; upgradeButton.title = getLangMsg(upgradeConf.nameKey + 'Desc', [cost]); upgradeButton.addEventListener('click', handleUpgradeClick); DOMElements.upgradeInfoContent.appendChild(upgradeButton); upgradesAdded++; } }); if (upgradesAdded === 0) { const noUpgradeText = document.createElement('p'); noUpgradeText.textContent = lang.upgradeNoUpgradesAvailable; DOMElements.upgradeInfoContent.appendChild(noUpgradeText); } } else { const selectUnitText = document.createElement('p'); selectUnitText.textContent = lang.upgradeInfoSelectUnit; DOMElements.upgradeInfoContent.appendChild(selectUnitText); }
     }
    function updateResearchUI() { /* ... (no changes other than adding .completed class) ... */
        const lang = getLang(); const isResearching = !!gameState.activeResearch; DOMElements.primitiveTechList.innerHTML = ''; Object.entries(gameConfig.tech).filter(([id, tech]) => tech.age === 'primitive').forEach(([id, tech]) => { const isCompleted = gameState.completedTech.has(id); const canResearch = !isResearching && !isCompleted && tech.requires.every(req => gameState.completedTech.has(req)); const listItem = document.createElement('li'); listItem.className = 'research-item'; if (isCompleted) listItem.classList.add('completed'); const button = document.createElement('button'); button.id = `${id}-research`; button.dataset.techId = id; button.textContent = lang[tech.nameKey] || id; button.disabled = !canResearch || isCompleted; button.title = lang[tech.nameKey] || id; if (isCompleted) { button.textContent += ` ${lang.researchStatusComplete}`; } button.addEventListener('click', () => handleResearchClick(id)); const progressContainer = document.createElement('div'); progressContainer.id = `${id}-research-progress`; progressContainer.className = 'research-progress-container'; progressContainer.style.display = (gameState.activeResearch === id) ? 'flex' : 'none'; const progressBar = document.createElement('div'); progressBar.id = `${id}-research-bar`; progressBar.className = 'research-progress-bar'; progressBar.style.backgroundColor = tech.color || '#3498db'; const infoContainer = document.createElement('div'); infoContainer.className = 'research-info'; const costP = document.createElement('p'); costP.className = 'research-cost'; costP.textContent = `Cost: ${tech.cost} RP`; const descP = document.createElement('p'); descP.className = 'description'; descP.textContent = getLangMsg(tech.nameKey + 'Desc'); progressContainer.appendChild(progressBar); listItem.appendChild(button); listItem.appendChild(progressContainer); infoContainer.appendChild(costP); infoContainer.appendChild(descP); listItem.appendChild(infoContainer); if (gameState.activeResearch === id) { const progress = Math.min(100, tech.cost > 0 ? (gameState.researchPoints / tech.cost) * 100 : 100); progressBar.style.width = progress + '%'; DOMElements.researchStatusDisplay.textContent = getLangMsg('researchStatusResearching') + ` ${lang[tech.nameKey] || id}... ${Math.floor(progress)}%`; } DOMElements.primitiveTechList.appendChild(listItem); }); if (!isResearching && DOMElements.researchStatusDisplay.textContent.startsWith(lang.researchStatusResearching)) { DOMElements.researchStatusDisplay.textContent = ''; } else if (!isResearching && gameState.completedTech.size === 0) { DOMElements.researchStatusDisplay.textContent = lang.researchStatusInitial; } DOMElements.researchStatusDisplay.style.display = DOMElements.researchStatusDisplay.textContent ? 'block' : 'none';
     }
    function updateResearchProgress() { /* ... (no changes) ... */
        if (!gameState.activeResearch) return; const techId = gameState.activeResearch; const tech = gameConfig.tech[techId]; if (!tech) { gameState.activeResearch = null; return; } const progress = Math.min(100, tech.cost > 0 ? (gameState.researchPoints / tech.cost) * 100 : 100); const progressBar = document.getElementById(`${techId}-research-bar`); if (progressBar) { progressBar.style.width = progress + '%'; } DOMElements.researchStatusDisplay.textContent = getLangMsg('researchStatusResearching') + ` ${getLangMsg(tech.nameKey)}... ${Math.floor(progress)}%`; DOMElements.researchStatusDisplay.style.display = 'block'; if (gameState.researchPoints >= tech.cost) { gameState.completedTech.add(techId); gameState.activeResearch = null; gameState.researchPoints = 0; showAlert('alertResearchComplete', 3500, true, [tech.nameKey]); DOMElements.researchStatusDisplay.textContent = `${getLangMsg(tech.nameKey)} ${getLangMsg('researchStatusComplete')}`; let expGained = false; gameState.units.forEach(unit => { const unitConf = gameConfig.units[unit.type]; if (unitConf?.researchBonus > 0) { unit.exp = (unit.exp || 0) + gameConfig.expPerResearchComplete * unitConf.researchBonus; expGained = true; } }); if (expGained) { logEvent('logGainedExpResearch', ['unitPawn', gameConfig.expPerResearchComplete, tech.nameKey]); if(gameState.units.find(u => u.id === gameState.selectedUnitId)?.type === 'pawn') updateUnitInfoDisplay(); } updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateInventoryCapacity(); updateResearchPointsDisplay(); }
     }
    function updateBuildingsList() { /* ... (no changes) ... */
        const listElement = DOMElements.buildingsListUl; listElement.innerHTML = ''; const lang = getLang(); let availableBuildings = 0; Object.entries(gameConfig.buildings).forEach(([id, building]) => { if (building.unlockedBy && !gameState.completedTech.has(building.unlockedBy)) { return; } availableBuildings++; const listItem = document.createElement('li'); const button = document.createElement('button'); const costString = Object.entries(building.cost).map(([res, amount]) => `${amount} ${lang[res] || res}`).join(', '); button.textContent = `${lang[building.nameKey] || id}`; button.dataset.building = id; button.title = lang[building.nameKey] || id; button.disabled = !canAfford(building.cost); button.addEventListener('click', () => { gameState.selectedBuilding = id; showAlert('alertBuildSelected', 4000, true, [building.nameKey]); gameState.highlightEnabled = true; updateGrid(); updateBuildingsList(); }); const costP = document.createElement('p'); costP.className = 'building-cost'; costP.textContent = `Cost: ${costString}`; const description = document.createElement('p'); description.className = 'description'; description.textContent = getLangMsg(building.nameKey + 'Desc'); listItem.appendChild(button); listItem.appendChild(costP); listItem.appendChild(description); listElement.appendChild(listItem); }); if (availableBuildings === 0) { listElement.innerHTML = `<li>${lang.noBuildingsAvailable}</li>`; }
     }
    function updateUnitDisplayBar() { /* ... (no changes) ... */
        DOMElements.unitDisplayBar.innerHTML = ''; const lang = getLang(); const fragment = document.createDocumentFragment(); gameState.units.forEach(unit => { const unitInfo = gameConfig.units[unit.type]; const icon = document.createElement('div'); icon.className = `unit-icon ${unit.type}`; icon.dataset.unitId = unit.id; icon.dataset.unitType = unit.type; icon.textContent = unitInfo?.icon || unit.type.charAt(0).toUpperCase(); const translatedUnitType = lang[unitInfo?.nameKey] || unit.type; icon.title = `${translatedUnitType} (${unit.id})`; if (unit.id === gameState.selectedUnitId) { icon.classList.add('selected'); } icon.addEventListener('click', () => { gameState.selectedUnitId = unit.id; focusOnUnit(unit.id); gameState.selectedBuilding = null; gameState.highlightEnabled = false; }); fragment.appendChild(icon); }); DOMElements.unitDisplayBar.appendChild(fragment);
     }

    // Updated to show deploy buttons based on housing capacity
    function updateUnitsPanel() {
        const listElement = DOMElements.unitsListUl;
        listElement.innerHTML = ''; // Clear list
        const lang = getLang();
        let deployableUnitsShown = 0;

        const currentDeployedCount = gameState.units.filter(u => u.type === 'worker' || u.type === 'scout').length;
        const capacity = gameState.housingCapacity;
        const canDeployMore = currentDeployedCount < capacity;

        // Worker Deployment Button
        if (gameState.completedTech.has('settlement')) { // Worker implicitly available with house tech
             const unitId = 'worker';
             const unitConf = gameConfig.units[unitId];
             const listItem = document.createElement('li');
             const button = document.createElement('button');
             button.dataset.unitType = unitId;

             let buttonText = `${lang[unitConf.nameKey]} (${currentDeployedCount}/${capacity})`;
             let isDisabled = !canDeployMore;
             let tooltip = lang[unitConf.nameKey + 'Desc'] || ''; // Base tooltip
             if (!canDeployMore) {
                 tooltip = lang.alertMaxUnits;
             }

             button.textContent = buttonText;
             button.disabled = isDisabled;
             button.title = tooltip; // Set tooltip
             button.addEventListener('click', handleDeployUnitClick); // Add listener back

             listItem.appendChild(button);
             listElement.appendChild(listItem);
             deployableUnitsShown++;
        }

         // Scout Deployment Button
         const scoutTechReq = 'exploration';
         if (gameState.completedTech.has(scoutTechReq)) {
             const unitId = 'scout';
             const unitConf = gameConfig.units[unitId];
             const listItem = document.createElement('li');
             const button = document.createElement('button');
             button.dataset.unitType = unitId;

             let buttonText = `${lang[unitConf.nameKey]} (${currentDeployedCount}/${capacity})`;
             let isDisabled = !canDeployMore;
             let tooltip = lang[unitConf.nameKey + 'Desc'] || '';
              if (!canDeployMore) {
                  tooltip = lang.alertMaxUnits;
              } else {
                  tooltip += ` (${lang.researchExploration})`; // Add tech info
              }


             button.textContent = buttonText;
             button.disabled = isDisabled;
             button.title = tooltip;
             button.addEventListener('click', handleDeployUnitClick); // Add listener back

             listItem.appendChild(button);
             listElement.appendChild(listItem);
             deployableUnitsShown++;
         }


         if (deployableUnitsShown === 0) {
             listElement.innerHTML = `<li>${lang.noUnitsAvailablePanel}</li>`;
         }
    }

     function updateInventoryCapacity() { /* ... (no changes) ... */
         gameState.inventoryCapacity = { ...gameConfig.baseInventoryCapacity }; let warehouseBonus = 0; gameState.revealedTiles.forEach(coordString => { const [x, y] = coordString.split(',').map(Number); const data = getTileData(x, y); if (data?.building === 'warehouse') { warehouseBonus += gameConfig.buildings.warehouse.provides.capacityBonus || 0; } }); for (const resId in gameState.inventoryCapacity) { gameState.inventoryCapacity[resId] += warehouseBonus; } updateInventoryDisplay();
      }

    // --- Gameplay Functions ---
    function checkResource() { /* ... (no changes) ... */
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId); let canGather = false; let tileName = getLang().noUnitSelected; if (selectedUnit) { const data = getTileData(selectedUnit.worldX, selectedUnit.worldY); tileName = getLang().unknownTile; if (data && !data.building) { const unitType = selectedUnit.type; if (unitType === 'pawn' || unitType === 'worker' || unitType === 'scout') { if (data.type === 'tree' || data.type === 'stone' || data.type === 'flint') { canGather = true; } } const lang = getLang(); if (data.type === 'tree') { tileName = `${lang.onTile} ${lang.tileResourceTree}`; } else if (data.type === 'stone') { tileName = `${lang.onTile} ${lang.tileResourceStone}`; } else if (data.type === 'flint') { tileName = `${lang.onTile} ${lang.tileResourceFlint}`; } else if (data.type === 'water') { tileName = `${lang.onTile} ${lang.water}`; } else if (data.type === 'sand') { tileName = `${lang.onTile} ${lang.sand}`; } else if (data.type === 'grass') { tileName = `${lang.onTile} ${lang.grass}`; } else { tileName = `${lang.onTile} ${lang.emptyTile}`; } } else if (data && data.building) { const bInfo = gameConfig.buildings[data.building]; tileName = `${getLang().onTile} ${getLangMsg(bInfo?.nameKey) || data.building}`; } } DOMElements.actionButton.style.display = canGather ? 'inline-block' : 'none'; DOMElements.resourceNameDisplay.textContent = tileName;
     }
    function triggerRandomEvent(unit) { /* ... (no changes) ... */
        if (Math.random() < gameConfig.eventChance) { let foundSpot = false; for (let range = 1; range <= 2 && !foundSpot; range++) { for (let dy = -range; dy <= range; dy++) { for (let dx = -range; dx <= range; dx++) { if (Math.abs(dx) + Math.abs(dy) !== range) continue; const tx = unit.worldX + dx; const ty = unit.worldY + dy; const tData = getTileData(tx, ty); const coordString = `${tx},${ty}`; if (gameState.revealedTiles.has(coordString) && tData && tData.type !== 'water' && !tData.building && !gameState.units.some(u => u.worldX === tx && u.worldY === ty)) { const resourceTypes = ['wood', 'pebble', 'flint']; const resource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)]; const amount = Math.floor(Math.random() * 5) + 2; if (updateResource(resource, amount)) { showAlert('alertGatheredEvent', 3000, true, [resource, amount]); unit.exp = (unit.exp || 0) + gameConfig.expPerEventDiscovery; logEvent('logGainedExpEvent', [unit.id, gameConfig.expPerEventDiscovery]); if(unit.id === gameState.selectedUnitId) updateUnitInfoDisplay(); foundSpot = true; break; } } } if (foundSpot) break; } }
     }
    function moveUnit(targetGridX, targetGridY) { /* ... (no changes) ... */
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId); if (!selectedUnit) return; const targetWorldX = targetGridX + gameState.viewOffsetX; const targetWorldY = targetGridY + gameState.viewOffsetY; const unitInfo = gameConfig.units[selectedUnit.type]; let maxMove = unitInfo?.move || 1; if (selectedUnit.upgrades?.movement1) maxMove += gameConfig.upgrades.movement1.effect.moveBonus; const dx = Math.abs(targetWorldX - selectedUnit.worldX); const dy = Math.abs(targetWorldY - selectedUnit.worldY); if (dx + dy > maxMove) { return; } if (!gameState.revealedTiles.has(`${targetWorldX},${targetWorldY}`)) return; const targetData = getTileData(targetWorldX, targetWorldY); if (!targetData || targetData.type === 'water') { showAlert('alertMoveInvalid', 1500, false); return; } const targetOccupied = gameState.units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY); if (targetOccupied) { showAlert("alertUnitMoveOccupied", 2000, false); return; } selectedUnit.worldX = targetWorldX; selectedUnit.worldY = targetWorldY; revealArea(targetWorldX, targetWorldY, unitInfo?.revealRadius || gameConfig.revealRadiusBase); if (selectedUnit.upgrades?.autoGather) { tryAutoGather(selectedUnit); } if (gameState.activeResearch) { const researchBonus = unitInfo?.researchBonus || 0; gameState.researchPoints += researchBonus; if(researchBonus > 0) updateResearchProgress(); } updateResearchPointsDisplay(); for (const prodType in gameState.productionProgress) { gameState.productionProgress[prodType]++; const interval = gameConfig.productionIntervals[prodType]; if (gameState.productionProgress[prodType] >= interval) { produceResources(prodType); gameState.productionProgress[prodType] = 0; } } triggerRandomEvent(selectedUnit); if (selectedUnit.id === gameState.selectedUnitId) { focusOnUnit(selectedUnit.id); } else { updateGrid(); }
     }
    function tryAutoGather(unit) { /* ... (no changes) ... */
        const data = getTileData(unit.worldX, unit.worldY); if (data && !data.building && (data.type === 'tree' || data.type === 'stone' || data.type === 'flint')) { gatherResource(unit, true); }
     }
    function gatherResource(unit = null, auto = false) { /* ... (updated alert args) ... */
        const targetUnit = unit || gameState.units.find(u => u.id === gameState.selectedUnitId); if (!targetUnit) { if (!auto) showAlert("noUnitSelected", 2000); return; } const data = getTileData(targetUnit.worldX, targetUnit.worldY); if (data && !data.building) { let gatheredResourceKey = null; let baseTerrain = data.biome === 'desert' ? 'sand' : 'grass'; let quantity = 1; if (data.type === 'tree') gatheredResourceKey = 'wood'; else if (data.type === 'stone') gatheredResourceKey = 'pebble'; else if (data.type === 'flint') gatheredResourceKey = 'flint'; if (gatheredResourceKey) { if (updateResource(gatheredResourceKey, quantity)) { data.type = baseTerrain; setTileData(targetUnit.worldX, targetUnit.worldY, data); const langResourceName = getLangMsg(gatheredResourceKey); if (!auto) showAlert('alertGathered', 1500, true, [langResourceName, quantity]); else logEvent('alertGathered', [langResourceName, quantity], `[Auto] ${getLangMsg('alertGathered', [langResourceName, quantity])}`); updateGrid(); checkResource(); } else { if (!auto) showAlert('alertStorageFull', 2000, true, [getLangMsg(gatheredResourceKey)]); } } }
     }
    function produceResources(productionType) { /* ... (no changes) ... */
         let producedCount = 0; gameState.revealedTiles.forEach(coordString => { const [x, y] = coordString.split(',').map(Number); const data = getTileData(x, y); if (!data || !data.building) return; const buildingConf = gameConfig.buildings[data.building]; if (!buildingConf || !buildingConf.produces || buildingConf.produces.interval !== productionType) return; let canProduce = true; if(canProduce) { if (Array.isArray(buildingConf.produces.resource)) { const metalKey = buildingConf.produces.resource[Math.floor(Math.random() * buildingConf.produces.resource.length)]; if (updateResource(metalKey, 1)) { if (producedCount === 0) showAlert('alertGatheredQuarry', 2000, true, [metalKey]); producedCount++; } else { if (producedCount === 0) showAlert('alertStorageFull', 2000, true, [metalKey]); } } else { const resourceKey = buildingConf.produces.resource; if (updateResource(resourceKey, 1)) { producedCount++; } else { if (producedCount === 0) showAlert('alertStorageFull', 2000, true, [resourceKey]); } } } });
      }

    // Modified to find ANY house anchor
    function findSpawnPoint(anchorType = 'unit') {
        let anchorCoords = [];

        if (anchorType === 'houseAnchor') {
            gameState.revealedTiles.forEach(coordString => {
                 const [x, y] = coordString.split(',').map(Number);
                 if (getTileData(x,y)?.building === 'house') {
                     anchorCoords.push({x, y});
                 }
             });
             if (anchorCoords.length === 0) return null; // No houses found
        } else { // Default: Spawn near first unit
             if (gameState.units.length > 0) {
                 anchorCoords.push({ x: gameState.units[0].worldX, y: gameState.units[0].worldY });
             } else return null;
        }

        // Check adjacent tiles around ALL found anchors until a spot is free
        for (const anchor of anchorCoords) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const sx = anchor.x + dx;
                    const sy = anchor.y + dy;
                    const sData = getTileData(sx, sy);
                    const coordString = `${sx},${sy}`;
                    const isOccupied = gameState.units.some(u => u.worldX === sx && u.worldY === sy);

                    if (gameState.revealedTiles.has(coordString) && sData && (sData.type === 'grass' || sData.type === 'sand' || sData.type === 'empty') && !isOccupied && !sData.building) {
                        return { worldX: sx, worldY: sy }; // Found a valid spot
                    }
                }
            }
        }
        return null; // No suitable spot found near any anchor
    }

    // --- Unit Focusing ---
    function focusOnUnit(unitId) { /* ... (no changes) ... */
        const unit = gameState.units.find(u => u.id === unitId); if (!unit) return; const unitConf = gameConfig.units[unit.type]; const newViewOffsetX = unit.worldX - gameConfig.viewCenterOffset; const newViewOffsetY = unit.worldY - gameConfig.viewCenterOffset; const viewChanged = newViewOffsetX !== gameState.viewOffsetX || newViewOffsetY !== gameState.viewOffsetY; gameState.viewOffsetX = newViewOffsetX; gameState.viewOffsetY = newViewOffsetY; const newlyRevealed = revealArea(unit.worldX, unit.worldY, unitConf?.revealRadius || gameConfig.revealRadiusBase); gameState.selectedUnitId = unitId; updateUnitDisplayBar(); updateUnitInfoDisplay(); if (viewChanged || newlyRevealed) { updateGrid(); } else { updateGrid(); } checkResource();
     }

    // --- Event Log Helper ---
     function logEvent(messageKey, args = [], renderedOverride = null) { /* ... (no changes) ... */
         const timeString = getFormattedTime(); const message = renderedOverride !== null ? renderedOverride : getLangMsg(messageKey, args); const storedArgs = args.map(arg => (typeof arg === 'number' || typeof arg === 'boolean' || arg === null) ? arg : String(arg)); gameState.eventLogs.push({ time: timeString, messageKey: messageKey, args: storedArgs, rendered: message }); if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift(); if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay();
      }

    // --- Event Listeners ---
    function setupEventListeners() { /* ... (no changes except handleDeployUnitClick listener added in updateUnitsPanel) ... */
        DOMElements.grid.addEventListener('click', (event) => { const tile = event.target.closest('.tile'); if (tile && !tile.classList.contains('unknown')) { const gridX = parseInt(tile.dataset.gridX); const gridY = parseInt(tile.dataset.gridY); const worldX = gridX + gameState.viewOffsetX; const worldY = gridY + gameState.viewOffsetY; const clickedUnit = gameState.units.find(u => u.worldX === worldX && u.worldY === worldY); if (clickedUnit) { gameState.selectedUnitId = clickedUnit.id; gameState.selectedBuilding = null; gameState.highlightEnabled = false; focusOnUnit(clickedUnit.id); showAlert('alertSelectedUnit', 1500, false, [gameConfig.units[clickedUnit.type]?.nameKey || clickedUnit.type, clickedUnit.id]); } else if (gameState.selectedBuilding) { handlePlaceBuilding(worldX, worldY); } else if (gameState.selectedUnitId) { moveUnit(gridX, gridY); } if (!gameState.selectedBuilding) gameState.highlightEnabled = false; } }); DOMElements.actionButton.addEventListener('click', () => gatherResource(null, false)); DOMElements.middleControls.addEventListener('click', (event) => { const button = event.target.closest('button[data-panel-target]'); if (button) { togglePanel(button.dataset.panelTarget); } }); DOMElements.closeTutorialButton.addEventListener('click', () => { DOMElements.tutorialModal.style.display = 'none'; }); DOMElements.tutorialModal.addEventListener('click', (event) => { if (event.target === DOMElements.tutorialModal) { DOMElements.tutorialModal.style.display = 'none'; } }); DOMElements.logSearchInput.addEventListener('input', updateLogsDisplay); DOMElements.logFilterCheckbox.addEventListener('change', updateLogsDisplay); DOMElements.saveButton.addEventListener('click', saveGame); DOMElements.loadButton.addEventListener('click', () => DOMElements.loadFileInput.click()); DOMElements.loadFileInput.addEventListener('change', loadGame); DOMElements.languageSwitchButton.addEventListener('click', switchLanguage); DOMElements.grid.addEventListener('mouseover', (event) => { const tile = event.target.closest('.tile'); if (tile && !tile.classList.contains('unknown') && gameState.selectedUnitId != null && !gameState.selectedBuilding) { gameState.highlightEnabled = true; updateGrid(); } }); DOMElements.grid.addEventListener('mouseout', (event) => { if (gameState.highlightEnabled && (!event.relatedTarget || !event.relatedTarget.closest || !event.relatedTarget.closest('#grid'))) { gameState.highlightEnabled = false; updateGrid(); } });
    }

    // --- Action Handlers ---
    function togglePanel(targetId) { /* ... (no changes) ... */
         const targetElement = document.getElementById(targetId); if (!targetElement) return; if (targetId === 'tutorial-modal') { hideAllPanels(); targetElement.style.display = 'block'; updateLanguageUI(); return; } const isVisible = targetElement.style.display === 'block'; hideAllPanels(); if (!isVisible) { targetElement.style.display = 'block'; if (targetId === 'tech-tree') updateResearchUI(); else if (targetId === 'buildings-list') updateBuildingsList(); else if (targetId === 'units-panel') updateUnitsPanel(); else if (targetId === 'upgrade-info') updateUnitInfoDisplay(); else if (targetId === 'logs-panel') updateLogsDisplay(); }
     }
    function hideAllPanels() { /* ... (no changes other than removing unit choice modal hide) ... */
         document.querySelectorAll('.panel:not(#inventory)').forEach(panel => { panel.style.display = 'none'; }); DOMElements.tutorialModal.style.display = 'none';
     }
    function handleResearchClick(techId) { /* ... (no changes) ... */
        const tech = gameConfig.tech[techId]; if (!tech || gameState.completedTech.has(techId) || gameState.activeResearch) { if(gameState.activeResearch) showAlert("alertAlreadyResearching", 3000, true, [gameConfig.tech[gameState.activeResearch]?.nameKey || gameState.activeResearch]); return; } if (!tech.requires.every(req => gameState.completedTech.has(req))) { return; } gameState.activeResearch = techId; gameState.researchPoints = 0; updateResearchPointsDisplay(); updateResearchUI(); showAlert("alertResearchStarted", 2500, true, [tech.nameKey]);
     }

    // Re-implemented Deployment from Panel click
     function handleDeployUnitClick(event) {
         const button = event.target;
         const unitType = button.dataset.unitType;
         if (!unitType || button.disabled) return; // Basic check

         const lang = getLang();
         const unitConf = gameConfig.units[unitType];

         // Double-check capacity
         const currentDeployedCount = gameState.units.filter(u => u.type === 'worker' || u.type === 'scout').length;
         if (currentDeployedCount >= gameState.housingCapacity) {
              showAlert("alertMaxUnits", 3000, true); // Use new alert
              return;
         }

         // Double-check tech (primarily for scout)
         if (unitType === 'scout' && !gameState.completedTech.has('exploration')) {
              console.warn("Attempted to deploy scout without Exploration tech."); // Should be prevented by button state
              return;
         }

         // Find a spawn point near *any* house
         const spawnDetails = findSpawnPoint('houseAnchor');

         if (spawnDetails && unitConf) {
             const newUnit = {
                 id: `unit-${gameState.nextUnitId++}`, type: unitType,
                 worldX: spawnDetails.worldX, worldY: spawnDetails.worldY,
                 exp: 0, upgrades: {}
             };
             gameState.units.push(newUnit);
             revealArea(newUnit.worldX, newUnit.worldY, unitConf?.revealRadius || gameConfig.revealRadiusBase);
             showAlert("alertUnitDeployed", 2000, true, [unitConf.nameKey]);

             updateGrid();
             updateUnitDisplayBar();
             updateUnitsPanel(); // Update counts/disabled states on the panel
         } else {
             // Use the more general "no space near house" message
             showAlert("alertNoSpaceForUnit", 3000, true, [unitConf?.nameKey || unitType]);
         }
     }


    function handlePlaceBuilding(worldX, worldY) {
        const builderUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        const buildingId = gameState.selectedBuilding;
        if (!builderUnit || !buildingId) { gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; }

        const buildingConf = gameConfig.buildings[buildingId];
        const builderConf = gameConfig.units[builderUnit.type];
        const lang = getLang();

        if (!builderUnit) { showAlert("alertSelectUnitToBuild", 2500); gameState.selectedBuilding = null; return; }
        if (!buildingConf) { console.error(`Invalid building selected: ${buildingId}`); gameState.selectedBuilding = null; return; }
        if (!builderConf?.build?.includes(buildingId)) { showAlert('alertUnitCannotBuild', 3000, true, [builderConf.nameKey, buildingConf.nameKey]); gameState.selectedBuilding = null; return; }

        const tileData = getTileData(worldX, worldY);
        let canPlace = true; let failReasonKey = ''; let failArgs = [];

        if (!tileData || (tileData.type !== 'grass' && tileData.type !== 'empty')) { canPlace = false; failReasonKey = 'alertCannotBuildNonEmpty'; if (tileData?.type === 'water' || tileData?.type === 'sand') { failReasonKey = 'alertCannotBuildOnTerrain'; failArgs = [tileData.type]; } else if (tileData?.type) { failReasonKey = 'alertCannotBuildOnResource'; failArgs = [lang[`tileResource${tileData.type.charAt(0).toUpperCase() + tileData.type.slice(1)}`] || tileData.type]; } }
        else if (tileData.building) { canPlace = false; failReasonKey = 'alertCannotBuildExists'; failArgs = [lang[gameConfig.buildings[tileData.building]?.nameKey] || tileData.building]; }

        if (!canPlace) { showAlert(failReasonKey || 'alertCannotBuildNonEmpty', 3000, true, failArgs); gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; }
        if (!spendResources(buildingConf.cost)) { showAlert('alertNotEnoughResources', 3000, true, [buildingConf.nameKey]); gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; }

        // --- Placement Success ---
        tileData.building = buildingId;
        setTileData(worldX, worldY, tileData);
        showAlert('alertBuildingBuilt', 2500, true, [buildingConf.nameKey]);
        gameState.selectedBuilding = null; gameState.highlightEnabled = false;

        // Grant XP
        builderUnit.exp = (builderUnit.exp || 0) + gameConfig.expPerBuild;
        logEvent('logGainedExp', [builderConf.nameKey, builderUnit.id, gameConfig.expPerBuild, buildingConf.nameKey]);
        if (builderUnit.id === gameState.selectedUnitId) updateUnitInfoDisplay();

        // Update game state based on building type
        if (buildingConf.provides?.housingCapacity) { // Check for housing capacity
            gameState.housingCapacity += buildingConf.provides.housingCapacity;
            updateUnitsPanel(); // Update deploy buttons status
        }
        if (buildingConf.provides?.capacityBonus) { updateInventoryCapacity(); }

        updateGrid(); updateBuildingsList();
    }
    function handleUpgradeClick(event) { /* ... (no changes) ... */
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId); if (!selectedUnit || event.target.disabled) return; const upgradeId = event.target.dataset.upgradeType; const upgradeConf = gameConfig.upgrades[upgradeId]; if (!upgradeConf) return; const cost = upgradeConf.cost; const currentLevel = selectedUnit.upgrades?.[upgradeId] || 0; if (currentLevel >= upgradeConf.maxLevel) { showAlert('alertUpgradeMaxLevel', 3000, true, [upgradeConf.nameKey]); return; } if (selectedUnit.exp >= cost) { selectedUnit.exp -= cost; if (!selectedUnit.upgrades) selectedUnit.upgrades = {}; if (upgradeConf.effect.moveBonus) { selectedUnit.upgrades[upgradeId] = (selectedUnit.upgrades[upgradeId] || 0) + 1; } else if (upgradeConf.effect.autoGather) { selectedUnit.upgrades[upgradeId] = true; } showAlert('alertUpgradeSuccess', 2500, true, [upgradeConf.nameKey, selectedUnit.id]); logEvent('alertUpgradeSuccess', [upgradeConf.nameKey, selectedUnit.id]); updateUnitInfoDisplay(); updateGrid(); } else { showAlert('alertNotEnoughExp', 3000, true, [upgradeConf.nameKey]); }
     }
    // --- Removed Unit Choice Functions ---

    // --- Save/Load Functions ---
     function gatherSaveData() { /* ... (updated version, removed maxWorkers, added housingCapacity) ... */
         const saveData = { version: "1.3", // Increment version
             gameState: { units: gameState.units, nextUnitId: gameState.nextUnitId, selectedUnitId: gameState.selectedUnitId, inventory: gameState.inventory, researchPoints: gameState.researchPoints, activeResearch: gameState.activeResearch, completedTech: Array.from(gameState.completedTech), housingCapacity: gameState.housingCapacity, // Added
                 productionProgress: gameState.productionProgress, colonyName: gameState.colonyName, currentLanguage: gameState.currentLanguage, eventLogs: gameState.eventLogs.map(log => ({ time: log.time, messageKey: log.messageKey, args: log.args || [] })), viewOffsetX: gameState.viewOffsetX, viewOffsetY: gameState.viewOffsetY, worldData: gameState.worldData, revealedTiles: Array.from(gameState.revealedTiles) } }; return saveData;
      }
    function saveGame() { /* ... (updated filename version) ... */
        try { const saveData = gatherSaveData(); const saveDataJson = JSON.stringify(saveData); const blob = new Blob([saveDataJson], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const safeColonyName = gameState.colonyName.replace(/[^a-z0-9]/gi, '_').toLowerCase(); link.download = `tinyciv_${safeColonyName}_save_v${saveData.version}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showAlert('alertGameSaved', 2000); logEvent('logGameSaved'); } catch (error) { console.error("Error saving game:", error); showAlert('alertSaveError', 4000); }
     }
    function applyLoadedData(data) { /* ... (updated version check, removed maxWorkers, added housingCapacity) ... */
         const requiredVersion = "1.3"; if (!data || !data.gameState || data.version !== requiredVersion) { showAlert('alertLoadInvalidFormat', 5000, true); if (data?.version && data.version !== requiredVersion) { showAlert('alertSaveVersionMismatch', 6000, true, [requiredVersion, data.version]); } return false; } const loadedState = data.gameState; gameState.units = loadedState.units || []; gameState.nextUnitId = loadedState.nextUnitId || 0; gameState.selectedUnitId = loadedState.selectedUnitId !== undefined ? loadedState.selectedUnitId : (gameState.units.length > 0 ? gameState.units[0].id : null); gameState.inventory = loadedState.inventory || {}; gameState.researchPoints = loadedState.researchPoints || 0; gameState.activeResearch = loadedState.activeResearch || null; gameState.completedTech = new Set(loadedState.completedTech || []); gameState.housingCapacity = loadedState.housingCapacity || 0; // Load housing capacity
         gameState.productionProgress = loadedState.productionProgress || { wheat: 0, coal: 0, quarry: 0 }; gameState.colonyName = loadedState.colonyName || "Loaded Colony"; gameState.currentLanguage = loadedState.currentLanguage || 'en'; gameState.viewOffsetX = loadedState.viewOffsetX || 0; gameState.viewOffsetY = loadedState.viewOffsetY || 0; gameState.worldData = loadedState.worldData || {}; gameState.revealedTiles = new Set(loadedState.revealedTiles || []); gameState.eventLogs = (loadedState.eventLogs || []).map(logData => ({ time: logData.time, messageKey: logData.messageKey, args: logData.args || [], rendered: getLangMsg(logData.messageKey, logData.args || []) })); gameState.units.forEach(unit => { if (unit.exp === undefined) unit.exp = 0; if (unit.upgrades === undefined) unit.upgrades = {}; }); gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateInventoryCapacity(); updateLanguageUI(); hideAllPanels(); updateInventoryDisplay(); updateResearchPointsDisplay(); updateUnitDisplayBar(); updateGrid(); updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); if (gameState.selectedUnitId) { focusOnUnit(gameState.selectedUnitId); } showAlert('alertLoadSuccess', 3000, false, [gameState.colonyName]); return true;
      }
    function loadGame(event) { /* ... (no changes) ... */
        const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const loadedData = JSON.parse(e.target.result); applyLoadedData(loadedData); } catch (error) { console.error("Error loading game:", error); showAlert('alertLoadError', 5000, true, [error.message]); } finally { DOMElements.loadFileInput.value = null; } }; reader.onerror = function() { showAlert('alertReadFileError', 3000); DOMElements.loadFileInput.value = null; }; reader.readAsText(file);
     }

    // --- UI Language Update Function ---
     function updateLanguageUI() { /* ... (updated tutorial steps text) ... */
         const lang = getLang(); document.title = lang.gameTitle; document.querySelector('h1').textContent = lang.gameTitle; DOMElements.languageSwitchButton.textContent = (gameState.currentLanguage === 'en') ? lang.switchToFrench : lang.switchToEnglish; DOMElements.languageSwitchButton.title = lang.switchLanguageTooltip; DOMElements.colonyNameDisplay.textContent = `${lang.colonyLabel} ${gameState.colonyName}`; DOMElements.inventoryDisplay.querySelector('h2').textContent = lang.inventoryTitle; DOMElements.actionButton.textContent = lang.gatherButton; document.getElementById('tutorial-button').textContent = lang.tutorialButton; document.getElementById('research-button').textContent = lang.researchButton; document.getElementById('buildings-button').textContent = lang.buildingsButton; document.getElementById('units-button').textContent = lang.unitsButton; document.getElementById('upgrade-button').textContent = lang.upgradeButton; document.getElementById('logs-button').textContent = lang.logsButton; DOMElements.saveButton.textContent = lang.saveButton; DOMElements.loadButton.textContent = lang.loadButton; DOMElements.logsPanel.querySelector('h2').textContent = lang.logsPanelTitle; DOMElements.logSearchInput.placeholder = lang.logSearchPlaceholder; const filterLabel = DOMElements.logFilterCheckbox.parentElement; if (filterLabel) filterLabel.childNodes[1].nodeValue = ` ${lang.logFilterLabel}`; DOMElements.researchPointsDisplayContainer.childNodes[0].nodeValue = `${lang.researchPointsLabel} `; DOMElements.unitExpDisplayContainer.childNodes[0].nodeValue = `${lang.unitExpLabel} `; const techTitle = DOMElements.techTree.querySelector('h2'); if (techTitle) techTitle.textContent = lang.researchPanelTitle; const buildTitle = DOMElements.buildingsList.querySelector('h2'); if (buildTitle) buildTitle.textContent = lang.buildingsPanelTitle; const unitsTitle = DOMElements.unitsPanel.querySelector('h2'); if (unitsTitle) unitsTitle.textContent = lang.unitsPanelTitle; const upgradeTitleH4 = DOMElements.upgradeInfoDisplay.querySelector('h4'); if (upgradeTitleH4) upgradeTitleH4.textContent = lang.upgradeSectionTitle; DOMElements.tutorialTitle.textContent = lang.tutorialTitle; DOMElements.tutorialStepsList.innerHTML = ` <li>${lang.tutorialStep1}</li><li>${lang.tutorialStep2}</li> <li>${lang.tutorialStep3}</li><li>${lang.tutorialStep4}</li> <li>${lang.tutorialStep5}</li><li>${lang.tutorialStep6}</li> <li>${lang.tutorialStep7}</li><li>${lang.tutorialStep8}</li> <li>${lang.tutorialStep9}</li><li>${lang.tutorialStep10}</li> <li>${lang.tutorialStep11}</li><li>${lang.tutorialStep12}</li> <li>${lang.tutorialStep13}</li><li>${lang.tutorialStep14}</li> <li>${lang.tutorialStep15}</li><li>${lang.tutorialStep16}</li>`; DOMElements.closeTutorialButton.textContent = lang.closeButton; updateInventoryDisplay(); updateGrid(); updateUnitDisplayBar(); updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); updateLogsDisplay(); checkResource();
      }

    // --- Language Switching ---
     function switchLanguage() { /* ... (no changes) ... */
         gameState.currentLanguage = (gameState.currentLanguage === 'en') ? 'fr' : 'en'; gameState.eventLogs.forEach(log => { log.rendered = getLangMsg(log.messageKey, log.args); }); updateLanguageUI();
      }

    // --- Game Start ---
    function initializeGame() { /* ... (init housingCapacity) ... */
        if (gameState.gameInitialized) return; noise.biome = SimplexNoise.create(Math.random()); noise.feature = SimplexNoise.create(Math.random() + 1); noise.water = SimplexNoise.create(Math.random() + 2); gameState.units = []; gameState.nextUnitId = 0; gameState.selectedUnitId = null; gameState.inventory = {}; gameState.inventoryCapacity = {}; gameState.researchPoints = 0; gameState.activeResearch = null; gameState.completedTech = new Set(); gameState.housingCapacity = 0; // Initialize housing capacity
         gameState.selectedBuilding = null; gameState.productionProgress = { wheat: 0, coal: 0, quarry: 0 }; gameState.eventLogs = []; gameState.worldData = {}; gameState.revealedTiles = new Set(); gameState.highlightEnabled = false; clearTimeout(gameState.alertTimeout); gameConfig.resources.forEach(res => { gameState.inventory[res.id] = 0; }); gameState.currentLanguage = 'en'; const lang = getLang(); gameState.colonyName = prompt(lang.promptColonyName, lang.defaultColonyName) || lang.defaultColonyName; logEvent('logNewGame', [gameState.colonyName]); const startWorldX = 5, startWorldY = 5; let startValid = false, attemptCount = 0; do { attemptCount++; if (attemptCount > 1) { logEvent('logInvalidStartRegen'); noise.biome = SimplexNoise.create(Math.random()); noise.feature = SimplexNoise.create(Math.random() + 1); noise.water = SimplexNoise.create(Math.random() + 2); gameState.worldData = {}; gameState.revealedTiles = new Set(); } revealArea(startWorldX, startWorldY, 1); const startData = getTileData(startWorldX, startWorldY); if (startData && startData.type !== 'water') { let hasAdjLand = false; for (let dy=-1; dy<=1; dy++) { for (let dx=-1; dx<=1; dx++) { if(dx===0 && dy===0) continue; const adj = getTileData(startWorldX+dx,startWorldY+dy) || generateTileContent(startWorldX+dx,startWorldY+dy); if(adj && adj.type !== 'water') { hasAdjLand=true; break; } } if(hasAdjLand) break; } if(hasAdjLand) startValid=true; } if (!startValid && attemptCount >= gameConfig.maxStartRegenAttempts) { logEvent('logInvalidStartGiveUp', [attemptCount]); startValid=true; } } while (!startValid); gameState.units.push({ id: `unit-${gameState.nextUnitId++}`, type: 'pawn', worldX: startWorldX, worldY: startWorldY, exp: 0, upgrades: {} }); gameState.selectedUnitId = gameState.units[0].id; gameState.viewOffsetX = startWorldX - gameConfig.viewCenterOffset; gameState.viewOffsetY = startWorldY - gameConfig.viewCenterOffset; revealArea(startWorldX, startWorldY, gameConfig.units.pawn.revealRadius); initializeGridDOM(); setupEventListeners(); hideAllPanels(); updateLanguageUI(); updateInventoryCapacity(); updateUnitDisplayBar(); updateResearchPointsDisplay(); updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); DOMElements.researchStatusDisplay.textContent = lang.researchStatusInitial; DOMElements.researchStatusDisplay.style.display = 'block'; showAlert('alertWelcome', 4000, false, [gameState.colonyName]); gameState.gameInitialized = true;
    }

    // --- Start Game ---
    initializeGame();

  </script>
</body>
</html>
