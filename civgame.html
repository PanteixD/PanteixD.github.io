<html>
<head>
<title>Civilization Simulator</title>
<meta charset="UTF-8">
<style>
  /* --- General Styles --- */
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; text-align: center; display: flex; flex-direction: column; align-items: center; background-color: #e8eff5; margin: 0; padding: 20px; color: #333; }
  h1 { color: #2c3e50; margin-bottom: 10px; }

  /* Language Switcher */
  #language-switcher { position: absolute; top: 15px; left: 15px; z-index: 10; }
  #language-switch-button { padding: 8px 12px; font-size: 14px; background-color: #5dade2; color: white; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: background-color 0.2s ease; }
  #language-switch-button:hover { background-color: #3498db; }


  /* --- Unit Display Bar --- */
  #unit-display-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 10px; margin-bottom: 15px; min-height: 40px; background-color: #dde8f0; border-radius: 8px; border: 1px solid #c8d6e1; flex-wrap: wrap; }
  .unit-icon { width: 35px; height: 35px; border: 2px solid #adb5bd; background-color: #ced4da; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; cursor: pointer; transition: all 0.2s ease; position: relative; }
  .unit-icon:hover { border-color: #495057; background-color: #e9ecef; transform: scale(1.05); }
  .unit-icon.selected { border-color: #007bff; box-shadow: 0 0 8px rgba(0, 123, 255, 0.5); transform: scale(1.1); }
  .unit-icon[data-unit-type="pawn"] { background-color: #3498db; color: white; }
  .unit-icon[data-unit-type="worker"] { background-color: #e67e22; color: white; }
  .unit-icon[data-unit-type="scout"] { background-color: #1abc9c; color: white; }

  /* --- Alert Message --- */
  #alert-message { padding: 10px 20px; margin-top: 10px; border-radius: 8px; background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; font-weight: bold; text-align: center; opacity: 0; transition: opacity 0.5s ease-in-out; max-width: 550px; width: 90%; box-sizing: border-box; position: relative; left: 50%; transform: translateX(-50%); display: none; z-index: 20; }
  #alert-message.show { display: block; opacity: 1; }

  /* --- Game Layout --- */
  #game-container { display: flex; justify-content: center; align-items: flex-start; margin-top: 20px; flex-wrap: wrap; gap: 20px; background-color: #ffffff; padding: 30px; border-radius: 16px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); max-width: 1400px; width: 100%; position: relative; }
  #left-container, #right-panel { display: flex; flex-direction: column; align-items: stretch; gap: 15px; flex: 1; min-width: 250px; }
  #middle-controls { display: flex; flex-direction: column; align-items: stretch; gap: 10px; flex: 0 0 auto; width: 150px; }
  #middle-controls button { margin-top: 0; }
  #grid-area { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; min-width: 585px; }
  #grid { display: grid; grid-template-columns: repeat(10, 55px); grid-template-rows: repeat(10, 55px); gap: 5px; padding: 15px; background-color: #b0bec5; border-radius: 12px; border: 1px solid #90a4ae; margin-bottom: 10px; position: relative; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

  /* --- Tiles --- */
  .tile { width: 55px; height: 55px; border: 1px solid #cfd8dc; display: flex; align-items: center; justify-content: center; font-size: 28px; font-weight: normal; cursor: pointer; overflow: hidden; border-radius: 8px; transition: background-color 0.2s ease-in-out, border-color 0.2s ease, box-shadow 0.2s ease; background-color: #eceff1; color: #555; position: relative; line-height: 1; }
  .tile:not(.unknown):hover { transform: scale(1.05); box-shadow: 0 0 8px rgba(0, 0, 0, 0.1); z-index: 1; }
  .tile.unknown { /* Darker Unknown Tile */
    background-color: #78909c; /* Darker shade */
    cursor: default;
    border-color: #546e7a; /* Darker border */
    color: #cfd8dc; /* Lighter text for contrast */
    opacity: 0.85;
  }
  .tile.unknown:hover { /* Prevent hover effects on unknown */
    transform: none;
    box-shadow: none;
    z-index: 0;
  }
  .unit-marker { border-radius: 50%; width: 70%; height: 70%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: white; position: absolute; z-index: 2; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); pointer-events: none; }
  .unit-marker.pawn { background-color: #3498db; } .unit-marker.worker { background-color: #e67e22; } .unit-marker.scout { background-color: #1abc9c; }
  .unit-marker.selected { outline: 3px solid #007bff; outline-offset: 2px; }

  /* Resource & Building Styles */
  .tile.grass { background-color: #aed581; color: #38761d; border-color: #9ccc65; }
  .tile.tree { background-color: #c8e6c9; color: #2e7d32; border-color: #a5d6a7; font-size: 32px; }
  .tile.stone { background-color: #95a5a6; color: #fff; } /* Pebbles */
  .tile.flint { background-color: #7f8c8d; color: #fff; } /* Flint */
  .tile.water { background-color: #5dade2; cursor: not-allowed; border-color: #3498db; }
  .tile.sand { background-color: #f7dc6f; color: #9a7d0a; border-color: #f1c40f; }
  .tile.house, .tile.farm, .tile.mine, .tile.quarry, .tile.warehouse { text-align: center; line-height: 55px; font-weight: bold; font-size: 10px; }
  .tile.farm { background-color: #f1c40f; color: #333; }
  .tile.mine { background-color: #607d8b; color: white; }
  .tile.house { background-color: #8e44ad; color: white; }
  .tile.quarry { background-color: #a1887f; color: white; border-color: #795548;}
  .tile.warehouse { background-color: #7f8c8d; color: white; border-color: #62757f; }

  /* Highlight Styles */
  .highlight { background-color: rgba(52, 152, 219, 0.2) !important; border: 1px solid #3498db !important; }
  .tile.highlight-house-target { /* Style for target house selection */
       background-color: rgba(46, 204, 113, 0.3) !important; /* Light green highlight */
       border: 2px solid #2ecc71 !important; /* Green border */
       box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
       cursor: crosshair; /* Indicate target selection */
   }

  /* --- Buttons --- */
  button { padding: 12px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 8px; background-color: #3498db; color: white; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); font-weight: 600; }
  button:hover:not(:disabled) { background-color: #2980b9; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); transform: translateY(-1px); }
  button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  button:disabled { background-color: #bdc3c7; cursor: default; opacity: 0.7; }
  #action-button { background-color: #e67e22; margin-top: 5px; }
  #action-button:hover:not(:disabled) { background-color: #d35400; }
  /* Panel toggle buttons */
  #middle-controls button { background-color: #9b59b6; } #middle-controls button:hover:not(:disabled) { background-color: #8e44ad; }
  #middle-controls #tutorial-button { background-color: #f39c12; } #middle-controls #tutorial-button:hover:not(:disabled) { background-color: #e67e22; }
  #middle-controls #research-button { background-color: #2980b9; } #middle-controls #research-button:hover:not(:disabled) { background-color: #1f618d; }
  #middle-controls #buildings-button { background-color: #16a085; } #middle-controls #buildings-button:hover:not(:disabled) { background-color: #117a65; }
  #middle-controls #units-button { background-color: #27ae60; } /* Green */ #middle-controls #units-button:hover:not(:disabled) { background-color: #229954; }
  #middle-controls #upgrade-button { background-color: #c0392b; } /* Red */ #middle-controls #upgrade-button:hover:not(:disabled) { background-color: #a93226; }
  #middle-controls #logs-button { background-color: #34495e; } #middle-controls #logs-button:hover:not(:disabled) { background-color: #2c3e50; }
  #middle-controls #save-button { background-color: #2ecc71; } #middle-controls #save-button:hover:not(:disabled) { background-color: #27ae60; }
  #middle-controls #load-button { background-color: #f1c40f; } #middle-controls #load-button:hover:not(:disabled) { background-color: #d4ac0d; }
  #middle-controls #cheat-reveal-button { background-color: #e74c3c; margin-top: 10px; } /* Cheat button style */
  #middle-controls #cheat-reveal-button:hover:not(:disabled) { background-color: #c0392b; }
  /* Buttons within panels */
  .panel-content li button { background-color: #f1c40f; color: #333; padding: 8px 15px; font-size: 14px; width: auto; display: inline-block; margin-right: 5px; }
  .panel-content li button:hover:not(:disabled) { background-color: #f39c12; }

  #units-list li button { background-color: #27ae60; color: white; padding: 8px 15px; font-size: 14px; width: auto; display: inline-block; margin-right: 5px; } /* Style for unit deploy buttons */
  #units-list li button:hover:not(:disabled) { background-color: #229954; } /* Darker green on hover */
  #upgrade-info button { background-color: #c0392b; color: white; padding: 6px 10px; font-size: 13px; width: 100%; box-sizing: border-box; margin-top: 5px; border-radius: 5px; display: block; }
  #upgrade-info button:hover:not(:disabled) { background-color: #a93226; }

  /* --- Panels --- */
  .panel { text-align: left; background-color: #fdfefe; padding: 20px; border-radius: 12px; border: 1px solid #e4e9ed; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); max-height: 350px; overflow-y: auto; display: none; /* Hidden by default */ }
  #inventory { display: block; max-height: none; overflow-y: visible; }
  #logs-panel { max-height: 250px; }
  .panel h2 { font-size: 20px; color: #2c3e50; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
  .panel ul { list-style-type: none; padding: 0; margin: 0; }
  .panel li { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
  .panel li:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
  .panel p.description { font-size: 13px; color: #777; margin-top: 0; margin-bottom: 0; }

  /* Specific Panel Styles */
  #inventory p { font-size: 16px; color: #555; margin-bottom: 8px; line-height: 1.4; } #inventory span { font-weight: bold; color: #333; }
   .panel-content .building-cost { font-size: 13px; font-weight: bold; color: #777; margin-top: 4px; margin-bottom: 2px; }
   .panel-content #buildings-list .description { margin-top: 2px; }

  #logs-list { list-style-type: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.5; color: #555; margin-top: 10px; }
  #logs-list li { padding: 4px 0; border-bottom: 1px dashed #eee; white-space: pre-wrap; } #logs-list li:last-child { border-bottom: none; }
  #logs-list .log-time { display: inline-block; width: 50px; color: #888; margin-right: 5px; }
  #log-search-input { width: 100%; padding: 8px 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 14px; }
  #log-filter-container { display: block; margin-bottom: 10px; font-size: 14px; color: #555; }
  #log-filter-checkbox { margin-right: 5px; vertical-align: middle; }

  /* --- Other UI --- */
  #colony-name-display { font-size: 22px; color: #2c3e50; font-weight: bold; margin-bottom: 0; text-align: left; padding: 10px; background-color: #ecf0f1; border-radius: 8px; }
  #resource-name { margin-top: 15px; font-size: 16px; font-weight: bold; color: #7f8c8d; min-height: 20px; text-align: left; }
  #unit-biome-display-container, #unit-coords-display-container, #unit-exp-display-container, #research-points-display-container { font-size: 16px; font-weight: bold; text-align: left; padding: 10px; border-radius: 8px; margin-bottom: 10px; }
  #unit-biome-display-container { color: #16a085; background-color: #e8f8f5; } #unit-biome-display-container span { font-weight: normal; color: #117a65; text-transform: capitalize; }
  #unit-coords-display-container { color: #34495e; background-color: #ecf0f1; } #unit-coords-display-container span { font-weight: normal; color: #2c3e50; }
  #unit-exp-display-container { color: #e67e22; background-color: #fef5e7; } #unit-exp-display-container span { font-weight: normal; color: #d35400; }
  #research-points-display-container { color: #8e44ad; background-color: #f3eaf7; margin-bottom: 0; } /* Removed margin-bottom */
  #upgrade-info { margin-top: 10px; text-align: left; background-color: #f9ebea; padding: 15px; border-radius: 8px; border: 1px solid #f5b7b1; min-height: 50px; }
  #upgrade-info h4 { font-size: 15px; margin-top: 0; margin-bottom: 10px; color: #a93226; border-bottom: 1px solid #e6b0aa; padding-bottom: 5px;}
  #upgrade-info p { font-size: 13px; color: #555; margin-top: 5px; }
  #research-status-display { font-size: 14px; font-weight: bold; color: #27ae60; margin-top: 10px; min-height: 18px; text-align: left; padding: 5px 10px; background-color: #e8f8f5; border-radius: 6px; border: 1px solid #a3e4d7; display: none; /* Initially hidden */}

  /* --- Tutorial Modal Styles --- */
  #tutorial-modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
  #tutorial-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 650px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); text-align: left; }
  #tutorial-content h2 { text-align: center; color: #2c3e50; margin-top: 0; padding-bottom: 15px; border-bottom: 1px solid #eee; }
  #tutorial-steps { list-style-type: decimal; margin-left: 20px; padding-left: 15px; font-size: 15px; line-height: 1.6; color: #333; }
  #tutorial-steps li { margin-bottom: 12px; }
  #tutorial-steps code { background-color: #ecf0f1; padding: 2px 5px; border-radius: 4px; font-family: Consolas, monospace; color: #e67e22; font-weight: bold; }
  #close-tutorial-button { display: block; margin: 20px auto 0 auto; background-color: #e74c3c; padding: 10px 25px; }
  #close-tutorial-button:hover { background-color: #c0392b; }

  /* --- Tech Tree Modal Styles --- */
    #tech-tree-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 100; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
      padding-top: 30px; /* Location of the box */
      padding-bottom: 30px;
    }

    #tech-tree-modal-content {
      background-color: #2b3e50; /* Dark background like Civ V */
      color: #ecf0f1; /* Light text */
      margin: 2% auto; /* Centered */
      padding: 25px;
      border: 1px solid #34495e;
      width: 90%; /* Wider */
      max-width: 1200px; /* Wider Max width */
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      text-align: left;
      position: relative; /* For absolute positioning inside */
    }

    #tech-tree-modal-content h2 {
      text-align: center;
      color: #e4f1fe; /* Lighter title */
      margin-top: 0;
      padding-bottom: 15px;
      border-bottom: 1px solid #4e5d6c;
    }

    #tech-tree-display-area {
      position: relative; /* Crucial for positioning nodes */
      height: 650px; /* Increased height for more techs */
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.1); /* Slightly darker area for techs */
      border-radius: 8px;
      overflow-x: auto; /* Allow horizontal scrolling if needed */
      margin-bottom: 20px;
    }

    #close-tech-tree-button {
      display: block;
      margin: 20px auto 0 auto;
      background-color: #e74c3c;
      padding: 10px 25px;
    }
    #close-tech-tree-button:hover {
      background-color: #c0392b;
    }

    /* --- Tech Node Styling --- */
    .tech-node {
      position: absolute; /* Position nodes precisely */
      width: 160px; /* Fixed width */
      min-height: 90px; /* Increased min height */
      border: 2px solid #7f8c8d; /* Default border */
      border-radius: 6px;
      background-color: #34495e; /* Darker node background */
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      justify-content: space-between; /* Help push progress bar down */
    }

    .tech-node.researched {
      border-color: #f1c40f; /* Gold border for researched */
      background-color: #524e44; /* Slightly different bg */
      opacity: 0.8;
    }

    .tech-node.available {
      border-color: #2ecc71; /* Green border for available */
      cursor: pointer;
    }
    .tech-node.available:hover {
      transform: scale(1.03);
      box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
    }

    .tech-node.researching {
        border-color: #3498db; /* Blue border for researching */
        box-shadow: 0 0 12px rgba(52, 152, 219, 0.7);
        animation: pulse-border 1.5s infinite;
    }

    @keyframes pulse-border {
      0% { box-shadow: 0 0 12px rgba(52, 152, 219, 0.7); }
      50% { box-shadow: 0 0 18px rgba(52, 152, 219, 1); }
      100% { box-shadow: 0 0 12px rgba(52, 152, 219, 0.7); }
    }


    .tech-node .tech-name {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
      color: #ecf0f1;
      width: 100%; /* Ensure it takes full width for centering */
      line-height: 1.2;
    }

    .tech-node .tech-cost {
      font-size: 11px;
      color: #bdc3c7;
      margin-bottom: 4px;
    }

    .tech-node .tech-unlocks { /* NEW STYLE */
        font-size: 10px;
        color: #aed581; /* Greenish color for unlocks */
        margin-top: 4px; /* Space above */
        margin-bottom: 4px; /* Space below */
        width: 100%; /* Ensure it takes full width */
        line-height: 1.1;
        font-style: italic;
        text-align: center; /* Center unlocks text */
    }
    .tech-node .tech-unlocks span { /* Style for the "Unlocks:" label */
        font-weight: bold;
        color: #bdc3c7; /* Slightly lighter grey */
    }

    /* Progress Bar inside Node */
    .tech-node .research-progress-container {
        width: 90%; /* Relative to node */
        height: 6px; /* Smaller bar */
        border: 1px solid #566573;
        margin-top: auto; /* Push to bottom */
        margin-bottom: 2px;
        border-radius: 3px;
        background-color: #2c3e50;
        overflow: hidden;
        display: none; /* Hidden by default, shown when researching */
        align-items: center;
    }
    .tech-node .research-progress-bar {
        width: 0%;
        height: 100%;
        border-radius: 2px 0 0 2px;
        transition: width 0.3s ease-in-out;
        background-color: #3498db; /* Default progress color */
    }

    /* Era Title Styling */
    .era-title {
        position: absolute;
        /* top value will be set by JS */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%);
        color: #bdc3c7;
        font-size: 16px;
        font-weight: bold;
        background-color: rgba(43, 62, 80, 0.8);
        padding: 3px 10px;
        border-radius: 4px;
        z-index: 5; /* Above nodes but potentially below modal controls */
    }

    /* Simple Connecting Lines (Horizontal Example) */
    .tech-node::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 100%; /* Start at the right edge of the node */
        /* Adjust width based on typical node spacing */
        width: calc(200px - 160px - 10px); /* (Approx Next Node posX diff) - (This Node width) - buffer */
        height: 2px; /* Thickness */
        background-color: #7f8c8d; /* Line color */
        transform: translateY(-50%);
        z-index: -1; /* Behind nodes */
        display: none; /* Hide by default, show via JS if needed */
    }
     /* Style for nodes that should have a horizontal line */
    .tech-node.has-horizontal-connector::after { /* Renamed class */
        display: block;
    }
    /* NOTE: Drawing vertical/angled lines accurately requires SVG/Canvas */


    /* --- Legend Styling --- */
    #tech-tree-legend {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #4e5d6c;
        text-align: center;
        font-size: 12px;
        color: #bdc3c7;
    }
    #tech-tree-legend span {
        margin-right: 15px;
        vertical-align: middle;
    }
     #tech-tree-legend span:last-child {
        margin-right: 0;
    }
    .legend-item {
        display: inline-block;
        width: 12px;
        height: 12px;
        border: 2px solid #7f8c8d;
        border-radius: 3px;
        margin-right: 5px;
        vertical-align: middle;
    }
    .legend-item.researched { border-color: #f1c40f; background-color: #524e44; }
    .legend-item.available { border-color: #2ecc71; background-color: #34495e; }
    .legend-item.researching { border-color: #3498db; background-color: #34495e; }
    .legend-item.unavailable { border-color: #7f8c8d; background-color: #34495e; opacity: 0.7; }


  /* Tooltip Base Style */
  [data-tooltip] { position: relative; cursor: help; }
  [data-tooltip]::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px); background-color: rgba(50, 50, 50, 0.9); color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; pointer-events: none; }
  [data-tooltip]:hover::after { opacity: 1; visibility: visible; }

</style>
</head>
<body>
  <!-- Language Switch Button -->
  <div id="language-switcher">
      <button id="language-switch-button" title="Switch Language / Changer de langue"></button>
  </div>

  <h1>Civilization Simulator</h1>
  <div id="unit-display-bar"></div>

  <div id="game-container">
    <!-- === LEFT CONTAINER === -->
    <div id="left-container">
      <div id="colony-name-display">Colony Name</div>
      <div id="inventory">
        <h2>Inventory</h2>
        <!-- Inventory items will be generated by JS -->
      </div>
      <button id="action-button" style="display: none;">Gather Resource</button>
      <div id="resource-name"></div>
    </div>

    <!-- === MIDDLE CONTROLS === -->
    <div id="middle-controls">
         <button id="tutorial-button" data-panel-target="tutorial-modal">Tutorial</button>
         <button id="research-button" data-panel-target="tech-tree-modal">Research</button>
         <button id="buildings-button" data-panel-target="buildings-list">Buildings</button>
         <button id="units-button" data-panel-target="units-panel">Units</button>
         <button id="upgrade-button" data-panel-target="upgrade-info">Upgrades</button>
         <button id="logs-button" data-panel-target="logs-panel">Logs</button>
         <button id="save-button">Save Game</button>
         <button id="load-button">Load Game</button>
         <input type="file" id="load-file-input" accept=".json" style="display: none;">
         <button id="cheat-reveal-button">Reveal Map</button> <!-- CHEAT BUTTON -->
    </div>

    <!-- === GRID AREA === -->
    <div id="grid-area">
        <div id="grid" class="grid"></div>
        <div id="alert-message"></div>
    </div>

    <!-- === RIGHT CONTAINER === -->
    <div id="right-panel">
       <div id="unit-biome-display-container">Biome: <span id="unit-biome">Unknown</span></div>
       <div id="unit-coords-display-container">Coords: <span id="unit-coords">(-, -)</span></div>
       <div id="unit-exp-display-container">Exp: <span id="unit-exp">0</span></div>
       <!-- Research Points moved here -->
       <div id="research-points-display-container">Research Points: <span id="research-points">0</span></div>

       <!-- Logs Panel -->
       <div id="logs-panel" class="panel">
           <h2>Event Logs</h2>
           <input type="text" id="log-search-input" placeholder="Search logs...">
           <div id="log-filter-container">
               <label><input type="checkbox" id="log-filter-checkbox"> Hide gather/cost messages</label>
           </div>
           <ul id="logs-list"></ul>
       </div>

       <!-- Other Toggleable Panels -->
       <div id="upgrade-info" class="panel">
           <h4>Unit Upgrades</h4>
           <div class="panel-content">
               <p>Select a unit to see upgrades.</p>
           </div>
       </div>
       <!-- Tech Tree Panel REMOVED -->
       <div id="buildings-list" class="panel">
           <h2>Buildings</h2>
           <div class="panel-content">
               <ul></ul> <!-- Populated by JS -->
           </div>
       </div>
       <div id="units-panel" class="panel">
           <h2>Deploy Units</h2> <!-- Changed Title -->
           <div class="panel-content">
               <ul id="units-list"> <!-- Populated by JS to deploy units via houses -->
                   <li>Build houses and research units first!</li>
               </ul>
           </div>
       </div>
       <!-- Static displays -->
       <!-- Research Points was moved up -->
       <div id="research-status-display"></div> <!-- Separate status display -->
    </div>
  </div> <!-- End of game-container -->

  <!-- === TUTORIAL MODAL === -->
  <div id="tutorial-modal" style="display: none;">
      <div id="tutorial-content">
          <h2 id="tutorial-title">How to Play (Basics)</h2>
          <ol id="tutorial-steps">
              <!-- Steps will be populated by JS -->
          </ol>
          <button id="close-tutorial-button">Close</button>
      </div>
  </div>

   <!-- === TECH TREE MODAL === -->
   <div id="tech-tree-modal" style="display: none;">
       <div id="tech-tree-modal-content">
           <h2 id="tech-tree-title">Technology Tree</h2>
           <div id="tech-tree-display-area">
               <!-- Tech nodes and eras will be populated by JS -->
           </div>
           <button id="close-tech-tree-button">Close</button>
           <!-- Optional Legend -->
           <div id="tech-tree-legend">
              <span class="legend-item researched"></span> <span data-lang-key="legendResearched">Researched</span>
              <span class="legend-item available"></span> <span data-lang-key="legendAvailable">Available</span>
              <span class="legend-item researching"></span> <span data-lang-key="legendResearching">Researching</span>
              <span class="legend-item unavailable"></span> <span data-lang-key="legendUnavailable">Unavailable</span>
           </div>
       </div>
   </div>


  <script>
    // --- Simplex Noise Library (Minimized) ---
    var SimplexNoise=(function(){var F2=0.5*(Math.sqrt(3.0)-1.0);var G2=(3.0-Math.sqrt(3.0))/6.0;var F3=1.0/3.0;var G3=1.0/6.0;var F4=(Math.sqrt(5.0)-1.0)/4.0;var G4=(5.0-Math.sqrt(5.0))/20.0;function Alea(){var s0=0;var s1=0;var s2=0;var c=1;var mash=Mash();s0=mash(' ');s1=mash(' ');s2=mash(' ');for(var i=0;i<arguments.length;i++){s0-=mash(arguments[i]);if(s0<0){s0+=1;} s1-=mash(arguments[i]);if(s1<0){s1+=1;} s2-=mash(arguments[i]);if(s2<0){s2+=1;}} mash=null;var random=function(){var t=2091639*s0+c*2.3283064365386963e-10;s0=s1;s1=s2;return s2=t-(c=t|0);};random.uint32=function(){return random()*0x100000000;};random.fract53=function(){return random()+(random()*0x200000|0)*1.1102230246251565e-16;};random.version='Alea 0.9';random.args=arguments;return random;} function Mash(){var n=0xefc8249d;var mash=function(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;} return(n>>>0)*2.3283064365386963e-10;};mash.version='Mash 0.9';return mash;} function SimplexNoise(random){if(!random)random=Math.random;this.p=new Uint8Array(256);this.perm=new Uint8Array(512);this.permMod12=new Uint8Array(512);for(var i=0;i<256;i++){this.p[i]=i;} for(i=0;i<255;i++){var r=i+~~(random()*(256-i));var aux=this.p[i];this.p[i]=this.p[r];this.p[r]=aux;} for(i=0;i<512;i++){this.perm[i]=this.p[i&255];this.permMod12[i]=this.perm[i]%12;}} SimplexNoise.prototype={grad3:new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),noise2D:function(xin,yin){var permMod12=this.permMod12;var perm=this.perm;var grad3=this.grad3;var n0=0;var n1=0;var n2=0;var s=(xin+yin)*F2;var i=Math.floor(xin+s);var j=Math.floor(yin+s);var t=(i+j)*G2;var X0=i-t;var Y0=j-t;var x0=xin-X0;var y0=yin-Y0;var i1,j1;if(x0>y0){i1=1;j1=0;}else{i1=0;j1=1;} var x1=x0-i1+G2;var y1=y0-j1+G2;var x2=x0-1.0+2.0*G2;var y2=y0-1.0+2.0*G2;var ii=i&255;var jj=j&255;var t0=0.5-x0*x0-y0*y0;if(t0>=0){var gi0=permMod12[ii+perm[jj]]*3;t0*=t0;n0=t0*t0*(grad3[gi0]*x0+grad3[gi0+1]*y0);} var t1=0.5-x1*x1-y1*y1;if(t1>=0){var gi1=permMod12[ii+i1+perm[jj+j1]]*3;t1*=t1;n1=t1*t1*(grad3[gi1]*x1+grad3[gi1+1]*y1);} var t2=0.5-x2*x2-y2*y2;if(t2>=0){var gi2=permMod12[ii+1+perm[jj+1]]*3;t2*=t2;n2=t2*t2*(grad3[gi2]*x2+grad3[gi2+1]*y2);} return 70.0*(n0+n1+n2);},};SimplexNoise.create=function(seed){if(seed){return new SimplexNoise(new Alea(seed));}else{return new SimplexNoise(Math.random);}};return SimplexNoise;})();
    // --- End Simplex Noise Library ---

    // --- DOM Element References (Cached) ---
    const DOMElements = {
        grid: document.getElementById('grid'), actionButton: document.getElementById('action-button'),
        inventoryDisplay: document.getElementById('inventory'),
        middleControls: document.getElementById('middle-controls'),
        buildingsList: document.getElementById('buildings-list'),
        unitsPanel: document.getElementById('units-panel'), logsPanel: document.getElementById('logs-panel'),
        upgradeInfoDisplay: document.getElementById('upgrade-info'), logsList: document.getElementById('logs-list'),
        logSearchInput: document.getElementById('log-search-input'), logFilterCheckbox: document.getElementById('log-filter-checkbox'),
        resourceNameDisplay: document.getElementById('resource-name'), researchPointsDisplay: document.getElementById('research-points'),
        researchStatusDisplay: document.getElementById('research-status-display'), colonyNameDisplay: document.getElementById('colony-name-display'),
        alertMessageElement: document.getElementById('alert-message'), unitDisplayBar: document.getElementById('unit-display-bar'),
        unitBiomeDisplay: document.getElementById('unit-biome'), unitCoordsDisplay: document.getElementById('unit-coords'),
        unitExpDisplay: document.getElementById('unit-exp'), loadFileInput: document.getElementById('load-file-input'),
        languageSwitchButton: document.getElementById('language-switch-button'),
        tutorialModal: document.getElementById('tutorial-modal'), tutorialTitle: document.getElementById('tutorial-title'),
        tutorialStepsList: document.getElementById('tutorial-steps'), closeTutorialButton: document.getElementById('close-tutorial-button'),
        buildingsListUl: document.querySelector('#buildings-list ul'),
        unitsListUl: document.getElementById('units-list'),
        upgradeInfoContent: document.querySelector('#upgrade-info .panel-content'),
        saveButton: document.getElementById('save-button'), loadButton: document.getElementById('load-button'),
        cheatRevealButton: document.getElementById('cheat-reveal-button'), // Cheat button ref
        techTreeModal: document.getElementById('tech-tree-modal'),
        techTreeModalContent: document.getElementById('tech-tree-modal-content'),
        techTreeDisplayArea: document.getElementById('tech-tree-display-area'),
        techTreeTitle: document.getElementById('tech-tree-title'),
        closeTechTreeButton: document.getElementById('close-tech-tree-button'),
        techTreeLegend: document.getElementById('tech-tree-legend'),
    };

    // --- Game Configuration ---
    const gameConfig = {
        gridSize: 10, viewCenterOffset: 5, revealRadiusBase: 2,
        maxLogEntries: 50, alertDuration: 3000,
        baseInventoryCapacity: { wood: 50, pebble: 50, flint: 30, wheat: 20, coal: 20, iron: 10, copper: 10, nickel: 10, zinc: 10 },
        eventChance: 0.01,
        expPerBuild: 3, expPerResearchComplete: 10, expPerEventDiscovery: 5,
        productionIntervals: { wheat: 5, coal: 7, quarry: 12 },
        noiseScales: { biome: 30.0, feature: 15.0, water: 40.0 },
        noiseThresholds: { biomeDesert: 0.3, lake: -0.3, treeForest: -0.1, flintForest: 0.0, stoneForest: 0.15 },
        desertStoneChance: 0.06,
        maxStartRegenAttempts: 10,
        cheatRevealSize: 50,
        saveVersion: "1.8", // Increment for resource cost changes
        units: {
            pawn: { nameKey: 'unitPawn', icon: 'P', build: ['house'], move: 1, revealRadius: 2, researchBonus: 1, upgrades: ['movement1', 'autoGather'] },
            worker: { nameKey: 'unitWorker', icon: 'W', build: ['farm', 'mine', 'quarry', 'warehouse'], move: 1, revealRadius: 2, researchBonus: 0, upgrades: ['movement1', 'autoGather'], deployableFromPanel: true, requiredTech: 'settlement' },
            scout: { nameKey: 'unitScout', icon: 'S', build: [], move: 3, revealRadius: 3, researchBonus: 0, upgrades: ['movement1', 'autoGather'], deployableFromPanel: true, requiredTech: 'exploration' }
        },
        buildings: {
            house: { nameKey: 'buildingHouse', cost: { wood: 10, pebble: 5, flint: 1 }, provides: { }, unlockedBy: 'settlement' }, // Added flint cost
            farm: { nameKey: 'buildingFarm', cost: { wood: 3 }, produces: { resource: 'wheat', interval: 'wheat' }, requires: 'worker', unlockedBy: 'agriculture' },
            mine: { nameKey: 'buildingMine', cost: { pebble: 5, wood: 2 }, produces: { resource: 'coal', interval: 'coal' }, requires: 'worker', unlockedBy: 'mining' },
            quarry: { nameKey: 'buildingQuarry', cost: { pebble: 15, wood: 5, flint: 3 }, produces: { resource: ['iron', 'copper', 'nickel', 'zinc'], interval: 'quarry' }, requires: 'worker', unlockedBy: 'masonry' }, // Added flint cost
            warehouse: { nameKey: 'buildingWarehouse', cost: { wood: 15, pebble: 10, iron: 2 }, provides: { capacityBonus: 50 }, unlockedBy: 'storage' } // Added iron cost
        },
        tech: {
            // --- Primitive Age (Era 1) ---
            settlement: { nameKey: 'researchSettlement', cost: 15, unlocks: ['house'], requires: [], age: 'primitive', color: '#8e44ad', posX: 20, posY: 150, era: 1 },
            agriculture: { nameKey: 'researchAgriculture', cost: 10, unlocks: ['farm'], requires: [], age: 'primitive', color: '#aed581', posX: 20, posY: 260, era: 1 },
            exploration: { nameKey: 'researchExploration', cost: 15, unlocks: [], requires: ['settlement'], age: 'primitive', color: '#1abc9c', posX: 220, posY: 40, era: 1 },
            mining: { nameKey: 'researchMining', cost: 15, unlocks: ['mine'], requires: ['agriculture'], age: 'primitive', color: '#7f8c8d', posX: 220, posY: 260, era: 1 },
            masonry: { nameKey: 'researchMasonry', cost: 20, unlocks: ['quarry'], requires: ['mining'], age: 'primitive', color: '#bcaaa4', posX: 420, posY: 260, era: 1 },
            storage: { nameKey: 'researchStorage', cost: 25, unlocks: ['warehouse'], requires: ['masonry'], age: 'primitive', color: '#7f8c8d', posX: 620, posY: 260, era: 1 },
            toolMaking: { nameKey: 'researchToolMaking', cost: { wood: 5, flint: 5, research: 20 }, unlocks: [], requires: ['mining'], age: 'primitive', color: '#5D6D7E', posX: 420, posY: 150, era: 1 }, // Added flint cost, specified RP cost
            animalHusbandry: { nameKey: 'researchAnimalHusbandry', cost: { wheat: 10, research: 25 }, unlocks: [], requires: ['agriculture'], age: 'primitive', color: '#AF601A', posX: 220, posY: 370, era: 1 }, // Added wheat cost, specified RP cost
            writing: { nameKey: 'researchWriting', cost: 30, unlocks: [], requires: ['settlement', 'exploration'], age: 'primitive', color: '#AED6F1', posX: 420, posY: 40, era: 1 },

            // --- Classical Age (Era 2) ---
            bronzeWorking: { nameKey: 'researchBronzeWorking', cost: { copper: 5, coal: 3, research: 40 }, unlocks: [], requires: ['toolMaking', 'masonry'], age: 'classical', color: '#E59866', posX: 820, posY: 200, era: 2 }, // Added copper/coal cost, specified RP cost
            ironWorking: { nameKey: 'researchIronWorking', cost: { iron: 5, coal: 5, research: 50 }, unlocks: [], requires: ['bronzeWorking'], age: 'classical', color: '#95A5A6', posX: 1020, posY: 200, era: 2 }, // Added iron/coal cost, specified RP cost
            philosophy: { nameKey: 'researchPhilosophy', cost: 45, unlocks: [], requires: ['writing'], age: 'classical', color: '#D2B4DE', posX: 620, posY: 40, era: 2 },
            mathematics: { nameKey: 'researchMathematics', cost: 45, unlocks: [], requires: ['writing'], age: 'classical', color: '#85C1E9', posX: 620, posY: 150, era: 2 },
            construction: { nameKey: 'researchConstruction', cost: { pebble: 20, iron: 5, research: 60 }, unlocks: [], requires: ['masonry', 'mathematics'], age: 'classical', color: '#AAB7B8', posX: 820, posY: 370, era: 2 }, // Added iron cost, specified RP cost
        },
         // Tech cost structure: Can be a number (RP only) or object { research: RP, resource1: amount, ... }
        getTechCost: function(techId) {
            const tech = this.tech[techId];
            if (!tech) return null;
            if (typeof tech.cost === 'number') {
                return { research: tech.cost }; // Only research points needed
            } else if (typeof tech.cost === 'object' && tech.cost !== null) {
                return { ...tech.cost }; // Return a copy of the cost object
            }
            return null; // Invalid cost format
        },
        upgrades: {
            movement1: { nameKey: 'upgradeMovement1', cost: 10, effect: { moveBonus: 1 }, maxLevel: 1 },
            autoGather: { nameKey: 'upgradeAutoGather', cost: 15, effect: { autoGather: true }, maxLevel: 1 },
        },
        resources: [
             { id: 'wood', nameKey: 'wood' }, { id: 'pebble', nameKey: 'pebble' }, { id: 'flint', nameKey: 'flint' },
             { id: 'wheat', nameKey: 'wheat' }, { id: 'coal', nameKey: 'coal' },
             { id: 'iron', nameKey: 'iron' }, { id: 'copper', nameKey: 'copper' }, { id: 'nickel', nameKey: 'nickel' }, { id: 'zinc', nameKey: 'zinc' }
        ],
        eraNames: { 1: 'primitiveAge', 2: 'classicalAge' }
    };

    // --- Game State Variables ---
    let gameState = {
        units: [], nextUnitId: 0, selectedUnitId: null,
        inventory: {}, inventoryCapacity: {},
        researchPoints: 0, activeResearch: null, completedTech: new Set(),
        selectedBuilding: null,
        unitToDeploy: null,
        productionProgress: { wheat: 0, coal: 0, quarry: 0 },
        colonyName: "New Colony", currentLanguage: 'en', eventLogs: [],
        viewOffsetX: 0, viewOffsetY: 0, worldData: {},
        revealedTiles: new Set(), naturallyRevealedTiles: new Set(),
        cheatMapRevealed: false,
        highlightEnabled: false, alertTimeout: null, gameInitialized: false
    };

    // --- Noise Generators ---
    let noise = { biome: null, feature: null, water: null };

    // --- Translations (No changes needed here unless resource/tech descriptions change) ---
    const translations = {
        en: {
            gameTitle: "Civilization Simulator", switchLanguageTooltip: "Switch Language / Changer de langue", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colony:",
            inventoryTitle: "Inventory", tutorialButton: "Tutorial", researchButton: "Research", buildingsButton: "Buildings", unitsButton: "Units", upgradeButton: "Upgrades", logsButton: "Logs", saveButton: "Save Game", loadButton: "Load Game", cheatRevealMap: "Reveal Map",
            wood: "Wood", pebble: "Pebbles", flint: "Flint", wheat: "Wheat", coal: "Coal", iron: "Iron", copper: "Copper", nickel: "Nickel", zinc: "Zinc",
            gatherButton: "Gather Resource", noUnitSelected: "No unit selected", onTile: "On Tile:", emptyTile: "Empty", unknownTile: "Unknown",
            researchPointsLabel: "Research Points:", researchStatusResearching: "⏳ Researching", researchStatusComplete: "✅", researchStatusInitial: "Begin your journey! Select units and move them.",
            water: "Water", sand: "Sand", grass: "Grass", forest: "Forest", desert: "Desert",
            tileResourceTree: "Tree (Wood)", tileResourceStone: "Stone (Pebbles)", tileResourceFlint: "Flint", // Added resource names here
            researchPanelTitle: "Technology Tree", primitiveAge: "Primitive Age", classicalAge: "Classical Age",
            researchSettlement: "Settlement", researchSettlementDesc: "Unlocks Houses & Worker deployment.",
            researchAgriculture: "Agriculture", researchAgricultureDesc: "Unlocks Farms (Wheat).",
            researchMining: "Mining", researchMiningDesc: "Unlocks Mines (Coal).",
            researchMasonry: "Masonry", researchMasonryDesc: "Unlocks Quarries (Metals).",
            researchStorage: "Storage", researchStorageDesc: "Unlocks Warehouses (+Cap).",
            researchExploration: "Exploration", researchExplorationDesc: "Enables Scout deployment.",
            researchToolMaking: "Tool Making", researchToolMakingDesc: "Basic understanding of tool crafting.",
            researchAnimalHusbandry: "Animal Husbandry", researchAnimalHusbandryDesc: "Domestication of animals.",
            researchWriting: "Writing", researchWritingDesc: "Develop basic written communication.",
            researchBronzeWorking: "Bronze Working", researchBronzeWorkingDesc: "Combine copper and tin for stronger tools.",
            researchIronWorking: "Iron Working", researchIronWorkingDesc: "Smelt iron for advanced tools and weapons.",
            researchPhilosophy: "Philosophy", researchPhilosophyDesc: "Systematic study of fundamental questions.",
            researchMathematics: "Mathematics", researchMathematicsDesc: "Develop numerical systems and geometry.",
            researchConstruction: "Construction", researchConstructionDesc: "Advanced building techniques.",
            buildingsPanelTitle: "Buildings",
            buildingHouse: "House", buildingHouseDesc: "Provides one slot to deploy a Worker or Scout later via the Units panel.",
            buildingFarm: "Farm", buildingFarmDesc: "Requires Worker. Produces Wheat over time.",
            buildingMine: "Mine", buildingMineDesc: "Requires Worker. Produces Coal over time.",
            buildingQuarry: "Quarry", buildingQuarryDesc: "Requires Worker. Slowly produces Metals.",
            buildingWarehouse: "Warehouse", buildingWarehouseDesc: "Increases Resource Capacity by 50.",
            noBuildingsAvailable: "No buildings available to build yet. Research technology first.",
            unitsPanelTitle: "Deploy Units",
            deployUnitButton: "Deploy {0}",
            noUnitsAvailablePanel: "Research units first!",
            noUnusedHouses: "No unused houses available to deploy units.",
            unitPawn: "Pawn", unitWorker: "Worker", unitScout: "Scout",
            deployUnitMax: "Max",
            logsPanelTitle: "Event Logs", logSearchPlaceholder: "Search logs...", logFilterLabel: "Hide gather/cost messages",
            alertWelcome: "Welcome to {0}!", alertGameStarted: "Game started for colony: {0}",
            alertGathered: "Gathered {1} {0}!",
            alertGatheredQuarry: "Quarry produced 1 {0}!", alertGatheredEvent: "Found a cache: +{1} {0}!",
            alertStorageFull: "Storage full for {0}!",
            alertNotEnoughResources: "Not enough resources for {0}!", alertCannotBuildNonEmpty: "Cannot build: Tile is not empty!", alertCannotBuildExists: "Cannot build: {0} already exists here!", alertCannotBuildOnResource: "Cannot build on a {0}!", alertCannotBuildOnTerrain: "Cannot build on {0}!", alertBuildSelected: "Selected: {0}. Click an empty tile to build.", alertBuildingBuilt: "{0} built!", alertSelectUnitToBuild: "No unit selected to perform build action.", alertUnitCannotBuild: "{0} cannot build {1}s!",
            alertResearchStarted: "Started researching {0}.", alertAlreadyResearching: "Already researching: {0}!", alertResearchComplete: "{0} research complete!", alertNotEnoughResourcesTech: "Not enough resources to start researching {0}!", // Specific alert for tech cost
            alertUnitDeployed: "{0} deployed!",
            alertNoSpaceForUnit: "No available space near the selected House to deploy {0}!",
            alertSelectUnusedHouse: "Select an unused House (highlighted) to deploy the unit.",
            alertInvalidHouseTarget: "Invalid target. Please click an unused House.",
            alertGameSaved: "Game Saved!", alertSaveError: "Error saving game. See console for details.", alertLoadSuccess: "Game loaded successfully for colony: {0}!", alertLoadError: "Error loading game: {0}.", alertLoadInvalidFormat: "Invalid save file format.", alertReadFileError: "Error reading file.", alertSaveVersionMismatch: "Save is from an older version and may not load correctly.",
            alertUnitMoveOccupied: "Cannot move unit: Tile is occupied!", alertMoveInvalid: "Cannot move there.", alertSelectedUnit: "Selected Unit: {0} ({1})",
            promptColonyName: "Welcome to Civilization Simulator! Please name your colony:", defaultColonyName: "New Settlement",
            logGameSaved: "Game state saved.", logNewGame: "New game started for colony:",
            logGainedExp: "{0} ({1}) gained {2} Exp for building {3}.", logGainedExpResearch: "{0} units gained {1} Exp for completing {2}.", logGainedExpEvent: "Unit {0} gained {1} Exp for discovering cache.",
            logCapacityIncreased: "Total capacity for {0} increased to {1}.",
            logInvalidStartRegen: "Invalid start position (surrounded by water). Regenerating map...", logInvalidStartGiveUp: "Could not find valid start position after {0} attempts. Starting anyway.",
            unitExpLabel: "Exp:", upgradeSectionTitle: "Unit Upgrades", upgradeInfoSelectUnit: "Select a unit to see upgrades.",
            upgradeMovement1: "Movement I", upgradeMovement1Desc: "Allows moving +1 tile away (Cost: {0} Exp).",
            upgradeAutoGather: "Auto-Gather", upgradeAutoGatherDesc: "Automatically gathers resources on tile arrival (Cost: {0} Exp).",
            upgradeNoUpgradesAvailable: "No upgrades available or affordable for this unit.",
            alertNotEnoughExp: "Not enough Exp for {0}!", alertUpgradeSuccess: "{0} purchased for unit {1}!", alertUpgradeMaxLevel: "Upgrade {0} is already at max level.",
            unusedHouseTarget: "Target",
            tutorialTitle: "How to Play (Basics)",
            tutorialStep1: "Select your starting <code>Pawn</code> (blue 'P').",
            tutorialStep2: "Move by clicking adjacent land tiles.",
            tutorialStep3: "Move onto <code>Tree</code> (🌳) or <code>Stone</code> and click <code>Gather Resource</code>.",
            tutorialStep4: "Gather Wood/Pebbles. Note <code>Inventory</code> limits.",
            tutorialStep5: "Click <code>Research</code> and research <code>Settlement</code> (in the modal).", // Updated step 5
            tutorialStep6: "Once done, click <code>Buildings</code>, select <code>House</code>.",
            tutorialStep7: "Click an empty <code>Grass</code> tile near your Pawn to build.",
            tutorialStep8: "A House provides one slot to deploy a unit later.",
            tutorialStep9: "Research <code>Exploration</code> to enable Scout deployment.",
            tutorialStep10: "Click the <code>Units</code> button (middle column).",
            tutorialStep11: "If tech is researched and an unused House exists, click <code>Deploy Worker/Scout</code>.",
            tutorialStep12: "Unused <code>Houses</code> will highlight. Click a highlighted House to deploy the unit nearby.",
            tutorialStep13: "Each House can deploy only one unit.",
            tutorialStep14: "Research <code>Agriculture</code> for Farms (built by Workers).",
            tutorialStep15: "Research <code>Storage</code> for <code>Warehouses</code> to increase capacity.",
            tutorialStep16: "Units gain <code>Exp</code>. Click <code>Upgrades</code> (right) to spend Exp.",
            closeButton: "Close",
            unlocksLabel: "Unlocks:", // NEW
            legendResearched: "Researched",
            legendAvailable: "Available",
            legendResearching: "Researching",
            legendUnavailable: "Unavailable",
            cheatMapRevealed: "Map Revealed", // Cheat status text
            cheatMapHidden: "Map Hidden", // Cheat status text
        },
        fr: { // REMEMBER TO UPDATE FRENCH KEYS if adding new descriptions etc.
            gameTitle: "Civilization Simulator", switchLanguageTooltip: "Changer de langue / Switch Language", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colonie :",
            inventoryTitle: "Inventaire", tutorialButton: "Tutoriel", researchButton: "Recherche", buildingsButton: "Bâtiments", unitsButton: "Unités", upgradeButton: "Améliorations", logsButton: "Journaux", saveButton: "Sauvegarder", loadButton: "Charger", cheatRevealMap: "Révéler Carte",
            wood: "Bois", pebble: "Cailloux", flint: "Silex", wheat: "Blé", coal: "Charbon", iron: "Fer", copper: "Cuivre", nickel: "Nickel", zinc: "Zinc",
            gatherButton: "Récolter Ressource", noUnitSelected: "Aucune unité sélectionnée", onTile: "Sur la case :", emptyTile: "Vide", unknownTile: "Inconnu",
            researchPointsLabel: "Points de Recherche :", researchStatusResearching: "⏳ Recherche en cours", researchStatusComplete: "✅", researchStatusInitial: "Commencez votre voyage ! Sélectionnez les unités et déplacez-les.",
            water: "Eau", sand: "Sable", grass: "Herbe", forest: "Forêt", desert: "Désert",
            tileResourceTree: "Arbre (Bois)", tileResourceStone: "Roche (Cailloux)", tileResourceFlint: "Silex", // Added resource names fr
            researchPanelTitle: "Arbre Technologique", primitiveAge: "Âge Primitif", classicalAge: "Âge Classique",
            researchSettlement: "Colonisation", researchSettlementDesc: "Débloque Maisons & déploiement Ouvriers.",
            researchAgriculture: "Agriculture", researchAgricultureDesc: "Débloque Fermes (Blé).",
            researchMining: "Minage", researchMiningDesc: "Débloque Mines (Charbon).",
            researchMasonry: "Maçonnerie", researchMasonryDesc: "Débloque Carrières (Métaux).",
            researchStorage: "Stockage", researchStorageDesc: "Débloque Entrepôts (+Cap).",
            researchExploration: "Exploration", researchExplorationDesc: "Permet déploiement Éclaireurs.",
            researchToolMaking: "Fabrication d'Outils", researchToolMakingDesc: "Compréhension basique de l'artisanat.",
            researchAnimalHusbandry: "Élevage", researchAnimalHusbandryDesc: "Domestication des animaux.",
            researchWriting: "Écriture", researchWritingDesc: "Développe la communication écrite.",
            researchBronzeWorking: "Travail du Bronze", researchBronzeWorkingDesc: "Combine cuivre et étain pour outils.",
            researchIronWorking: "Travail du Fer", researchIronWorkingDesc: "Fond le fer pour outils avancés.",
            researchPhilosophy: "Philosophie", researchPhilosophyDesc: "Étude systématique des questions.",
            researchMathematics: "Mathématiques", researchMathematicsDesc: "Développe systèmes numériques/géométrie.",
            researchConstruction: "Construction", researchConstructionDesc: "Techniques de construction avancées.",
            buildingsPanelTitle: "Bâtiments",
            buildingHouse: "Maison", buildingHouseDesc: "Fournit un emplacement pour déployer un Ouvrier ou Éclaireur plus tard via le panneau Unités.",
            buildingFarm: "Ferme", buildingFarmDesc: "Nécessite Ouvrier. Produit du Blé.",
            buildingMine: "Mine", buildingMineDesc: "Nécessite Ouvrier. Produit du Charbon.",
            buildingQuarry: "Carrière", buildingQuarryDesc: "Nécessite Ouvrier. Produit des Métaux.",
            buildingWarehouse: "Entrepôt", buildingWarehouseDesc: "Augmente la Capacité de Ressources de 50.",
            noBuildingsAvailable: "Aucun bâtiment à construire. Recherchez d'abord.",
            unitsPanelTitle: "Déployer Unités",
            deployUnitButton: "Déployer {0}",
            noUnitsAvailablePanel: "Recherchez des unités d'abord !",
            noUnusedHouses: "Aucune maison inutilisée disponible pour déployer des unités.",
            unitPawn: "Colon", unitWorker: "Ouvrier", unitScout: "Éclaireur",
            deployUnitMax: "Max",
            logsPanelTitle: "Journal des Événements", logSearchPlaceholder: "Rechercher...", logFilterLabel: "Masquer messages récolte/coût",
            alertWelcome: "Bienvenue à {0} !", alertGameStarted: "Partie démarrée pour : {0}",
            alertGathered: "Récolté {1} {0} !",
            alertGatheredQuarry: "Carrière a produit 1 {0} !", alertGatheredEvent: "Cache trouvée : +{1} {0}!",
            alertStorageFull: "Stockage plein pour {0} !",
            alertNotEnoughResources: "Pas assez de ressources pour {0} !", alertCannotBuildNonEmpty: "Construction impossible : Case non vide !", alertCannotBuildExists: "{0} existe déjà ici !", alertCannotBuildOnResource: "Construction impossible sur un(e) {0} !", alertCannotBuildOnTerrain: "Construction impossible sur {0} !", alertBuildSelected: "Sélectionné : {0}. Cliquez une case vide.", alertBuildingBuilt: "{0} construit(e) !", alertSelectUnitToBuild: "Pas d'unité sélectionnée pour construire.", alertUnitCannotBuild: "{0} ne peut pas construire de {1}s !",
            alertResearchStarted: "Recherche commencée pour {0}.", alertAlreadyResearching: "Recherche déjà en cours : {0} !", alertResearchComplete: "Recherche {0} terminée !", alertNotEnoughResourcesTech: "Pas assez de ressources pour rechercher {0} !", // Specific alert fr
            alertUnitDeployed: "{0} déployé !",
            alertNoSpaceForUnit: "Pas d'espace près de la Maison sélectionnée pour déployer {0} !",
            alertSelectUnusedHouse: "Sélectionnez une Maison inutilisée (surlignée) pour déployer l'unité.",
            alertInvalidHouseTarget: "Cible invalide. Veuillez cliquer sur une Maison inutilisée.",
            alertGameSaved: "Partie Sauvegardée !", alertSaveError: "Erreur sauvegarde.", alertLoadSuccess: "Partie chargée : {0} !", alertLoadError: "Erreur chargement : {0}.", alertLoadInvalidFormat: "Format sauvegarde invalide.", alertReadFileError: "Erreur lecture fichier.", alertSaveVersionMismatch: "Sauvegarde d'une ancienne version, peut mal charger.",
            alertUnitMoveOccupied: "Déplacement impossible : Case occupée !", alertMoveInvalid: "Déplacement impossible.", alertSelectedUnit: "Unité sélectionnée : {0} ({1})",
            promptColonyName: "Bienvenue ! Nommez votre colonie :", defaultColonyName: "Nouvelle Colonie",
            logGameSaved: "État sauvegardé.", logNewGame: "Nouvelle partie démarrée :",
            logGainedExp: "{0} ({1}) gagne {2} Exp pour construction de {3}.", logGainedExpResearch: "Unités {0} gagnent {1} Exp pour recherche {2}.", logGainedExpEvent: "Unité {0} gagne {1} Exp pour découverte de cache.",
            logCapacityIncreased: "Capacité totale pour {0} augmentée à {1}.",
            logInvalidStartRegen: "Position départ invalide (isolée par eau). Régénération map...", logInvalidStartGiveUp: "Impossible trouver position départ valide après {0} essais. Démarrage quand même.",
            unitExpLabel: "Exp :", upgradeSectionTitle: "Améliorations", upgradeInfoSelectUnit: "Sélectionnez une unité.",
            upgradeMovement1: "Mouvement I", upgradeMovement1Desc: "Permet de se déplacer +1 case (Coût : {0} Exp).",
            upgradeAutoGather: "Récolte Auto", upgradeAutoGatherDesc: "Récolte auto à l'arrivée (Coût : {0} Exp).",
            upgradeNoUpgradesAvailable: "Aucune amélioration disponible/abordable.",
            alertNotEnoughExp: "Pas assez d'Exp pour {0} !", alertUpgradeSuccess: "{0} acheté pour unité {1} !", alertUpgradeMaxLevel: "Amélioration {0} au niveau max.",
            unusedHouseTarget: "Cible",
            tutorialTitle: "Comment Jouer (Bases)",
            tutorialStep1: "Sélectionnez votre <code>Colon</code> (bleu 'P').", // Updated fr Pawn to P
            tutorialStep2: "Déplacez-vous sur une case terrestre adjacente vide.",
            tutorialStep3: "Allez sur <code>Arbre</code>/<code>Roche</code> et cliquez <code>Récolter Ressource</code>.",
            tutorialStep4: "Récoltez Bois/Cailloux. Notez les limites d'<code>Inventaire</code>.",
            tutorialStep5: "Cliquez <code>Recherche</code> et recherchez <code>Colonisation</code> (dans le modal).",
            tutorialStep6: "Puis, cliquez <code>Bâtiments</code>, sélectionnez <code>Maison</code>.",
            tutorialStep7: "Cliquez sur une case <code>Herbe</code> vide près du Colon.",
            tutorialStep8: "Une Maison fournit un emplacement pour déployer une unité plus tard.",
            tutorialStep9: "Recherchez <code>Exploration</code> pour activer le déploiement d'Éclaireurs.",
            tutorialStep10: "Cliquez sur le bouton <code>Unités</code> (colonne centrale).",
            tutorialStep11: "Si la tech est recherchée et une Maison inutilisée existe, cliquez <code>Déployer Ouvrier/Éclaireur</code>.",
            tutorialStep12: "Les <code>Maisons</code> inutilisées seront surlignées. Cliquez une Maison surlignée pour déployer l'unité à proximité.",
            tutorialStep13: "Chaque Maison ne peut déployer qu'une seule unité.",
            tutorialStep14: "Recherchez <code>Agriculture</code> pour les Fermes (construites par Ouvriers).",
            tutorialStep15: "Recherchez <code>Stockage</code> pour les <code>Entrepôts</code> (+ capacité).",
            tutorialStep16: "Unités gagnent <code>Exp</code>. Cliquez <code>Améliorations</code> (droite) pour dépenser l'Exp.",
            closeButton: "Fermer",
            unlocksLabel: "Débloque :", // NEW fr
            legendResearched: "Recherché",
            legendAvailable: "Disponible",
            legendResearching: "En recherche",
            legendUnavailable: "Indisponible",
            cheatMapRevealed: "Carte Révélée", // Cheat status fr
            cheatMapHidden: "Carte Cachée", // Cheat status fr
        }
    };

    // --- Helper Functions ---
    const getLang = () => translations[gameState.currentLanguage] || translations.en;
    const getLangMsg = (key, args = []) => { let msg = getLang()[key] || key; const argsArray = Array.isArray(args) ? args : [args]; argsArray.forEach((arg, index) => { const translatedArg = getLang()[arg] !== undefined ? getLang()[arg] : arg; msg = msg.replace(`{${index}}`, translatedArg); }); return msg; };
    const getFormattedTime = () => { const n = new Date(); return `${n.getHours().toString().padStart(2, '0')}:${n.getMinutes().toString().padStart(2, '0')}`; };
    function showAlert(messageKey, duration = gameConfig.alertDuration, logIt = true, args = []) { clearTimeout(gameState.alertTimeout); const message = getLangMsg(messageKey, args); if (logIt) { const timeString = getFormattedTime(); const storedArgs = (Array.isArray(args) ? args : [args]).map(arg => (typeof arg === 'number' || typeof arg === 'boolean' || arg === null) ? arg : String(arg)); gameState.eventLogs.push({ time: timeString, messageKey: messageKey, args: storedArgs, rendered: message }); if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift(); if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay(); } DOMElements.alertMessageElement.textContent = message; DOMElements.alertMessageElement.style.display = 'block'; void DOMElements.alertMessageElement.offsetWidth; DOMElements.alertMessageElement.classList.add('show'); gameState.alertTimeout = setTimeout(() => { DOMElements.alertMessageElement.classList.remove('show'); DOMElements.alertMessageElement.addEventListener('transitionend', function handleTransitionEnd() { if (! DOMElements.alertMessageElement.classList.contains('show')) { DOMElements.alertMessageElement.style.display = 'none'; } DOMElements.alertMessageElement.removeEventListener('transitionend', handleTransitionEnd); }, {once: true}); }, duration); }
    function updateLogsDisplay() { DOMElements.logsList.innerHTML = ''; const searchTerm = DOMElements.logSearchInput.value.toLowerCase(); const hideFiltered = DOMElements.logFilterCheckbox.checked; const filteredLogs = gameState.eventLogs.filter(log => { const currentRendered = log.rendered || getLangMsg(log.messageKey, log.args); const messageLower = currentRendered.toLowerCase(); const searchMatch = messageLower.includes(searchTerm); if (!searchMatch) return false; if (hideFiltered) { const isGather = log.messageKey === 'alertGathered' || log.messageKey === 'alertGatheredQuarry' || log.messageKey === 'alertGatheredEvent'; const isCost = log.messageKey === 'alertNotEnoughResources' || log.messageKey === 'alertNotEnoughResourcesTech'; const isExp = log.messageKey === 'logGainedExp' || log.messageKey === 'logGainedExpResearch' || log.messageKey === 'logGainedExpEvent'; const isStorage = log.messageKey === 'alertStorageFull'; const isRegen = log.messageKey === 'logInvalidStartRegen' || log.messageKey === 'logInvalidStartGiveUp'; const isCheat = log.messageKey === 'cheatMapRevealed' || log.messageKey === 'cheatMapHidden'; if (isGather || isCost || isExp || isStorage || isRegen || isCheat) return false; } return true; }); const fragment = document.createDocumentFragment(); for (let i = filteredLogs.length - 1; i >= 0; i--) { const log = filteredLogs[i]; const logEntry = document.createElement('li'); const timeSpan = document.createElement('span'); timeSpan.className = 'log-time'; timeSpan.textContent = `[${log.time}]`; logEntry.appendChild(timeSpan); logEntry.appendChild(document.createTextNode(` ${log.rendered || getLangMsg(log.messageKey, log.args)}`)); fragment.appendChild(logEntry); } DOMElements.logsList.appendChild(fragment); }
    function initializeGridDOM() { const f = document.createDocumentFragment(); for (let y=0; y<gameConfig.gridSize; y++) { for (let x=0; x<gameConfig.gridSize; x++) { const t = document.createElement('div'); t.className = 'tile'; t.dataset.gridX = x; t.dataset.gridY = y; f.appendChild(t); } } DOMElements.grid.innerHTML = ''; DOMElements.grid.appendChild(f); }
    function getTileData(x, y) { return gameState.worldData[y]?.[x]; }
    function setTileData(x, y, d) { if (!gameState.worldData[y]) gameState.worldData[y] = {}; gameState.worldData[y][x] = d; }
    function generateTileContent(x, y, cheat=false) { const cS=`${x},${y}`; if (getTileData(x, y)) { gameState.revealedTiles.add(cS); return getTileData(x, y); } gameState.revealedTiles.add(cS); let type='unknown'; let biome='forest'; const bNV = noise.biome.noise2D(x/gameConfig.noiseScales.biome, y/gameConfig.noiseScales.biome); if (bNV >= gameConfig.noiseThresholds.biomeDesert) biome='desert'; const wNV = noise.water.noise2D(x/gameConfig.noiseScales.water, y/gameConfig.noiseScales.water); if (wNV < gameConfig.noiseThresholds.lake) { type='water'; } else { const fNV = noise.feature.noise2D(x/gameConfig.noiseScales.feature, y/gameConfig.noiseScales.feature); if (biome==='forest') { if(fNV<gameConfig.noiseThresholds.treeForest) type='tree'; else if(fNV<gameConfig.noiseThresholds.flintForest) type='flint'; else if(fNV<gameConfig.noiseThresholds.stoneForest) type='stone'; else type='grass'; } else { type='sand'; const r=Math.random(); if(r<gameConfig.desertStoneChance) type='stone'; else if(r<gameConfig.desertStoneChance+0.03) type='flint'; } let isNW=false; for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nW=noise.water.noise2D((x+dx)/gameConfig.noiseScales.water,(y+dy)/gameConfig.noiseScales.water); if(nW<gameConfig.noiseThresholds.lake){ isNW=true; break; } } if(isNW) break; } if(isNW&&type!=='water'&&biome!=='desert'){ type='sand'; } } if (!cheat) { if (x === 5 && y === 5 && type === 'water') { type='grass'; biome='forest'; } else if (Math.abs(x-5)<=1&&Math.abs(y-5)<=1&&type==='water') { type='grass'; biome='forest'; } } const d={type:type, building:null, biome:biome, unitDeployed:null}; setTileData(x,y,d); return d; }
    function revealArea(cX, cY, rad) { let nRN = false; for (let dy=-rad; dy<=rad; dy++) { for (let dx=-rad; dx<=rad; dx++) { if (Math.sqrt(dx*dx+dy*dy)>rad+0.1) continue; const wx=cX+dx; const wy=cY+dy; const cS=`${wx},${wy}`; if (!gameState.naturallyRevealedTiles.has(cS)) { if (!getTileData(wx, wy)) { generateTileContent(wx, wy, false); } gameState.revealedTiles.add(cS); gameState.naturallyRevealedTiles.add(cS); nRN=true; } else if (!gameState.revealedTiles.has(cS)) { gameState.revealedTiles.add(cS); } } } return nRN; }
    function updateGrid() { const ts=DOMElements.grid.querySelectorAll('.tile'); const l=getLang(); ts.forEach(t=>{const eM=t.querySelector('.unit-marker');if(eM)eM.remove();t.className='tile';t.textContent='';t.title='';t.removeAttribute('data-tooltip');t.classList.remove('highlight','unknown','highlight-house-target');}); ts.forEach(t=>{const gx=parseInt(t.dataset.gridX); const gy=parseInt(t.dataset.gridY); const wx=gx+gameState.viewOffsetX; const wy=gy+gameState.viewOffsetY; const cS=`${wx},${wy}`; const isR=gameState.revealedTiles.has(cS); if(!isR){t.classList.add('unknown'); t.title=l.unknownTile;} else { let d=getTileData(wx,wy); if(!d){ console.warn(`Gen missing tile @${wx},${wy}`); generateTileContent(wx,wy,gameState.cheatMapRevealed); d=getTileData(wx,wy); } let tT=l.emptyTile; if(d){ t.classList.add(d.type); t.classList.add(`biome-${d.biome}`); if(d.building){ const bI=gameConfig.buildings[d.building]; t.classList.add(d.building); t.textContent=(bI?.nameKey?l[bI.nameKey]:d.building).substring(0,4).toUpperCase(); tT=l[bI?.nameKey]||d.building; if(gameState.unitToDeploy&&d.building==='house'&&d.unitDeployed===false){t.classList.add('highlight-house-target','highlight');tT+=` (${l.unusedHouseTarget||'Target'})`;} } else if(d.type==='tree'){t.textContent='🌳';tT=l.tileResourceTree;} else if(d.type==='stone'){t.textContent='🪨';tT=l.tileResourceStone;} else if(d.type==='flint'){t.textContent='◾';tT=l.tileResourceFlint;} else if(d.type==='water'){tT=l.water;} else if(d.type==='sand'){tT=l.sand;} else if(d.type==='grass'){tT=l.grass;} else {tT=l.emptyTile;} if(d.biome!=='forest'&&(d.type==='grass'||d.type==='tree'||d.type==='stone'||d.type==='flint')){tT+=` (${l[d.biome]||d.biome})`;} else if(d.biome==='forest'&&d.type==='sand'){tT+=` (${l[d.biome]||d.biome})`;} t.title=tT;} else { t.classList.add('unknown');t.textContent='?';t.title='Error: Missing Data';console.error(`Tile data STILL missing @${wx},${wy}`);} } }); gameState.units.forEach(u=>{const uGX=u.worldX-gameState.viewOffsetX; const uGY=u.worldY-gameState.viewOffsetY; if(uGX>=0&&uGX<gameConfig.gridSize&&uGY>=0&&uGY<gameConfig.gridSize){const t=DOMElements.grid.querySelector(`.tile[data-grid-x="${uGX}"][data-grid-y="${uGY}"]`); if(t&&!t.classList.contains('unknown')){const uI=gameConfig.units[u.type]; const m=document.createElement('div'); m.className=`unit-marker ${u.type}`; m.textContent=uI?.icon||u.type.charAt(0).toUpperCase(); const tUT=l[uI?.nameKey]||u.type; if(u.id===gameState.selectedUnitId)m.classList.add('selected'); t.appendChild(m); if(t.title&&!t.title.startsWith(tUT))t.title=`${tUT} (${u.id}) - ${t.title}`; else if(!t.title)t.title=`${tUT} (${u.id})`; } } }); const sU=gameState.units.find(u=>u.id===gameState.selectedUnitId); if(gameState.highlightEnabled&&sU&&!gameState.unitToDeploy&&!gameState.selectedBuilding){const uI=gameConfig.units[sU.type]; const uGX=sU.worldX-gameState.viewOffsetX; const uGY=sU.worldY-gameState.viewOffsetY; if(uGX>=0&&uGX<gameConfig.gridSize&&uGY>=0&&uGY<gameConfig.gridSize){let mM=uI?.move||1; if(sU.upgrades?.movement1)mM+=gameConfig.upgrades.movement1.effect.moveBonus; ts.forEach(t=>{const tGX=parseInt(t.dataset.gridX); const tGY=parseInt(t.dataset.gridY); const tWX=tGX+gameState.viewOffsetX; const tWY=tGY+gameState.viewOffsetY; const dist=Math.abs(tGX-uGX)+Math.abs(tGY-uGY); if(dist>0&&dist<=mM&&!t.classList.contains('unknown')){const tD=getTileData(tWX,tWY); const tO=gameState.units.some(un=>un.id!==sU.id&&un.worldX===tWX&&un.worldY===tWY); if(tD&&tD.type!=='water'&&!tO&&!t.classList.contains('highlight-house-target')){t.classList.add('highlight');} } }); } } checkResource(); }
    function updateInventoryDisplay() { const f = document.createDocumentFragment(); const l = getLang(); const t = DOMElements.inventoryDisplay.querySelector('h2'); DOMElements.inventoryDisplay.innerHTML = ''; DOMElements.inventoryDisplay.appendChild(t); gameConfig.resources.forEach(r => { const p = document.createElement('p'); const c = gameState.inventory[r.id] || 0; const a = gameState.inventoryCapacity[r.id] || 0; p.innerHTML = `${l[r.nameKey] || r.id}: <span id="${r.id}-count">${c}</span> / ${a}`; f.appendChild(p); }); DOMElements.inventoryDisplay.appendChild(f); }
    function updateResource(rId, amt) { const cur = gameState.inventory[rId] || 0; const cap = gameState.inventoryCapacity[rId] || 0; const nAmt = Math.max(0, cur + amt); if (amt > 0 && nAmt > cap) { gameState.inventory[rId] = cap; if (cur < cap) { showAlert('alertStorageFull', 2000, true, [rId]); } return false; } else if (amt < 0 && nAmt < 0) { console.warn(`Attempted spend > have ${rId}`); return false; } else { gameState.inventory[rId] = nAmt; updateInventoryDisplay(); return true; } }
    function canAfford(costObj) { return Object.entries(costObj).every(([rId, amt]) => (gameState.inventory[rId] || 0) >= amt); }
    function spendResources(costObj) { if (!canAfford(costObj)) return false; Object.entries(costObj).forEach(([rId, amt]) => { updateResource(rId, -amt); }); return true; }
    function updateResearchPointsDisplay() { DOMElements.researchPointsDisplay.textContent = gameState.researchPoints; }
    function updateUnitInfoDisplay() { const sU = gameState.units.find(u => u.id === gameState.selectedUnitId); const l = getLang(); if (sU) { DOMElements.unitCoordsDisplay.textContent = `(${sU.worldX}, ${sU.worldY})`; const tD = getTileData(sU.worldX, sU.worldY); DOMElements.unitBiomeDisplay.textContent = tD ? (l[tD.biome] || tD.biome) : l.unknownTile; DOMElements.unitExpDisplay.textContent = sU.exp || 0; } else { DOMElements.unitCoordsDisplay.textContent = `(-, -)`; DOMElements.unitBiomeDisplay.textContent = l.unknownTile; DOMElements.unitExpDisplay.textContent = '0'; } DOMElements.upgradeInfoContent.innerHTML = ''; const uT = document.createElement('h4'); uT.textContent = l.upgradeSectionTitle; DOMElements.upgradeInfoContent.appendChild(uT); if (sU) { const uC = gameConfig.units[sU.type]; let uA = 0; (uC.upgrades || []).forEach(uId => { const uG = gameConfig.upgrades[uId]; if (!uG) return; const cL = sU.upgrades?.[uId] || 0; if (cL < uG.maxLevel) { const c = uG.cost; const uB = document.createElement('button'); uB.dataset.upgradeType = uId; uB.textContent = `${getLangMsg(uG.nameKey)} (${c} Exp)`; uB.disabled = sU.exp < c; uB.title = getLangMsg(uG.nameKey + 'Desc', [c]); uB.addEventListener('click', handleUpgradeClick); DOMElements.upgradeInfoContent.appendChild(uB); uA++; } }); if (uA === 0) { const nU = document.createElement('p'); nU.textContent = l.upgradeNoUpgradesAvailable; DOMElements.upgradeInfoContent.appendChild(nU); } } else { const sT = document.createElement('p'); sT.textContent = l.upgradeInfoSelectUnit; DOMElements.upgradeInfoContent.appendChild(sT); } }
    function updateResearchUI() { const l = getLang(); const dA = DOMElements.techTreeDisplayArea; dA.innerHTML = ''; const isR = !!gameState.activeResearch; const eras = new Set(Object.values(gameConfig.tech).map(t => t.era)); eras.forEach(eN => { const eTK = gameConfig.eraNames[eN]; if(eTK) { const eT = document.createElement('div'); eT.className = 'era-title'; eT.textContent = l[eTK] || `Era ${eN}`; const eTO = (eN - 1) * 350; eT.style.top = `${eTO + 5}px`; dA.appendChild(eT); } }); const tD = {}; Object.entries(gameConfig.tech).forEach(([id, t]) => { t.requires.forEach(rId => { if (!tD[rId]) tD[rId] = []; tD[rId].push(id); }); }); Object.entries(gameConfig.tech).forEach(([id, t]) => { const isC = gameState.completedTech.has(id); const fullCost = gameConfig.getTechCost(id); const canAffordRes = fullCost ? Object.entries(fullCost).every(([res, amt]) => res === 'research' || (gameState.inventory[res] || 0) >= amt) : true; const canResearch = !isR && !isC && t.requires.every(r => gameState.completedTech.has(r)) && canAffordRes; const isCurR = gameState.activeResearch === id; const n = document.createElement('div'); n.className = 'tech-node'; n.id = `tech-node-${id}`; n.style.left = `${t.posX || 10}px`; n.style.top = `${t.posY || 10}px`; if (isC) n.classList.add('researched'); else if (isCurR) n.classList.add('researching'); else if (canResearch) n.classList.add('available'); else n.classList.add('unavailable'); const nmD = document.createElement('div'); nmD.className = 'tech-name'; nmD.textContent = l[t.nameKey] || id; if (isC) nmD.textContent += ` ${l.researchStatusComplete}`; const cP = document.createElement('p'); cP.className = 'tech-cost'; const costString = fullCost ? Object.entries(fullCost).map(([res, amt]) => `${amt} ${res === 'research' ? 'RP' : (l[res] || res)}`).join(', ') : 'Error'; cP.textContent = `(${costString})`; const uD = document.createElement('div'); uD.className = 'tech-unlocks'; const uLS = document.createElement('span'); uLS.textContent = `${l.unlocksLabel} `; uD.appendChild(uLS); let uT = ""; if (t.unlocks && t.unlocks.length > 0) { uT = t.unlocks.map(uK => { const bC = gameConfig.buildings[uK]; return bC?.nameKey ? (l[bC.nameKey] || uK) : (l[uK] || uK); }).join(', '); } if (id === 'exploration') { const sC = gameConfig.units['scout']; if (sC) uT += (uT ? ', ' : '') + (l[sC.nameKey] || 'Scout'); } else if (id === 'settlement') { const wC = gameConfig.units['worker']; if (wC) uT += (uT ? ', ' : '') + (l[wC.nameKey] || 'Worker'); } if (!uT) { uD.style.display = 'none'; } else { uD.appendChild(document.createTextNode(uT)); } const pC = document.createElement('div'); pC.className = 'research-progress-container'; pC.style.display = isCurR ? 'flex' : 'none'; const pB = document.createElement('div'); pB.id = `${id}-research-bar-modal`; pB.className = 'research-progress-bar'; pB.style.backgroundColor = t.color || '#3498db'; if (isCurR && fullCost) { const progress = Math.min(100, fullCost.research > 0 ? (gameState.researchPoints / fullCost.research) * 100 : 100); pB.style.width = progress + '%'; } pC.appendChild(pB); n.appendChild(nmD); n.appendChild(cP); n.appendChild(uD); n.appendChild(pC); if (canResearch || (!canAffordRes && !isR && !isC && t.requires.every(r => gameState.completedTech.has(r)))) { n.addEventListener('click', () => handleResearchClick(id)); n.title = `${l[t.nameKey] || id} - Click to research`; if(!canAffordRes) n.title += ` (Insufficient Resources)`; } else if (isC) { n.title = `${l[t.nameKey] || id} - Researched`; } else if (isCurR) { n.title = `${l[t.nameKey] || id} - Researching...`; } else { const p = t.requires.filter(rId => !gameState.completedTech.has(rId)).map(rId => l[gameConfig.tech[rId]?.nameKey] || rId).join(', '); n.title = `${l[t.nameKey] || id} - Requires: ${p || 'Unknown'}`; } if (tD[id] && tD[id].length > 0) { const hHC = tD[id].some(cId => { const cT = gameConfig.tech[cId]; return cT && Math.abs(cT.posY - t.posY) < 50 && cT.posX > (t.posX + n.offsetWidth + 10); }); if (hHC) { n.classList.add('has-horizontal-connector'); } } dA.appendChild(n); }); updateResearchStatusDisplayOnly(); }
    function updateResearchStatusDisplayOnly() { const l = getLang(); if (gameState.activeResearch) { const t = gameConfig.tech[gameState.activeResearch]; const c = gameConfig.getTechCost(gameState.activeResearch); if (!t || !c) return; const p = Math.min(100, c.research > 0 ? (gameState.researchPoints / c.research) * 100 : 100); DOMElements.researchStatusDisplay.textContent = `${getLangMsg('researchStatusResearching')} ${l[t.nameKey] || gameState.activeResearch}... ${Math.floor(p)}%`; DOMElements.researchStatusDisplay.style.display = 'block'; } else if (gameState.completedTech.size === 0 && gameState.gameInitialized) { DOMElements.researchStatusDisplay.textContent = l.researchStatusInitial; DOMElements.researchStatusDisplay.style.display = 'block'; } else { DOMElements.researchStatusDisplay.textContent = ''; DOMElements.researchStatusDisplay.style.display = 'none'; } }
    function updateResearchProgress() { if (!gameState.activeResearch) return; const tId = gameState.activeResearch; const t = gameConfig.tech[tId]; const cost = gameConfig.getTechCost(tId); if (!t || !cost) { gameState.activeResearch = null; return; } const rpCost = cost.research || 0; const progress = Math.min(100, rpCost > 0 ? (gameState.researchPoints / rpCost) * 100 : 100); if (DOMElements.techTreeModal.style.display === 'block') { const pBM = document.getElementById(`${tId}-research-bar-modal`); if (pBM) { pBM.style.width = progress + '%'; const pC = pBM.closest('.research-progress-container'); if(pC) pC.style.display = 'flex'; } } updateResearchStatusDisplayOnly(); if (gameState.researchPoints >= rpCost) { gameState.completedTech.add(tId); gameState.activeResearch = null; gameState.researchPoints = 0; showAlert('alertResearchComplete', 3500, true, [t.nameKey]); const l = getLang(); DOMElements.researchStatusDisplay.textContent = `${getLangMsg(t.nameKey)} ${getLangMsg('researchStatusComplete')}`; DOMElements.researchStatusDisplay.style.display = 'block'; let eG = false; gameState.units.forEach(u => { const uC = gameConfig.units[u.type]; if (uC?.researchBonus > 0) { u.exp = (u.exp || 0) + gameConfig.expPerResearchComplete * uC.researchBonus; eG = true; } }); if (eG) { logEvent('logGainedExpResearch', ['unitPawn', gameConfig.expPerResearchComplete, t.nameKey]); if(gameState.units.find(u => u.id === gameState.selectedUnitId)?.type === 'pawn') updateUnitInfoDisplay(); } if (DOMElements.techTreeModal.style.display === 'block') { updateResearchUI(); } updateBuildingsList(); updateUnitsPanel(); updateInventoryCapacity(); updateResearchPointsDisplay(); } }
    function updateBuildingsList() { const lE = DOMElements.buildingsListUl; lE.innerHTML = ''; const l = getLang(); let aB = 0; Object.entries(gameConfig.buildings).forEach(([id, b]) => { if (b.unlockedBy && !gameState.completedTech.has(b.unlockedBy)) { return; } aB++; const lI = document.createElement('li'); const btn = document.createElement('button'); const cS = Object.entries(b.cost).map(([res, amt]) => `${amt} ${l[res] || res}`).join(', '); btn.textContent = `${l[b.nameKey] || id}`; btn.dataset.building = id; btn.title = l[b.nameKey] || id; btn.disabled = !canAfford(b.cost); btn.addEventListener('click', () => { gameState.selectedBuilding = id; gameState.unitToDeploy = null; showAlert('alertBuildSelected', 4000, true, [b.nameKey]); gameState.highlightEnabled = false; updateGrid(); updateBuildingsList(); hideAllPanels(); }); const cP = document.createElement('p'); cP.className = 'building-cost'; cP.textContent = `Cost: ${cS}`; const d = document.createElement('p'); d.className = 'description'; d.textContent = getLangMsg(b.nameKey + 'Desc'); lI.appendChild(btn); lI.appendChild(cP); lI.appendChild(d); lE.appendChild(lI); }); if (aB === 0) { lE.innerHTML = `<li>${l.noBuildingsAvailable}</li>`; } }
    function updateUnitDisplayBar() { DOMElements.unitDisplayBar.innerHTML = ''; const l = getLang(); const f = document.createDocumentFragment(); gameState.units.forEach(u => { const uI = gameConfig.units[u.type]; const i = document.createElement('div'); i.className = `unit-icon ${u.type}`; i.dataset.unitId = u.id; i.dataset.unitType = u.type; i.textContent = uI?.icon || u.type.charAt(0).toUpperCase(); const tUT = l[uI?.nameKey] || u.type; i.title = `${tUT} (${u.id})`; if (u.id === gameState.selectedUnitId) { i.classList.add('selected'); } i.addEventListener('click', () => { gameState.selectedUnitId = u.id; gameState.selectedBuilding = null; gameState.unitToDeploy = null; gameState.highlightEnabled = false; focusOnUnit(u.id); }); f.appendChild(i); }); DOMElements.unitDisplayBar.appendChild(f); }
    function updateUnitsPanel() { const lE = DOMElements.unitsListUl; lE.innerHTML = ''; const l = getLang(); let dUC = 0; let hUH = false; gameState.revealedTiles.forEach(cS => { if (hUH) return; const [x, y] = cS.split(',').map(Number); const d = getTileData(x, y); if (d?.building === 'house' && d.unitDeployed === false) { hUH = true; } }); if (!hUH) { lE.innerHTML = `<li>${l.noUnusedHouses}</li>`; return; } Object.entries(gameConfig.units).forEach(([uId, uC]) => { if (uC.deployableFromPanel && uC.requiredTech && gameState.completedTech.has(uC.requiredTech)) { dUC++; const lI = document.createElement('li'); const btn = document.createElement('button'); btn.dataset.unitType = uId; btn.textContent = getLangMsg('deployUnitButton', [uC.nameKey]); btn.addEventListener('click', () => { gameState.unitToDeploy = uId; gameState.selectedBuilding = null; gameState.highlightEnabled = true; showAlert('alertSelectUnusedHouse', 4000); updateGrid(); hideAllPanels(); }); lI.appendChild(btn); lE.appendChild(lI); } }); if (dUC === 0 && hUH) { lE.innerHTML = `<li>${l.noUnitsAvailablePanel}</li>`; } }
    function updateInventoryCapacity() { gameState.inventoryCapacity = { ...gameConfig.baseInventoryCapacity }; let wB = 0; gameState.revealedTiles.forEach(cS => { const [x, y] = cS.split(',').map(Number); const d = getTileData(x, y); if (d?.building === 'warehouse') { wB += gameConfig.buildings.warehouse.provides.capacityBonus || 0; } }); for (const rId in gameState.inventoryCapacity) { gameState.inventoryCapacity[rId] += wB; } updateInventoryDisplay(); }

    // --- Gameplay Functions ---
    function checkResource() {
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        let canGather = false;
        let tileNameKey = 'noUnitSelected';
        let tileArgs = [];

        if (selectedUnit) {
            const data = getTileData(selectedUnit.worldX, selectedUnit.worldY);
            tileNameKey = 'unknownTile';

            if (data) {
                // Check for gatherable resources first (only if no building)
                if (!data.building) {
                    if (data.type === 'tree') {
                        canGather = true; tileNameKey = 'onTile'; tileArgs = ['tileResourceTree'];
                    } else if (data.type === 'stone') {
                        canGather = true; tileNameKey = 'onTile'; tileArgs = ['tileResourceStone'];
                    } else if (data.type === 'flint') {
                        canGather = true; tileNameKey = 'onTile'; tileArgs = ['tileResourceFlint'];
                    } else if (data.type === 'water') {
                        tileNameKey = 'onTile'; tileArgs = ['water'];
                    } else if (data.type === 'sand') {
                        tileNameKey = 'onTile'; tileArgs = ['sand'];
                    } else if (data.type === 'grass') {
                        tileNameKey = 'onTile'; tileArgs = ['grass'];
                    } else {
                         tileNameKey = 'onTile'; tileArgs = ['emptyTile']; // Fallback for other non-resource land
                    }
                } else { // If there is a building, display building name
                    const bInfo = gameConfig.buildings[data.building];
                    tileNameKey = 'onTile';
                    tileArgs = [bInfo?.nameKey || data.building];
                    canGather = false; // Cannot gather from building tiles
                }
            }
        }

        DOMElements.actionButton.style.display = canGather ? 'inline-block' : 'none';
        DOMElements.resourceNameDisplay.textContent = getLangMsg(tileNameKey, tileArgs);
    }
    function triggerRandomEvent(u) { if (Math.random() < gameConfig.eventChance) { let fS = false; for (let rng = 1; rng <= 2 && !fS; rng++) { for (let dy = -rng; dy <= rng; dy++) { for (let dx = -rng; dx <= rng; dx++) { if (Math.abs(dx) + Math.abs(dy) !== rng) continue; const tx = u.worldX + dx; const ty = u.worldY + dy; const tD = getTileData(tx, ty); const cS = `${tx},${ty}`; if (gameState.revealedTiles.has(cS) && tD && tD.type !== 'water' && !tD.building && !gameState.units.some(un => un.worldX === tx && un.worldY === ty)) { const rT = ['wood', 'pebble', 'flint']; const r = rT[Math.floor(Math.random() * rT.length)]; const a = Math.floor(Math.random() * 5) + 2; if (updateResource(r, a)) { showAlert('alertGatheredEvent', 3000, true, [r, a]); u.exp = (u.exp || 0) + gameConfig.expPerEventDiscovery; logEvent('logGainedExpEvent', [u.id, gameConfig.expPerEventDiscovery]); if(u.id === gameState.selectedUnitId) updateUnitInfoDisplay(); fS = true; break; } } } if (fS) break; } } } }
    function moveUnit(tGX, tGY) { const sU = gameState.units.find(u => u.id === gameState.selectedUnitId); if (!sU) return; const tWX = tGX + gameState.viewOffsetX; const tWY = tGY + gameState.viewOffsetY; const uI = gameConfig.units[sU.type]; let mM = uI?.move || 1; if (sU.upgrades?.movement1) mM += gameConfig.upgrades.movement1.effect.moveBonus; const dx = Math.abs(tWX - sU.worldX); const dy = Math.abs(tWY - sU.worldY); if (dx + dy === 0 || dx + dy > mM) { return; } if (!gameState.revealedTiles.has(`${tWX},${tWY}`)) return; const tD = getTileData(tWX, tWY); if (!tD || tD.type === 'water') { showAlert('alertMoveInvalid', 1500, false); return; } const tO = gameState.units.some(un => un.id !== sU.id && un.worldX === tWX && un.worldY === tWY); if (tO) { showAlert("alertUnitMoveOccupied", 2000, false); return; } sU.worldX = tWX; sU.worldY = tWY; revealArea(tWX, tWY, uI?.revealRadius || gameConfig.revealRadiusBase); if (sU.upgrades?.autoGather) { tryAutoGather(sU); } if (gameState.activeResearch) { const rB = uI?.researchBonus || 0; if (rB > 0) { gameState.researchPoints += rB; updateResearchProgress(); } } updateResearchPointsDisplay(); for (const pT in gameState.productionProgress) { gameState.productionProgress[pT]++; const i = gameConfig.productionIntervals[pT]; if (gameState.productionProgress[pT] >= i) { produceResources(pT); gameState.productionProgress[pT] = 0; } } triggerRandomEvent(sU); focusOnUnit(sU.id); }
    function tryAutoGather(u) { const d = getTileData(u.worldX, u.worldY); if (d && !d.building && (d.type === 'tree' || d.type === 'stone' || d.type === 'flint')) { gatherResource(u, true); } }
    function gatherResource(u = null, a = false) { const tU = u || gameState.units.find(un => un.id === gameState.selectedUnitId); if (!tU) { if (!a) showAlert("noUnitSelected", 2000); return; } const d = getTileData(tU.worldX, tU.worldY); if (d && !d.building) { let gRK = null; let bT = d.biome === 'desert' ? 'sand' : 'grass'; let q = 1; if (d.type === 'tree') gRK = 'wood'; else if (d.type === 'stone') gRK = 'pebble'; else if (d.type === 'flint') gRK = 'flint'; if (gRK) { if (updateResource(gRK, q)) { d.type = bT; setTileData(tU.worldX, tU.worldY, d); const lRN = getLangMsg(gRK); if (!a) { showAlert('alertGathered', 1500, true, [lRN, q]); } else { logEvent('alertGathered', [lRN, q], `[Auto] ${getLangMsg('alertGathered', [lRN, q])}`); } updateGrid(); checkResource(); } else { if (!a) { showAlert('alertStorageFull', 2000, true, [getLangMsg(gRK)]); } } } } }
    function produceResources(pT) { let pC = 0; const l = getLang(); gameState.revealedTiles.forEach(cS => { const [x, y] = cS.split(',').map(Number); const d = getTileData(x, y); if (!d || !d.building) return; const bC = gameConfig.buildings[d.building]; if (!bC || !bC.produces || bC.produces.interval !== pT) return; const pI = bC.produces; if (Array.isArray(pI.resource)) { const mK = pI.resource[Math.floor(Math.random() * pI.resource.length)]; if (updateResource(mK, 1)) { if (pC === 0) showAlert('alertGatheredQuarry', 2000, true, [mK]); pC++; } else { if (pC === 0) showAlert('alertStorageFull', 2000, true, [mK]); } } else { const rK = pI.resource; if (updateResource(rK, 1)) { pC++; } else { if (pC === 0) showAlert('alertStorageFull', 2000, true, [rK]); } } }); }
    function findSpawnPoint(aX, aY) { const dirs = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: -1}, {dx: 1, dy: 1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}]; for (const dir of dirs) { const sx = aX + dir.dx; const sy = aY + dir.dy; const sD = getTileData(sx, sy); const cS = `${sx},${sy}`; const isO = gameState.units.some(u => u.worldX === sx && u.worldY === sy); if (gameState.revealedTiles.has(cS) && sD && (sD.type === 'grass' || sD.type === 'sand') && !isO && !sD.building) { return { worldX: sx, worldY: sy }; } } return null; }
    function focusOnUnit(uId) { const u = gameState.units.find(un => un.id === uId); if (!u) return; const uC = gameConfig.units[u.type]; const nVX = u.worldX - gameConfig.viewCenterOffset; const nVY = u.worldY - gameConfig.viewCenterOffset; gameState.viewOffsetX = nVX; gameState.viewOffsetY = nVY; revealArea(u.worldX, u.worldY, uC?.revealRadius || gameConfig.revealRadiusBase); gameState.selectedUnitId = uId; updateUnitDisplayBar(); updateUnitInfoDisplay(); updateGrid(); checkResource(); }
    function logEvent(mK, args = [], rO = null) { const tS = getFormattedTime(); const m = rO !== null ? rO : getLangMsg(mK, args); const sA = (Array.isArray(args) ? args : [args]).map(a => (typeof a === 'number' || typeof a === 'boolean' || a === null) ? a : String(a)); gameState.eventLogs.push({ time: tS, messageKey: mK, args: sA, rendered: m }); if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift(); if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay(); }


    // --- Event Listeners ---
     function setupEventListeners() { /* ... no changes needed in this function itself ... */ DOMElements.grid.addEventListener('click', (event) => { const tile = event.target.closest('.tile'); if (!tile) { if (gameState.unitToDeploy || gameState.selectedBuilding) { gameState.unitToDeploy = null; gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); } return; } const gridX = parseInt(tile.dataset.gridX); const gridY = parseInt(tile.dataset.gridY); const worldX = gridX + gameState.viewOffsetX; const worldY = gridY + gameState.viewOffsetY; if (tile.classList.contains('unknown') && !gameState.unitToDeploy) { return; } if (gameState.unitToDeploy) { if (tile.classList.contains('unknown')) { showAlert('alertInvalidHouseTarget', 2500, true); gameState.unitToDeploy = null; gameState.highlightEnabled = false; updateGrid(); return; } const targetData = getTileData(worldX, worldY); if (targetData?.building === 'house' && targetData.unitDeployed === false) { deployUnitNearHouse(gameState.unitToDeploy, worldX, worldY); } else { showAlert('alertInvalidHouseTarget', 2500, true); gameState.unitToDeploy = null; gameState.highlightEnabled = false; updateGrid(); } return; } if (gameState.selectedBuilding) { handlePlaceBuilding(worldX, worldY); return; } const clickedUnit = gameState.units.find(u => u.worldX === worldX && u.worldY === worldY); if (clickedUnit) { gameState.selectedUnitId = clickedUnit.id; gameState.highlightEnabled = false; focusOnUnit(clickedUnit.id); showAlert('alertSelectedUnit', 1500, false, [gameConfig.units[clickedUnit.type]?.nameKey || clickedUnit.type, clickedUnit.id]); } else if (gameState.selectedUnitId) { moveUnit(gridX, gridY); } if (!gameState.selectedBuilding && !gameState.unitToDeploy) gameState.highlightEnabled = false; }); DOMElements.actionButton.addEventListener('click', () => gatherResource(null, false)); DOMElements.middleControls.addEventListener('click', (event) => { const button = event.target.closest('button[data-panel-target]'); if (button) { togglePanel(button.dataset.panelTarget); } if (event.target.id === 'cheat-reveal-button') { toggleMapRevealCheat(); } }); DOMElements.closeTutorialButton.addEventListener('click', () => { DOMElements.tutorialModal.style.display = 'none'; }); DOMElements.tutorialModal.addEventListener('click', (event) => { if (event.target === DOMElements.tutorialModal) { DOMElements.tutorialModal.style.display = 'none'; } }); DOMElements.closeTechTreeButton.addEventListener('click', () => { DOMElements.techTreeModal.style.display = 'none'; }); DOMElements.techTreeModal.addEventListener('click', (event) => { if (event.target === DOMElements.techTreeModal) { DOMElements.techTreeModal.style.display = 'none'; } }); DOMElements.logSearchInput.addEventListener('input', updateLogsDisplay); DOMElements.logFilterCheckbox.addEventListener('change', updateLogsDisplay); DOMElements.saveButton.addEventListener('click', saveGame); DOMElements.loadButton.addEventListener('click', () => DOMElements.loadFileInput.click()); DOMElements.loadFileInput.addEventListener('change', loadGame); DOMElements.languageSwitchButton.addEventListener('click', switchLanguage); DOMElements.grid.addEventListener('mouseover', (event) => { const tile = event.target.closest('.tile'); if (tile && !tile.classList.contains('unknown') && gameState.selectedUnitId != null && !gameState.selectedBuilding && !gameState.unitToDeploy) { gameState.highlightEnabled = true; updateGrid(); } }); DOMElements.grid.addEventListener('mouseout', (event) => { if (gameState.highlightEnabled && !gameState.selectedBuilding && !gameState.unitToDeploy && (!event.relatedTarget || !event.relatedTarget.closest || !event.relatedTarget.closest('#grid'))) { gameState.highlightEnabled = false; updateGrid(); } }); }

    // --- Action Handlers ---
    function togglePanel(targetId) { const tE = document.getElementById(targetId); if (!tE) return; gameState.selectedBuilding = null; gameState.unitToDeploy = null; gameState.highlightEnabled = false; const iM = tE.id.includes('-modal'); const iV = tE.style.display === 'block' || tE.style.display === 'flex'; hideAllPanels(); if (!iV) { tE.style.display = iM ? 'block' : 'block'; if (targetId === 'tech-tree-modal') { updateResearchUI(); updateLanguageUI(); } else if (targetId === 'tutorial-modal') updateLanguageUI(); else if (targetId === 'buildings-list') updateBuildingsList(); else if (targetId === 'units-panel') updateUnitsPanel(); else if (targetId === 'upgrade-info') updateUnitInfoDisplay(); else if (targetId === 'logs-panel') updateLogsDisplay(); } updateGrid(); }
    function hideAllPanels() { document.querySelectorAll('.panel:not(#inventory)').forEach(p => { p.style.display = 'none'; }); DOMElements.tutorialModal.style.display = 'none'; DOMElements.techTreeModal.style.display = 'none'; }
    function handleResearchClick(techId) {
        const tech = gameConfig.tech[techId];
        if (!tech || gameState.completedTech.has(techId)) return;
        if (gameState.activeResearch && gameState.activeResearch !== techId) {
            showAlert("alertAlreadyResearching", 3000, true, [gameConfig.tech[gameState.activeResearch]?.nameKey || gameState.activeResearch]); return;
        }
        if (!tech.requires.every(req => gameState.completedTech.has(req))) return;

        // Check resource cost (if applicable)
        const fullCost = gameConfig.getTechCost(techId);
        if (!fullCost) { console.error("Invalid cost for tech:", techId); return; }

        const resourceCost = { ...fullCost };
        delete resourceCost.research; // Separate RP cost

        if (!canAfford(resourceCost)) {
             showAlert('alertNotEnoughResourcesTech', 3000, true, [tech.nameKey]);
             return;
        }

        // Spend resources BEFORE starting research
        if (!spendResources(resourceCost)) {
             // This shouldn't happen due to canAfford check, but safeguard
             console.error("Failed to spend resources for tech", techId, "despite passing canAfford check.");
             return;
        }

        // Start research
        gameState.activeResearch = techId;
        gameState.researchPoints = 0;
        updateResearchPointsDisplay();
        updateResearchUI(); // Update modal immediately
        updateResearchStatusDisplayOnly();
        showAlert("alertResearchStarted", 2500, true, [tech.nameKey]);
    }
    function handlePlaceBuilding(wX, wY) { const bU = gameState.units.find(u => u.id === gameState.selectedUnitId); const bId = gameState.selectedBuilding; if (!bU) { showAlert('alertSelectUnitToBuild', 3000, true); gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; } if (!bId) { gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; } const bC = gameConfig.buildings[bId]; const bldrC = gameConfig.units[bU.type]; const l = getLang(); if (!bC) { console.error(`Invalid building: ${bId}`); gameState.selectedBuilding = null; return; } if (!bldrC?.build?.includes(bId)) { showAlert('alertUnitCannotBuild', 3000, true, [bldrC.nameKey, bC.nameKey]); gameState.selectedBuilding = null; return; } const tD = getTileData(wX, wY); let cP = true; let fRK = ''; let fA = []; if (!tD) { cP = false; fRK = 'alertCannotBuildOnTerrain'; fA = [l.unknownTile]; } else if (tD.type === 'water') { cP = false; fRK = 'alertCannotBuildOnTerrain'; fA = [l.water]; } else if (tD.type === 'tree' || tD.type === 'stone' || tD.type === 'flint') { const rN = tD.type === 'tree' ? l.tileResourceTree : (tD.type === 'stone' ? l.tileResourceStone : l.tileResourceFlint); cP = false; fRK = 'alertCannotBuildOnResource'; fA = [rN]; } else if (tD.building) { cP = false; fRK = 'alertCannotBuildExists'; fA = [l[gameConfig.buildings[tD.building]?.nameKey] || tD.building]; } if (!cP) { showAlert(fRK || 'alertCannotBuildNonEmpty', 3000, true, fA); return; } if (!spendResources(bC.cost)) { showAlert('alertNotEnoughResources', 3000, true, [bC.nameKey]); return; } tD.building = bId; if (bId === 'house') { tD.unitDeployed = false; } setTileData(wX, wY, tD); showAlert('alertBuildingBuilt', 2500, true, [bC.nameKey]); bU.exp = (bU.exp || 0) + gameConfig.expPerBuild; logEvent('logGainedExp', [bldrC.nameKey, bU.id, gameConfig.expPerBuild, bC.nameKey]); if (bU.id === gameState.selectedUnitId) updateUnitInfoDisplay(); if (bC.provides?.capacityBonus) { updateInventoryCapacity(); } gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); updateBuildingsList(); updateUnitsPanel(); }
    function handleUpgradeClick(e) { const sU = gameState.units.find(u => u.id === gameState.selectedUnitId); if (!sU || e.target.disabled) return; const uId = e.target.dataset.upgradeType; const uC = gameConfig.upgrades[uId]; if (!uC) return; const cost = uC.cost; const cL = sU.upgrades?.[uId] || 0; if (cL >= uC.maxLevel) { showAlert('alertUpgradeMaxLevel', 3000, true, [uC.nameKey]); return; } if (sU.exp >= cost) { sU.exp -= cost; if (!sU.upgrades) sU.upgrades = {}; if (uC.effect.moveBonus) { sU.upgrades[uId] = (sU.upgrades[uId] || 0) + 1; } else if (uC.effect.autoGather) { sU.upgrades[uId] = true; } showAlert('alertUpgradeSuccess', 2500, true, [uC.nameKey, sU.id]); logEvent('alertUpgradeSuccess', [uC.nameKey, sU.id]); updateUnitInfoDisplay(); updateGrid(); } else { showAlert('alertNotEnoughExp', 3000, true, [uC.nameKey]); } }
    function deployUnitNearHouse(uT, hX, hY) { const uC = gameConfig.units[uT]; const l = getLang(); if (!uC) { console.error("Invalid unit type:", uT); gameState.unitToDeploy = null; gameState.highlightEnabled = false; updateGrid(); return; } const sD = findSpawnPoint(hX, hY); if (sD) { const nU = { id: `unit-${gameState.nextUnitId++}`, type: uT, worldX: sD.worldX, worldY: sD.worldY, exp: 0, upgrades: {} }; gameState.units.push(nU); const hTD = getTileData(hX, hY); if (hTD) { hTD.unitDeployed = true; setTileData(hX, hY, hTD); } else { console.error("House data missing at", hX, hY); } revealArea(nU.worldX, nU.worldY, uC?.revealRadius || gameConfig.revealRadiusBase); showAlert("alertUnitDeployed", 2000, true, [uC.nameKey]); } else { showAlert("alertNoSpaceForUnit", 3000, true, [uC.nameKey]); } gameState.unitToDeploy = null; gameState.highlightEnabled = false; updateGrid(); updateUnitDisplayBar(); updateUnitsPanel(); }
    function toggleMapRevealCheat() { if (!gameState.cheatMapRevealed) { const size = gameConfig.cheatRevealSize; console.log(`CHEAT: Revealing map area +/- ${size}`); for (let wy = -size; wy <= size; wy++) { for (let wx = -size; wx <= size; wx++) { const cS = `${wx},${wy}`; if (!getTileData(wx, wy)) { generateTileContent(wx, wy, true); } else { gameState.revealedTiles.add(cS); } gameState.revealedTiles.add(cS); } } gameState.cheatMapRevealed = true; logEvent('cheatMapRevealed'); showAlert('cheatMapRevealed', 1500, false); } else { console.log("CHEAT: Hiding map"); gameState.revealedTiles = new Set(gameState.naturallyRevealedTiles); gameState.cheatMapRevealed = false; logEvent('cheatMapHidden'); showAlert('cheatMapHidden', 1500, false); } updateGrid(); }
    function gatherSaveData() { const saveData = { version: gameConfig.saveVersion, gameState: { units: gameState.units, nextUnitId: gameState.nextUnitId, selectedUnitId: gameState.selectedUnitId, inventory: gameState.inventory, researchPoints: gameState.researchPoints, activeResearch: gameState.activeResearch, completedTech: Array.from(gameState.completedTech), productionProgress: gameState.productionProgress, colonyName: gameState.colonyName, currentLanguage: gameState.currentLanguage, viewOffsetX: gameState.viewOffsetX, viewOffsetY: gameState.viewOffsetY, worldData: gameState.worldData, revealedTiles: Array.from(gameState.revealedTiles), naturallyRevealedTiles: Array.from(gameState.naturallyRevealedTiles), cheatMapRevealed: gameState.cheatMapRevealed, eventLogs: gameState.eventLogs.map(log => ({ time: log.time, messageKey: log.messageKey, args: log.args || [] })), } }; return saveData; }
    function saveGame() { try { const sD = gatherSaveData(); const sDJ = JSON.stringify(sD, null, 2); const b = new Blob([sDJ], { type: 'application/json' }); const u = URL.createObjectURL(b); const l = document.createElement('a'); l.href = u; const sCN = gameState.colonyName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'colony'; l.download = `civsim_${sCN}_save_v${sD.version}.json`; document.body.appendChild(l); l.click(); document.body.removeChild(l); URL.revokeObjectURL(u); showAlert('alertGameSaved', 2000); logEvent('logGameSaved'); } catch (e) { console.error("Save error:", e); showAlert('alertSaveError', 4000); } }
    function applyLoadedData(data) { const requiredMinVersion = 1.3; if (!data || !data.gameState) { showAlert('alertLoadInvalidFormat', 5000, true); return false; } const loadedVersion = parseFloat(data.version) || 0; if (loadedVersion < requiredMinVersion) { showAlert('alertSaveVersionMismatch', 6000, true); console.warn(`Loading v${loadedVersion}, current is ${gameConfig.saveVersion}.`); } const loadedState = data.gameState; gameState.units = loadedState.units || []; gameState.nextUnitId = loadedState.nextUnitId || 0; gameState.selectedUnitId = loadedState.selectedUnitId !== undefined && gameState.units.find(u => u.id === loadedState.selectedUnitId) ? loadedState.selectedUnitId : (gameState.units.length > 0 ? gameState.units[0].id : null); gameState.inventory = loadedState.inventory || {}; gameState.researchPoints = loadedState.researchPoints || 0; gameState.activeResearch = loadedState.activeResearch || null; gameState.completedTech = new Set(loadedState.completedTech || []); gameState.productionProgress = loadedState.productionProgress || { wheat: 0, coal: 0, quarry: 0 }; gameState.colonyName = loadedState.colonyName || "Loaded Colony"; gameState.currentLanguage = loadedState.currentLanguage || 'en'; gameState.viewOffsetX = loadedState.viewOffsetX || 0; gameState.viewOffsetY = loadedState.viewOffsetY || 0; gameState.worldData = loadedState.worldData || {}; gameState.revealedTiles = new Set(loadedState.revealedTiles || []); gameState.naturallyRevealedTiles = new Set(loadedState.naturallyRevealedTiles || loadedState.revealedTiles || []); gameState.cheatMapRevealed = loadedState.cheatMapRevealed || false; gameState.eventLogs = (loadedState.eventLogs || []).map(logData => ({ time: logData.time, messageKey: logData.messageKey, args: logData.args || [], rendered: getLangMsg(logData.messageKey, logData.args || []) })); gameState.units.forEach(u => { if (u.exp === undefined) u.exp = 0; if (u.upgrades === undefined) u.upgrades = {}; }); Object.values(gameState.worldData).forEach(r => { if(r) { Object.values(r).forEach(t => { if (t && t.building === 'house' && t.unitDeployed === undefined) { t.unitDeployed = false; } }); } }); gameState.selectedBuilding = null; gameState.unitToDeploy = null; gameState.highlightEnabled = false; updateInventoryCapacity(); updateLanguageUI(); hideAllPanels(); updateInventoryDisplay(); updateResearchPointsDisplay(); updateUnitDisplayBar(); updateGrid(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); updateResearchStatusDisplayOnly(); if (gameState.selectedUnitId) { focusOnUnit(gameState.selectedUnitId); } else { updateGrid(); } showAlert('alertLoadSuccess', 3000, false, [gameState.colonyName]); gameState.gameInitialized = true; return true; }
    function loadGame(e) { const f = e.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = function(ev) { try { const lD = JSON.parse(ev.target.result); applyLoadedData(lD); } catch (err) { console.error("Load error:", err); showAlert('alertLoadError', 5000, true, [err.message]); } finally { DOMElements.loadFileInput.value = null; } }; r.onerror = function() { showAlert('alertReadFileError', 3000); DOMElements.loadFileInput.value = null; }; r.readAsText(f); }
    function updateLanguageUI() { const lang = getLang(); document.title = lang.gameTitle; document.querySelector('h1').textContent = lang.gameTitle; DOMElements.languageSwitchButton.textContent = (gameState.currentLanguage === 'en') ? lang.switchToFrench : lang.switchToEnglish; DOMElements.languageSwitchButton.title = lang.switchLanguageTooltip; DOMElements.colonyNameDisplay.textContent = `${lang.colonyLabel} ${gameState.colonyName}`; DOMElements.inventoryDisplay.querySelector('h2').textContent = lang.inventoryTitle; DOMElements.actionButton.textContent = lang.gatherButton; document.getElementById('tutorial-button').textContent = lang.tutorialButton; document.getElementById('research-button').textContent = lang.researchButton; document.getElementById('buildings-button').textContent = lang.buildingsButton; document.getElementById('units-button').textContent = lang.unitsButton; document.getElementById('upgrade-button').textContent = lang.upgradeButton; document.getElementById('logs-button').textContent = lang.logsButton; DOMElements.saveButton.textContent = lang.saveButton; DOMElements.loadButton.textContent = lang.loadButton; DOMElements.cheatRevealButton.textContent = lang.cheatRevealMap; DOMElements.logsPanel.querySelector('h2').textContent = lang.logsPanelTitle; DOMElements.logSearchInput.placeholder = lang.logSearchPlaceholder; const filterLabel = DOMElements.logFilterCheckbox.parentElement; if (filterLabel) filterLabel.childNodes[1].nodeValue = ` ${lang.logFilterLabel}`; document.getElementById('research-points-display-container').childNodes[0].nodeValue = `${lang.researchPointsLabel} `; document.getElementById('unit-exp-display-container').childNodes[0].nodeValue = `${lang.unitExpLabel} `; const buildTitle = DOMElements.buildingsList.querySelector('h2'); if (buildTitle) buildTitle.textContent = lang.buildingsPanelTitle; const unitsTitle = DOMElements.unitsPanel.querySelector('h2'); if (unitsTitle) unitsTitle.textContent = lang.unitsPanelTitle; const upgradeTitleH4 = DOMElements.upgradeInfoDisplay.querySelector('h4'); if (upgradeTitleH4) upgradeTitleH4.textContent = lang.upgradeSectionTitle; DOMElements.tutorialTitle.textContent = lang.tutorialTitle; DOMElements.tutorialStepsList.innerHTML = `<li>${lang.tutorialStep1}</li> <li>${lang.tutorialStep2}</li><li>${lang.tutorialStep3}</li> <li>${lang.tutorialStep4}</li><li>${lang.tutorialStep5}</li> <li>${lang.tutorialStep6}</li><li>${lang.tutorialStep7}</li> <li>${lang.tutorialStep8}</li><li>${lang.tutorialStep9}</li> <li>${lang.tutorialStep10}</li><li>${lang.tutorialStep11}</li><li>${lang.tutorialStep12}</li><li>${lang.tutorialStep13}</li><li>${lang.tutorialStep14}</li><li>${lang.tutorialStep15}</li><li>${lang.tutorialStep16}</li>`; DOMElements.closeTutorialButton.textContent = lang.closeButton; DOMElements.techTreeTitle.textContent = lang.researchPanelTitle; DOMElements.closeTechTreeButton.textContent = lang.closeButton; DOMElements.techTreeLegend.querySelectorAll('[data-lang-key]').forEach(s => { const k = s.dataset.langKey; s.textContent = lang[k] || k; }); if (DOMElements.techTreeModal.style.display === 'block') { DOMElements.techTreeDisplayArea.querySelectorAll('.tech-unlocks span').forEach(s => { s.textContent = `${lang.unlocksLabel} `; }); } updateInventoryDisplay(); updateGrid(); updateUnitDisplayBar(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); updateLogsDisplay(); checkResource(); updateResearchStatusDisplayOnly(); if (DOMElements.techTreeModal.style.display === 'block') { updateResearchUI(); } }
    function switchLanguage() { gameState.currentLanguage = (gameState.currentLanguage === 'en') ? 'fr' : 'en'; gameState.eventLogs.forEach(log => { log.rendered = getLangMsg(log.messageKey, log.args || []); }); updateLanguageUI(); }
    function initializeGame() { const seed = Date.now(); noise.biome = SimplexNoise.create(seed); noise.feature = SimplexNoise.create(seed + 1); noise.water = SimplexNoise.create(seed + 2); gameState.units = []; gameState.nextUnitId = 0; gameState.selectedUnitId = null; gameState.inventory = {}; gameState.inventoryCapacity = {}; gameState.researchPoints = 0; gameState.activeResearch = null; gameState.completedTech = new Set(); gameState.selectedBuilding = null; gameState.unitToDeploy = null; gameState.productionProgress = { wheat: 0, coal: 0, quarry: 0 }; gameState.eventLogs = []; gameState.worldData = {}; gameState.revealedTiles = new Set(); gameState.naturallyRevealedTiles = new Set(); gameState.cheatMapRevealed = false; gameState.highlightEnabled = false; clearTimeout(gameState.alertTimeout); gameState.gameInitialized = false; gameState.colonyName = ""; gameConfig.resources.forEach(res => { gameState.inventory[res.id] = 0; }); gameState.currentLanguage = gameState.currentLanguage || 'en'; const lang = getLang(); gameState.colonyName = prompt(lang.promptColonyName, lang.defaultColonyName) || lang.defaultColonyName; logEvent('logNewGame', [gameState.colonyName]); const startWorldX = 5, startWorldY = 5; let startValid = false; let attemptCount = 0; do { attemptCount++; if (attemptCount > 1) { logEvent('logInvalidStartRegen'); const newSeed = Date.now() + attemptCount; noise.biome = SimplexNoise.create(newSeed); noise.feature = SimplexNoise.create(newSeed + 1); noise.water = SimplexNoise.create(newSeed + 2); gameState.worldData = {}; gameState.revealedTiles.clear(); gameState.naturallyRevealedTiles.clear(); } revealArea(startWorldX, startWorldY, 1); const startData = getTileData(startWorldX, startWorldY); if (startData && startData.type !== 'water') { let hasAdjLand = false; for (let dy=-1; dy<=1; dy++) { for (let dx=-1; dx<=1; dx++) { if(dx===0 && dy===0) continue; const adj = getTileData(startWorldX+dx,startWorldY+dy); if(adj && adj.type !== 'water') { hasAdjLand=true; break; } } if(hasAdjLand) break; } if(hasAdjLand) startValid=true; } if (!startValid && attemptCount >= gameConfig.maxStartRegenAttempts) { logEvent('logInvalidStartGiveUp', [attemptCount]); startValid=true; } } while (!startValid); gameState.units.push({ id: `unit-${gameState.nextUnitId++}`, type: 'pawn', worldX: startWorldX, worldY: startWorldY, exp: 0, upgrades: {} }); gameState.selectedUnitId = gameState.units[0].id; gameState.viewOffsetX = startWorldX - gameConfig.viewCenterOffset; gameState.viewOffsetY = startWorldY - gameConfig.viewCenterOffset; revealArea(startWorldX, startWorldY, gameConfig.units.pawn.revealRadius); initializeGridDOM(); setupEventListeners(); hideAllPanels(); updateLanguageUI(); updateInventoryCapacity(); updateUnitDisplayBar(); updateResearchPointsDisplay(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay(); updateResearchStatusDisplayOnly(); focusOnUnit(gameState.selectedUnitId); showAlert('alertWelcome', 4000, false, [gameState.colonyName]); gameState.gameInitialized = true; }

    // --- Start Game ---
    document.addEventListener('DOMContentLoaded', initializeGame);

  </script>
</body>
</html>
