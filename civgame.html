<head>
    <title>Tiny Civilization - Biomes</title> <!-- Updated Title -->
    <meta charset="UTF-8">
    <!-- Simple Perlin Noise Library (credit: Joseph Gentle) -->
    <script>
        /* Joseph Gentle's perlin noise implementation in javascript.
         * You can find more information about it here:
         * http://josephg.com/blog/javascript-perlin-noise/
         */
        var perlin = {
            rand_vect: function(){
                let theta = Math.random() * 2 * Math.PI;
                return {x: Math.cos(theta), y: Math.sin(theta)};
            },
            dot_prod_grid: function(x, y, vx, vy){
                let g_vect;
                let d_vect = {x: x - vx, y: y - vy};
                if (this.gradients[[vx,vy]]){
                    g_vect = this.gradients[[vx,vy]];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[[vx, vy]] = g_vect;
                }
                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            },
            smootherstep: function(x){
                return 6*x**5 - 15*x**4 + 10*x**3;
            },
            interp: function(x, a, b){
                return a + this.smootherstep(x) * (b-a);
            },
            seed: function(seedValue){
                // Simple seeding using the provided value
                // Note: This is a basic seed implementation. For true reproducibility
                // across different JS environments, a more robust PRNG might be needed.
                 let random = function() {
                    var x = Math.sin(seedValue++) * 10000;
                    return x - Math.floor(x);
                };
                // We need to override Math.random temporarily for seeding gradients,
                // but this is tricky globally. Instead, we'll use the seeded PRNG
                // directly when creating gradients if a seed is active.
                this.seededRandom = random; // Store the seeded function
                this.gradients = {}; // Reset gradients when seed changes
            },
            get: function(x, y) {
                // If seededRandom exists, use it, otherwise use Math.random
                const _randomFunc = this.seededRandom || Math.random;
                // Need to update rand_vect to use the potentially seeded random function
                // This requires modifying the library slightly or passing the function
                // For simplicity here, we'll redefine rand_vect inside get if seeded
                 this.rand_vect_seeded = function(){
                    let theta = _randomFunc() * 2 * Math.PI;
                    return {x: Math.cos(theta), y: Math.sin(theta)};
                 };

                 // Redefine gradient generation to use the correct random source
                 this.getGradient = function(vx, vy) {
                    if (this.gradients[[vx,vy]]){
                        return this.gradients[[vx,vy]];
                    } else {
                        const g_vect = this.rand_vect_seeded(); // Use potentially seeded version
                        this.gradients[[vx, vy]] = g_vect;
                        return g_vect;
                    }
                 };

                let xf = Math.floor(x);
                let yf = Math.floor(y);
                //interpolate
                let tl = this.dot_prod_grid(x, y, xf,   yf);
                let tr = this.dot_prod_grid(x, y, xf+1, yf);
                let bl = this.dot_prod_grid(x, y, xf,   yf+1);
                let br = this.dot_prod_grid(x, y, xf+1, yf+1);
                let xt = this.interp(x-xf, tl, tr);
                let xb = this.interp(x-xf, bl, br);
                let v = this.interp(y-yf, xt, xb);
                return v;
            }
        }
    </script>
    <style>
      /* ... Your existing styles ... */

      /* Biome Backgrounds (Applied to empty tiles) */
      .tile.biome-forest { background-color: #dcedc8; } /* Light green */
      .tile.biome-jungle { background-color: #a5d6a7; } /* Deeper green */
      .tile.biome-desert { background-color: #fff9c4; } /* Pale yellow */

      /* Adjust Resource/Building Backgrounds to potentially allow biome tint */
      /* Example: make resource backgrounds slightly transparent */
      .tile.tree { background-color: rgba(46, 204, 113, 0.9); /* Slightly transparent default */ }
      .tile.stone { background-color: rgba(149, 165, 166, 0.9); }
      .tile.flint { background-color: rgba(127, 140, 141, 0.9); }
      .tile.house { background-color: rgba(142, 68, 173, 0.9); }
      .tile.farm { background-color: rgba(241, 196, 15, 0.9); }
      .tile.mine { background-color: rgba(96, 125, 139, 0.9); }

      /* Ensure unknown is still opaque */
       .tile.unknown { background-color: #90a4ae; opacity: 1; filter: none; }

    </style>
</head>
<body>
    <!-- ... Your existing HTML body ... -->
    <script>
        // --- DOM Element References ---
        // ... (no changes) ...
        const grid = document.getElementById('grid'); const actionButton = document.getElementById('action-button');
        const woodCountDisplay = document.getElementById('wood-count'); const pebbleCountDisplay = document.getElementById('pebble-count'); const flintCountDisplay = document.getElementById('flint-count'); const wheatCountDisplay = document.getElementById('wheat-count'); const coalCountDisplay = document.getElementById('coal-count');
        const inventoryDisplay = document.getElementById('inventory'); const researchButton = document.getElementById('research-button'); const buildingsButton = document.getElementById('buildings-button'); const unitsButton = document.getElementById('units-button'); const logsButton = document.getElementById('logs-button');
        const techTree = document.getElementById('tech-tree'); const buildingsList = document.getElementById('buildings-list'); const unitsPanel = document.getElementById('units-panel'); const unitsList = document.getElementById('units-list'); const logsPanel = document.getElementById('logs-panel'); const logsList = document.getElementById('logs-list');
        const logSearchInput = document.getElementById('log-search-input'); const logFilterCheckbox = document.getElementById('log-filter-checkbox'); const resourceNameDisplay = document.getElementById('resource-name');
        const researchPointsDisplay = document.getElementById('research-points'); const researchStatusDisplay = document.getElementById('research-status-display'); const colonyNameDisplay = document.getElementById('colony-name-display');
        const alertMessageElement = document.getElementById('alert-message'); const unitDisplayBar = document.getElementById('unit-display-bar');
        const unitCoordsDisplay = document.getElementById('unit-coords');
        const settlementResearchBtn = document.getElementById('settlement-research'); const settlementResearchProgress = document.getElementById('settlement-research-progress'); const settlementResearchProgressBar = document.getElementById('settlement-research-bar'); const settlementResearchPercent = document.getElementById('settlement-research-percent');
        const agricultureResearchBtn = document.getElementById('agriculture-research'); const agricultureResearchProgress = document.getElementById('agriculture-research-progress'); const agricultureResearchProgressBar = document.getElementById('agriculture-research-bar'); const agricultureResearchPercent = document.getElementById('agriculture-research-percent');
        const miningResearchBtn = document.getElementById('mining-research'); const miningResearchProgress = document.getElementById('mining-research-progress'); const miningResearchProgressBar = document.getElementById('mining-research-bar'); const miningResearchPercent = document.getElementById('mining-research-percent');
        const deployWorkerButton = document.getElementById('deploy-worker-button');
        const saveButton = document.getElementById('save-button');
        const loadButton = document.getElementById('load-button');
        const loadFileInput = document.getElementById('load-file-input');
        const languageSwitchButton = document.getElementById('language-switch-button');

        // --- Game State Variables ---
        const gridSize = 10; let units = []; let nextUnitId = 0; let selectedUnitId = null;
        let inventory = { wood: 0, pebble: 0, flint: 0, wheat: 0, coal: 0 };
        let researchPoints = 0; let activeResearch = null;
        let settlementCompleted = false; let agricultureCompleted = false; let miningCompleted = false;
        let maxWorkers = 0; let selectedBuilding = null; let moveCount = 0; let movesSinceLastCoal = 0;
        let viewOffsetX = 0; let viewOffsetY = 0; let worldData = {};
        let revealedTiles = new Set();
        let worldSeed = Date.now(); // Generate a seed for this game session
        let colonyName = "New Colony"; let highlightEnabled = false; let alertTimeout; let eventLogs = []; const maxLogEntries = 50; let currentLanguage = 'en';

        // --- Game Constants ---
        const settlementResearchCost = 15; const agricultureResearchCost = 10; const miningResearchCost = 15;
        const houseCost = { wood: 10, pebble: 5 }; const farmCost = { wood: 3 }; const mineCost = { pebble: 5, wood: 2 };
        const wheatProductionInterval = 5; const coalProductionInterval = 7;
        const unitCapabilities = { pawn: { canBuild: ['house'] }, worker: { canBuild: ['farm', 'mine'] } };
        const REVEAL_RADIUS = 2;
        const VIEW_CENTER_OFFSET = Math.floor(gridSize / 2);
        const PERLIN_FREQUENCY = 0.05; // Lower value = larger biomes

        // --- Translations ---
        // ... (Translation object - needs biome names) ...
        const translations = {
            en: { /* ..., */ biomeForest: "Forest", biomeDesert: "Desert", biomeJungle: "Jungle" },
            fr: { /* ..., */ biomeForest: "Forêt", biomeDesert: "Désert", biomeJungle: "Jungle" },
            // Make sure to add these to your existing translations object!
             // General UI
            gameTitle: "Tiny Civilization", switchLanguageTooltip: "Switch Language / Changer de langue", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colony:",
            // Panels & Buttons
            inventoryTitle: "Inventory", researchButton: "Research", buildingsButton: "Buildings", unitsButton: "Units", logsButton: "Logs", saveButton: "Save Game", loadButton: "Load Game",
            // Inventory Items (also used as keys for costs/alerts)
            wood: "Wood", pebble: "Pebbles", flint: "Flint", wheat: "Wheat", coal: "Coal",
            // Grid Area
            gatherButton: "Gather Resource", noUnitSelected: "No unit selected", onTile: "On Tile:", emptyTile: "Empty", unknownTile: "Unknown", tileResourceTree: "Tree (Wood)", tileResourceStone: "Stone (Pebbles)", tileResourceFlint: "Flint",
            // Biomes
            biomeForest: "Forest", biomeDesert: "Desert", biomeJungle: "Jungle",
            // Research Panel
            researchPointsLabel: "Research Points:", researchPanelTitle: "Tech Tree", primitiveAge: "Primitive Age", researchSettlement: "Settlement", researchSettlementDesc: "Unlocks Houses.", researchAgriculture: "Agriculture", researchAgricultureDesc: "Unlocks Farms.", researchMining: "Mining", researchMiningDesc: "Unlocks Mines (requires Agriculture).", researchStatusResearching: "⏳ Researching", researchStatusComplete: "✅", researchStatusCompleteSettlement: "Settlement Complete! Houses unlocked.", researchStatusCompleteAgriculture: "Agriculture Complete! Farms unlocked.", researchStatusCompleteMining: "Mining Complete! Mines unlocked.", researchStatusInitial: "Begin your journey! Select units via the top bar and move them on the grid.",
            // Buildings Panel (Keys: buildingHouse, buildingFarm, buildingMine)
            buildingsPanelTitle: "Buildings", buildingHouse: "House", buildingFarm: "Farm", buildingMine: "Mine", buildingHouseDesc: "Increases Worker capacity by 1.", buildingFarmDesc: "Requires Worker. Produces Wheat over time.", buildingMineDesc: "Requires Worker. Produces Coal over time.", noBuildingsAvailable: "No buildings available to build yet. Research technology first.",
            // Units Panel (Keys: unitPawn, unitWorker)
            unitsPanelTitle: "Available Units", deployWorkerButton: "Deploy Worker", deployWorkerRequiresHouse: "Deploy Worker (Requires House)", deployWorkerMax: "Max", unitPawn: "Pawn", unitWorker: "Worker",
            // Logs Panel
            logsPanelTitle: "Event Logs", logSearchPlaceholder: "Search logs...", logFilterLabel: "Hide gather/cost messages",
            // Alerts & Prompts (Keys for alerts)
            alertWelcome: "Welcome to {0}!", alertGameStarted: "Game started for colony: {0}", alertGathered: "Gathered 1 {0}!", alertNotEnoughResources: "Not enough resources for {0}!", alertCannotBuildEmpty: "Cannot build: Tile is not empty!", alertCannotBuildNonEmpty: "Cannot build: Tile is not empty!", alertCannotBuildExists: "Cannot build: {0} already exists here!", alertCannotBuildOnResource: "Cannot build on a {0}!", alertBuildSelected: "Selected: {0}. Click an empty tile to build.", alertBuildingBuilt: "{0} built!", alertSelectUnitToBuild: "No unit selected to perform build action.", alertUnitCannotBuild: "{0} cannot build {1}s!", alertResearchStarted: "Started researching {0}.", alertAlreadyResearching: "Already researching: {0}!", alertWorkerDeployed: "Worker deployed!", alertMaxWorkers: "Maximum Worker capacity reached. Build more Houses.", alertNoSpaceForWorker: "No available space near any House to deploy Worker!", alertGameSaved: "Game Saved!", alertSaveError: "Error saving game. See console for details.", alertLoadSuccess: "Game loaded successfully for colony: {0}!", alertLoadError: "Error loading game: {0}.", alertLoadInvalidFormat: "Invalid save file format.", alertReadFileError: "Error reading file.", alertUnitMoveOccupied: "Cannot move unit: Tile is occupied!", alertMoveInvalid: "Cannot move there.", alertSelectedUnit: "Selected Unit: {0} ({1})", promptColonyName: "Welcome to Tiny Civilization! Please name your colony:", defaultColonyName: "New Colony", logGameSaved: "Game state saved to file.", logNewGame: "New game started for colony:"
        };
         translations.fr = { gameTitle: "Mini Civilisation", switchLanguageTooltip: "Changer de langue / Switch Language", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colonie :", inventoryTitle: "Inventaire", researchButton: "Recherche", buildingsButton: "Bâtiments", unitsButton: "Unités", logsButton: "Journaux", saveButton: "Sauvegarder", loadButton: "Charger", wood: "Bois", pebble: "Cailloux", flint: "Silex", wheat: "Blé", coal: "Charbon", gatherButton: "Récolter Ressource", noUnitSelected: "Aucune unité sélectionnée", onTile: "Sur la case :", emptyTile: "Vide", unknownTile: "Inconnu", tileResourceTree: "Arbre (Bois)", tileResourceStone: "Roche (Cailloux)", tileResourceFlint: "Silex", biomeForest: "Forêt", biomeDesert: "Désert", biomeJungle: "Jungle", researchPointsLabel: "Points de Recherche :", researchPanelTitle: "Arbre Technologique", primitiveAge: "Âge Primitif", researchSettlement: "Colonisation", researchSettlementDesc: "Débloque les Maisons.", researchAgriculture: "Agriculture", researchAgricultureDesc: "Débloque les Fermes.", researchMining: "Minage", researchMiningDesc: "Débloque les Mines (nécessite Agriculture).", researchStatusResearching: "⏳ Recherche en cours", researchStatusComplete: "✅", researchStatusCompleteSettlement: "Colonisation terminée ! Maisons débloquées.", researchStatusCompleteAgriculture: "Agriculture terminée ! Fermes débloquées.", researchStatusCompleteMining: "Minage terminé ! Mines débloquées.", researchStatusInitial: "Commencez votre voyage ! Sélectionnez les unités via la barre supérieure et déplacez-les sur la grille.", buildingsPanelTitle: "Bâtiments", buildingHouse: "Maison", buildingFarm: "Ferme", buildingMine: "Mine", buildingHouseDesc: "Augmente la capacité d'Ouvriers de 1.", buildingFarmDesc: "Nécessite Ouvrier. Produit du Blé périodiquement.", buildingMineDesc: "Nécessite Ouvrier. Produit du Charbon périodiquement.", noBuildingsAvailable: "Aucun bâtiment à construire pour le moment. Recherchez d'abord une technologie.", unitsPanelTitle: "Unités Disponibles", deployWorkerButton: "Déployer Ouvrier", deployWorkerRequiresHouse: "Déployer Ouvrier (Maison requise)", deployWorkerMax: "Max", unitPawn: "Colon", unitWorker: "Ouvrier", logsPanelTitle: "Journal des Événements", logSearchPlaceholder: "Rechercher dans les journaux...", logFilterLabel: "Masquer messages récolte/coût", alertWelcome: "Bienvenue à {0} !", alertGameStarted: "Partie démarrée pour la colonie : {0}", alertGathered: "Récolté 1 {0} !", alertNotEnoughResources: "Pas assez de ressources pour {0} !", alertCannotBuildEmpty: "Construction impossible : La case n'est pas vide !", alertCannotBuildNonEmpty: "Construction impossible : La case n'est pas vide !", alertCannotBuildExists: "Construction impossible : {0} existe déjà ici !", alertCannotBuildOnResource: "Construction impossible sur un(e) {0} !", alertBuildSelected: "Sélectionné : {0}. Cliquez une case vide pour construire.", alertBuildingBuilt: "{0} construit(e) !", alertSelectUnitToBuild: "Aucune unité sélectionnée pour construire.", alertUnitCannotBuild: "{0} ne peut pas construire de {1}s !", alertResearchStarted: "Recherche commencée pour {0}.", alertAlreadyResearching: "Recherche déjà en cours : {0} !", alertWorkerDeployed: "Ouvrier déployé !", alertMaxWorkers: "Capacité maximale d'Ouvriers atteinte. Construisez plus de Maisons.", alertNoSpaceForWorker: "Aucun espace disponible près d'une Maison pour déployer l'Ouvrier !", alertGameSaved: "Partie Sauvegardée !", alertSaveError: "Erreur lors de la sauvegarde. Voir la console pour détails.", alertLoadSuccess: "Partie chargée avec succès pour la colonie : {0} !", alertLoadError: "Erreur lors du chargement : {0}.", alertLoadInvalidFormat: "Format de sauvegarde invalide.", alertReadFileError: "Erreur de lecture du fichier.", alertUnitMoveOccupied: "Déplacement impossible : Case occupée !", alertMoveInvalid: "Déplacement impossible.", alertSelectedUnit: "Unité sélectionnée : {0} ({1})", promptColonyName: "Bienvenue dans Mini Civilisation ! Veuillez nommer votre colonie :", defaultColonyName: "Nouvelle Colonie", logGameSaved: "État de la partie sauvegardé dans un fichier.", logNewGame: "Nouvelle partie démarrée pour la colonie :" };


    // --- Helper Function for Time Formatting ---
    function getFormattedTime() { const now = new Date(); const hours = now.getHours().toString().padStart(2, '0'); const minutes = now.getMinutes().toString().padStart(2, '0'); return `${hours}:${minutes}`; }

    // --- Alert & Logging Function ---
    function showAlert(messageKey, duration = 3000, logMessage = true, args = []) { /* ... */ clearTimeout(alertTimeout); const lang = translations[currentLanguage]; let message = lang[messageKey] || messageKey; if (args && args.length > 0) { args.forEach((arg, index) => { const translatedArg = lang[arg] || arg; message = message.replace(`{${index}}`, translatedArg); }); } if (logMessage) { const timeString = getFormattedTime(); eventLogs.push({ time: timeString, messageKey: messageKey, args: args, rendered: message }); if (eventLogs.length > maxLogEntries) { eventLogs.shift(); } if (logsPanel.style.display === 'block') { updateLogsDisplay(); } } alertMessageElement.textContent = message; alertMessageElement.style.display = 'block'; requestAnimationFrame(() => { requestAnimationFrame(() => { alertMessageElement.classList.add('show'); }); }); alertTimeout = setTimeout(() => { alertMessageElement.classList.remove('show'); alertMessageElement.addEventListener('transitionend', function handleTransitionEnd() { if (!alertMessageElement.classList.contains('show')) { alertMessageElement.style.display = 'none'; } }, { once: true }); }, duration); }
    function updateLogsDisplay() { /* ... */ logsList.innerHTML = ''; const searchTerm = logSearchInput.value.toLowerCase(); const hideFilteredMessages = logFilterCheckbox.checked; const lang = translations[currentLanguage]; const filteredLogs = eventLogs.filter(log => { let messageToSearch = log.rendered || log.message; if(log.messageKey && !log.rendered) { messageToSearch = lang[log.messageKey] || log.messageKey; if (log.args && log.args.length > 0) { log.args.forEach((arg, index) => { const translatedArg = lang[arg] || arg; messageToSearch = messageToSearch.replace(`{${index}}`, translatedArg); }); } log.rendered = messageToSearch; } const messageLower = messageToSearch.toLowerCase(); const searchMatch = messageLower.includes(searchTerm); if (!searchMatch) return false; if (hideFilteredMessages) { const isGather = log.messageKey === 'alertGathered'; const isCost = log.messageKey === 'alertNotEnoughResources'; if (isGather || isCost) { return false; } } return true; }); for (let i = filteredLogs.length - 1; i >= 0; i--) { const log = filteredLogs[i]; const logEntry = document.createElement('li'); const timeSpan = document.createElement('span'); timeSpan.className = 'log-time'; timeSpan.textContent = `[${log.time}]`; const messageText = document.createTextNode(` ${log.rendered || log.message}`); logEntry.appendChild(timeSpan); logEntry.appendChild(messageText); logsList.appendChild(logEntry); } }

    // --- Initialization Functions ---
    function initializeGridDOM() { /* ... */ grid.innerHTML = ''; for (let gy = 0; gy < gridSize; gy++) { for (let gx = 0; gx < gridSize; gx++) { const tile = document.createElement('div'); tile.classList.add('tile'); tile.dataset.gridX = gx; tile.dataset.gridY = gy; grid.appendChild(tile); } } }

    // --- World Generation & Visibility ---
    function getTileData(worldX, worldY) { return worldData[worldY]?.[worldX]; }
    function setTileData(worldX, worldY, data) { if (!worldData[worldY]) { worldData[worldY] = {}; } worldData[worldY][worldX] = data; }

    function generateTileContent(worldX, worldY) { // <<< MODIFIED for Biomes
        const coordString = `${worldX},${worldY}`;
        if (revealedTiles.has(coordString)) {
            return getTileData(worldX, worldY); // Already generated
        }
        revealedTiles.add(coordString);

        // --- Biome Determination ---
        let biome = 'forest'; // Default
        // Use seeded Perlin noise
        const noiseValue = perlin.get(worldX * PERLIN_FREQUENCY, worldY * PERLIN_FREQUENCY);
        if (noiseValue < -0.1) { // Adjust threshold as needed
            biome = 'desert';
        } else if (noiseValue > 0.25) { // Adjust threshold
            biome = 'jungle';
        } else {
            biome = 'forest';
        }

         // --- Force Start Biome ---
         // Slightly larger override for a smoother start
         const startX = 5, startY = 5; // Make these constants?
         if (Math.abs(worldX - startX) <= 1 && Math.abs(worldY - startY) <= 1) {
             biome = 'forest';
         }


        // --- Resource Generation based on Biome ---
        let type = 'empty';
        const rand = Math.random(); // Use standard random for resource placement within biome

        if (biome === 'forest') {
            if (rand < 0.15) { type = 'tree'; } // High chance
            else if (rand < 0.22) { type = 'stone'; }
            else if (rand < 0.25) { type = 'flint'; }
        } else if (biome === 'desert') {
            if (rand < 0.01) { type = 'tree'; } // Very low chance
            else if (rand < 0.15) { type = 'stone'; } // High chance
            else if (rand < 0.25) { type = 'flint'; } // Medium chance
        } else if (biome === 'jungle') {
             if (rand < 0.25) { type = 'tree'; } // Very high chance
             else if (rand < 0.28) { type = 'stone'; } // Low chance
             else if (rand < 0.30) { type = 'flint'; } // Low chance
        }

        const data = { type: type, building: null, biome: biome }; // Store biome
        setTileData(worldX, worldY, data);
        return data;
    }

    function revealArea(centerX, centerY, radius) { /* ... */ let newlyRevealed = false; for (let dy = -radius; dy <= radius; dy++) { for (let dx = -radius; dx <= radius; dx++) { const wx = centerX + dx; const wy = centerY + dy; const coordString = `${wx},${wy}`; if (!revealedTiles.has(coordString)) { generateTileContent(wx, wy); newlyRevealed = true; } } } return newlyRevealed; }
    // REMOVED calculateVisibility function

    // --- Update Functions ---
    function updateGrid() { // <<< SIMPLIFIED (Removed visibility logic)
        const tiles = grid.querySelectorAll('.tile');
        const lang = translations[currentLanguage];

        tiles.forEach(tile => {
            const gx = parseInt(tile.dataset.gridX); const gy = parseInt(tile.dataset.gridY);
            const worldX = gx + viewOffsetX; const worldY = gy + viewOffsetY;
            const coordString = `${worldX},${worldY}`;
            const isRevealed = revealedTiles.has(coordString);

            const existingMarker = tile.querySelector('.unit-marker');
            if (existingMarker) existingMarker.remove();
            tile.className = 'tile'; // Reset classes first
            tile.textContent = '';
            tile.classList.remove('highlight', 'unknown');
            // Remove old biome classes before adding new one
            tile.classList.remove('biome-forest', 'biome-desert', 'biome-jungle');

            if (!isRevealed) {
                tile.classList.add('unknown');
                tile.title = lang.unknownTile;
            } else { // Tile is revealed - show normally
                const data = getTileData(worldX, worldY); let tileTitle = lang.emptyTile;
                if (data) {
                    // Add biome class first for background
                    if (data.biome) {
                        tile.classList.add(`biome-${data.biome}`);
                    }
                    // Add type/building class (will override biome background visually if not transparent)
                    tile.classList.add(data.type);
                    if (data.building) {
                        tile.classList.add(data.building); tile.textContent = data.building.substring(0, 4).toUpperCase();
                        tileTitle = lang[`building${data.building.charAt(0).toUpperCase() + data.building.slice(1)}`] || data.building;
                    } else if (data.type !== 'empty') {
                         let resourceKey = '';
                         if (data.type === 'tree') resourceKey = 'tileResourceTree'; else if (data.type === 'stone') resourceKey = 'tileResourceStone'; else if (data.type === 'flint') resourceKey = 'tileResourceFlint';
                         tileTitle = lang[resourceKey] || data.type;
                    }
                    // Append biome name to tooltip for revealed tiles
                    const biomeName = lang[`biome${data.biome.charAt(0).toUpperCase() + data.biome.slice(1)}`] || data.biome;
                    tileTitle += ` (${biomeName})`;

                } else { tile.classList.add('empty'); tileTitle = lang.emptyTile; }
                 tile.title = tileTitle;
            }
        });

        // Place unit markers on revealed tiles
        units.forEach(unit => {
            const unitGridX = unit.worldX - viewOffsetX; const unitGridY = unit.worldY - viewOffsetY;
            if (unitGridX >= 0 && unitGridX < gridSize && unitGridY >= 0 && unitGridY < gridSize) {
                const tile = grid.querySelector(`.tile[data-grid-x="${unitGridX}"][data-grid-y="${unitGridY}"]`);
                if (tile && !tile.classList.contains('unknown')) { // Only on revealed tiles
                    const marker = document.createElement('div'); marker.classList.add('unit-marker', unit.type);
                    const unitTypeKey = `unit${unit.type.charAt(0).toUpperCase() + unit.type.slice(1)}`;
                    const translatedUnitType = lang[unitTypeKey] || unit.type;
                    marker.textContent = translatedUnitType.charAt(0).toUpperCase();
                    if (unit.id === selectedUnitId) { marker.classList.add('selected'); }
                    tile.appendChild(marker);
                    // Prepend unit info to tooltip
                    tile.title = `${translatedUnitType} (${unit.id}) - ${tile.title}`;
                }
            }
        });

        // Apply movement highlighting only to revealed tiles
        const selectedUnit = units.find(u => u.id === selectedUnitId);
        if (highlightEnabled && selectedUnit) {
            const unitGridX = selectedUnit.worldX - viewOffsetX; const unitGridY = selectedUnit.worldY - viewOffsetY;
            if (unitGridX >= 0 && unitGridX < gridSize && unitGridY >= 0 && unitGridY < gridSize) {
                tiles.forEach(tile => {
                    const targetGridX = parseInt(tile.dataset.gridX); const targetGridY = parseInt(tile.dataset.gridY);
                    const targetWorldX = targetGridX + viewOffsetX; const targetWorldY = targetGridY + viewOffsetY;
                    const dx = Math.abs(targetGridX - unitGridX); const dy = Math.abs(targetGridY - unitGridY);
                    if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0) && !tile.classList.contains('unknown')) { // Check revealed
                        const targetOccupied = units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY && u.id !== selectedUnitId);
                        if (!targetOccupied) { tile.classList.add('highlight'); }
                    }
                });
            }
        }
        checkResource();
    }

    function updateInventoryDisplay() { /* ... */ woodCountDisplay.textContent = inventory.wood; pebbleCountDisplay.textContent = inventory.pebble; flintCountDisplay.textContent = inventory.flint; wheatCountDisplay.textContent = inventory.wheat; coalCountDisplay.textContent = inventory.coal; }
    function updateResearchPointsDisplay() { /* ... */ researchPointsDisplay.textContent = researchPoints; }
    function updateUnitCoordsDisplay() { const selectedUnit = units.find(u => u.id === selectedUnitId); if (selectedUnit) { unitCoordsDisplay.textContent = `(${selectedUnit.worldX}, ${selectedUnit.worldY})`; } else { unitCoordsDisplay.textContent = `(-, -)`; } }
    function updateResearchProgress() { /* ... */ let statusMsg = researchStatusDisplay.textContent || ""; let researchCompletedThisTurn = false; const lang = translations[currentLanguage]; function formatProgress(researchKeyBase, currentPoints, cost) { const researchKey = `research${researchKeyBase.charAt(0).toUpperCase() + researchKeyBase.slice(1)}`; const progress = Math.min(100, cost > 0 ? (currentPoints / cost) * 100 : 100); const researchName = lang[researchKey] || researchKeyBase; return `${lang.researchStatusResearching} ${researchName}... ${Math.floor(progress)}%`; } function updateProgressBar(progressBar, percentDisplay, progressContainer, progress) { progressBar.style.width = progress + '%'; percentDisplay.textContent = Math.floor(progress) + '%'; progressContainer.style.display = 'flex'; } function handleCompletion(researchKeyBase, completionFlag, progressContainer, buttonElement, nextButtonElement = null) { const completionKey = `researchStatusComplete${researchKeyBase.charAt(0).toUpperCase() + researchKeyBase.slice(1)}`; activeResearch = null; researchPoints = 0; progressContainer.style.display = 'none'; buttonElement.disabled = true; statusMsg = `${lang.researchStatusComplete} ${lang[completionKey]}`; showAlert(completionKey, 3500); researchCompletedThisTurn = true; if (nextButtonElement) { const nextResearchKey = nextButtonElement.id.replace('-research', ''); const nextCompletionFlagName = `${nextResearchKey}Completed`; if (!window[nextCompletionFlagName]) { nextButtonElement.disabled = false; } } return true; } if (activeResearch === 'settlement') { const progress = Math.min(100, settlementResearchCost > 0 ? (researchPoints / settlementResearchCost) * 100 : 100); updateProgressBar(settlementResearchProgressBar, settlementResearchPercent, settlementResearchProgress, progress); if (researchPoints >= settlementResearchCost && !settlementCompleted) { settlementCompleted = handleCompletion('Settlement', settlementCompleted, settlementResearchProgress, settlementResearchBtn); } else if (activeResearch === 'settlement') { statusMsg = formatProgress('settlement', researchPoints, settlementResearchCost); } } else if (activeResearch === 'agriculture') { const progress = Math.min(100, agricultureResearchCost > 0 ? (researchPoints / agricultureResearchCost) * 100 : 100); updateProgressBar(agricultureResearchProgressBar, agricultureResearchPercent, agricultureResearchProgress, progress); if (researchPoints >= agricultureResearchCost && !agricultureCompleted) { agricultureCompleted = handleCompletion('Agriculture', agricultureCompleted, agricultureResearchProgress, agricultureResearchBtn, miningResearchBtn); } else if (activeResearch === 'agriculture') { statusMsg = formatProgress('agriculture', researchPoints, agricultureResearchCost); } } else if (activeResearch === 'mining') { const progress = Math.min(100, miningResearchCost > 0 ? (researchPoints / miningResearchCost) * 100 : 100); updateProgressBar(miningResearchProgressBar, miningResearchPercent, miningResearchProgress, progress); if (researchPoints >= miningResearchCost && !miningCompleted) { miningCompleted = handleCompletion('Mining', miningCompleted, miningResearchProgress, miningResearchBtn); } else if (activeResearch === 'mining') { statusMsg = formatProgress('mining', researchPoints, miningResearchCost); } } else { settlementResearchProgress.style.display = 'none'; agricultureResearchProgress.style.display = 'none'; miningResearchProgress.style.display = 'none'; if (!researchCompletedThisTurn && !statusMsg.startsWith(lang.researchStatusComplete)) { const isCompletionMsg = statusMsg === `${lang.researchStatusComplete} ${lang.researchStatusCompleteSettlement}` || statusMsg === `${lang.researchStatusComplete} ${lang.researchStatusCompleteAgriculture}` || statusMsg === `${lang.researchStatusComplete} ${lang.researchStatusCompleteMining}`; if (!isCompletionMsg) { const initialMsg = lang.researchStatusInitial || ""; statusMsg = researchStatusDisplay.textContent.startsWith(initialMsg) ? researchStatusDisplay.textContent : ""; } } } if (researchCompletedThisTurn) { updateBuildingsList(); updateUnitsPanel(); updateResearchPointsDisplay(); } if (researchStatusDisplay.textContent !== statusMsg || statusMsg.startsWith(lang.researchStatusComplete) || statusMsg === "" || statusMsg.startsWith(lang.researchStatusInitial)) { researchStatusDisplay.textContent = statusMsg; } researchStatusDisplay.style.display = statusMsg ? 'block' : 'none'; }
    function updateBuildingsList() { /* ... */ const buildingsListElement = buildingsList.querySelector('ul'); buildingsListElement.innerHTML = ''; const lang = translations[currentLanguage]; function addBuildingOption(buildingKey, cost, costCheckFn) { const buildingName = lang[buildingKey] || buildingKey.replace('building',''); const descriptionText = lang[`${buildingKey}Desc`] || ""; const costString = Object.entries(cost).map(([resKey, amount]) => `${amount} ${lang[resKey] || resKey}`).join(', '); const listItem = document.createElement('li'); const button = document.createElement('button'); button.textContent = `${buildingName} (${costString})`; const buildingTypeSimple = buildingKey.replace('building','').toLowerCase(); button.dataset.building = buildingTypeSimple; button.addEventListener('click', () => { if (costCheckFn()) { selectedBuilding = buildingTypeSimple; showAlert('alertBuildSelected', 4000, true, [buildingKey]); } else { showAlert('alertNotEnoughResources', 3000, true, [buildingKey]); } }); listItem.appendChild(button); const description = document.createElement('p'); description.textContent = descriptionText; description.style.fontSize = '12px'; description.style.color = '#666'; description.style.marginTop = '4px'; listItem.appendChild(description); buildingsListElement.appendChild(listItem); } if (settlementCompleted) { addBuildingOption('buildingHouse', houseCost, () => inventory.wood >= houseCost.wood && inventory.pebble >= houseCost.pebble); } if (agricultureCompleted) { addBuildingOption('buildingFarm', farmCost, () => inventory.wood >= farmCost.wood); } if (miningCompleted) { addBuildingOption('buildingMine', mineCost, () => inventory.pebble >= mineCost.pebble && inventory.wood >= mineCost.wood); } if (buildingsListElement.innerHTML === '') { buildingsListElement.innerHTML = `<li>${lang.noBuildingsAvailable}</li>`; } }
    function updateUnitDisplayBar() { /* ... */ unitDisplayBar.innerHTML = ''; const lang = translations[currentLanguage]; units.forEach(unit => { const icon = document.createElement('div'); icon.classList.add('unit-icon'); icon.dataset.unitId = unit.id; icon.dataset.unitType = unit.type; const unitTypeKey = `unit${unit.type.charAt(0).toUpperCase() + unit.type.slice(1)}`; const translatedUnitType = lang[unitTypeKey] || unit.type; icon.textContent = translatedUnitType.charAt(0).toUpperCase(); icon.title = `${translatedUnitType} (${unit.id})`; if (unit.id === selectedUnitId) { icon.classList.add('selected'); } icon.addEventListener('click', () => { selectedUnitId = unit.id; focusOnUnit(unit.id); }); unitDisplayBar.appendChild(icon); }); }
    function updateUnitsPanel() { /* ... */ const currentWorkers = units.filter(u => u.type === 'worker').length; const lang = translations[currentLanguage]; let buttonText = lang.deployWorkerButton; let isDisabled = false; if (!settlementCompleted) { isDisabled = true; } else if (maxWorkers <= 0) { isDisabled = true; buttonText = lang.deployWorkerRequiresHouse; } else if (currentWorkers >= maxWorkers) { isDisabled = true; buttonText = `${lang.deployWorkerButton} (${currentWorkers}/${maxWorkers} ${lang.deployWorkerMax})`; } else { isDisabled = false; buttonText = `${lang.deployWorkerButton} (${currentWorkers}/${maxWorkers})`; } deployWorkerButton.disabled = isDisabled; deployWorkerButton.textContent = buttonText; const workerLi = unitsList.querySelector('li'); if (workerLi) { workerLi.innerHTML = ''; workerLi.appendChild(deployWorkerButton); } else { const newLi = document.createElement('li'); newLi.appendChild(deployWorkerButton); unitsList.appendChild(newLi); } }

    // --- Gameplay Functions ---
    function checkResource() { /* ... */ const selectedUnit = units.find(u => u.id === selectedUnitId); let canGather = false; let tileInfo = null; if (selectedUnit) { const unitWorldX = selectedUnit.worldX; const unitWorldY = selectedUnit.worldY; const data = getTileData(unitWorldX, unitWorldY); tileInfo = data; if (data && !data.building) { if (data.type === 'tree' || data.type === 'stone' || data.type === 'flint') { canGather = true; } } } actionButton.style.display = canGather ? 'inline-block' : 'none'; displayTileInfo(selectedUnit, tileInfo); }
    function displayTileInfo(unit, tileData) { /* ... */ const lang = translations[currentLanguage]; if (!unit) { resourceNameDisplay.textContent = lang.noUnitSelected; return; } let nameToShow = lang.unknownTile; if (tileData) { if (tileData.building) { const buildingKey = `building${tileData.building.charAt(0).toUpperCase() + tileData.building.slice(1)}`; nameToShow = `${lang.onTile} ${lang[buildingKey] || tileData.building}`; } else if (tileData.type === 'tree') { nameToShow = `${lang.onTile} ${lang.tileResourceTree}`; } else if (tileData.type === 'stone') { nameToShow = `${lang.onTile} ${lang.tileResourceStone}`; } else if (tileData.type === 'flint') { nameToShow = `${lang.onTile} ${lang.tileResourceFlint}`; } else { nameToShow = `${lang.onTile} ${lang.emptyTile}`; } if(tileData.biome){ const biomeName = lang[`biome${tileData.biome.charAt(0).toUpperCase() + tileData.biome.slice(1)}`] || tileData.biome; nameToShow += ` (${biomeName})`}} resourceNameDisplay.textContent = nameToShow; }
    function moveUnit(targetGridX, targetGridY) { /* ... */ const selectedUnit = units.find(u => u.id === selectedUnitId); if (!selectedUnit) return; const targetWorldX = targetGridX + viewOffsetX; const targetWorldY = targetGridY + viewOffsetY; const dx = Math.abs(targetWorldX - selectedUnit.worldX); const dy = Math.abs(targetWorldY - selectedUnit.worldY); if (!(dx <= 1 && dy <= 1 && (dx !== 0 || dy !== 0))) { return; } if (!revealedTiles.has(`${targetWorldX},${targetWorldY}`)) { return; } const targetOccupied = units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY && u.id !== selectedUnitId); if (targetOccupied) { showAlert("alertUnitMoveOccupied", 2000, false); return; } selectedUnit.worldX = targetWorldX; selectedUnit.worldY = targetWorldY; revealArea(targetWorldX, targetWorldY, REVEAL_RADIUS); if (activeResearch) { researchPoints++; updateResearchPointsDisplay(); updateResearchProgress(); } moveCount++; movesSinceLastCoal++; if (moveCount >= wheatProductionInterval) { produceWheat(); moveCount = 0; } if (movesSinceLastCoal >= coalProductionInterval) { produceCoal(); movesSinceLastCoal = 0; } const unitStillSelected = selectedUnit.id === selectedUnitId; if (unitStillSelected) { focusOnUnit(selectedUnit.id); } else { updateGrid(); } }
    function gatherResource() { /* ... */ const selectedUnit = units.find(u => u.id === selectedUnitId); if (!selectedUnit) { showAlert("noUnitSelected", 2000); return; } const unitWorldX = selectedUnit.worldX; const unitWorldY = selectedUnit.worldY; const data = getTileData(unitWorldX, unitWorldY); if (data && !data.building) { let gatheredResourceKey = ''; if (data.type === 'tree') { inventory.wood++; gatheredResourceKey = 'wood'; data.type = 'empty'; } else if (data.type === 'stone') { inventory.pebble++; gatheredResourceKey = 'pebble'; data.type = 'empty'; } else if (data.type === 'flint') { inventory.flint++; gatheredResourceKey = 'flint'; data.type = 'empty'; } if (gatheredResourceKey) { showAlert('alertGathered', 1500, true, [gatheredResourceKey]); setTileData(unitWorldX, unitWorldY, data); updateInventoryDisplay(); updateGrid(); } } }
    function produceWheat() { /* ... */ let wheatProduced = 0; revealedTiles.forEach(coordString => { const [x, y] = coordString.split(',').map(Number); const data = getTileData(x, y); if (data && data.building === 'farm') { wheatProduced++; } }); if (wheatProduced > 0) { inventory.wheat += wheatProduced; updateInventoryDisplay(); } }
    function produceCoal() { /* ... */ let coalProduced = 0; revealedTiles.forEach(coordString => { const [x, y] = coordString.split(',').map(Number); const data = getTileData(x, y); if (data && data.building === 'mine') { coalProduced++; } }); if (coalProduced > 0) { inventory.coal += coalProduced; updateInventoryDisplay(); } }
    function findSpawnPointNearHouse() { /* ... */ const workers = units.filter(u => u.type === 'worker'); if (workers.length === 0 && units.length > 0) { const pawn = units[0]; for (let dy = -1; dy <= 1; dy++) { for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const sx = pawn.worldX + dx; const sy = pawn.worldY + dy; const sData = getTileData(sx, sy); if (revealedTiles.has(`${sx},${sy}`) && sData && sData.type === 'empty' && !sData.building && !units.some(u => u.worldX === sx && u.worldY === sy)) { return { worldX: sx, worldY: sy }; } } } return null; } const houseCoords = []; revealedTiles.forEach(coordString => { const [x, y] = coordString.split(',').map(Number); const data = getTileData(x,y); if(data && data.building === 'house') { houseCoords.push({worldX: x, worldY: y}); } }); if (houseCoords.length === 0) return null; for (const houseCoord of houseCoords) { for (let dy = -1; dy <= 1; dy++) { for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const sx = houseCoord.worldX + dx; const sy = houseCoord.worldY + dy; const sData = getTileData(sx, sy); if (revealedTiles.has(`${sx},${sy}`) && sData && sData.type === 'empty' && !sData.building && !units.some(u => u.worldX === sx && u.worldY === sy)) { return { worldX: sx, worldY: sy }; } } } } return null; }

    // --- Unit Focusing ---
    function focusOnUnit(unitId) { /* ... */ const unit = units.find(u => u.id === unitId); if (!unit) return; const newViewOffsetX = unit.worldX - VIEW_CENTER_OFFSET; const newViewOffsetY = unit.worldY - VIEW_CENTER_OFFSET; const viewChanged = newViewOffsetX !== viewOffsetX || newViewOffsetY !== viewOffsetY; viewOffsetX = newViewOffsetX; viewOffsetY = newViewOffsetY; let newlyRevealed = false; for (let gy = 0; gy < gridSize; gy++) { for (let gx = 0; gx < gridSize; gx++) { if(revealArea(gx + viewOffsetX, gy + viewOffsetY, 0)) { newlyRevealed = true; } } } selectedUnitId = unitId; updateUnitDisplayBar(); updateUnitCoordsDisplay(); if (viewChanged || newlyRevealed) { updateGrid(); } else { updateGrid(); } }

    // --- Event Listeners ---
    grid.addEventListener('click', (event) => { // <<< SIMPLIFIED (removed visibility check)
        if (event.target.classList.contains('tile') && !event.target.classList.contains('unknown')) {
            const gridX = parseInt(event.target.dataset.gridX); const gridY = parseInt(event.target.dataset.gridY);
            const worldX = gridX + viewOffsetX; const worldY = gridY + viewOffsetY;
            const clickedUnit = units.find(u => u.worldX === worldX && u.worldY === worldY);
            const lang = translations[currentLanguage];

            if (clickedUnit) { /* ... select unit ... */ selectedUnitId = clickedUnit.id; selectedBuilding = null; updateUnitDisplayBar(); updateGrid(); const unitTypeKey = `unit${clickedUnit.type.charAt(0).toUpperCase() + clickedUnit.type.slice(1)}`; showAlert('alertSelectedUnit', 1500, false, [unitTypeKey, clickedUnit.id]); }
            else if (selectedBuilding) { // Build action
                const builderUnit = units.find(u => u.id === selectedUnitId); if (!builderUnit) { showAlert("alertSelectUnitToBuild", 2500); selectedBuilding = null; return; }
                const tileData = getTileData(worldX, worldY);
                // Check if tile exists, is empty, has no building (No visibility check)
                if (tileData && tileData.type === 'empty' && !tileData.building) {
                   const capabilities = unitCapabilities[builderUnit.type]; const buildingKey = `building${selectedBuilding.charAt(0).toUpperCase() + selectedBuilding.slice(1)}`;
                   if (!capabilities || !capabilities.canBuild.includes(selectedBuilding)) { const unitTypeKey = `unit${builderUnit.type.charAt(0).toUpperCase() + builderUnit.type.slice(1)}`; showAlert('alertUnitCannotBuild', 3000, true, [unitTypeKey, buildingKey]); selectedBuilding = null; return; }
                   let costMet = false; let cost;
                   if (selectedBuilding === 'house') { cost = houseCost; if (inventory.wood >= cost.wood && inventory.pebble >= cost.pebble) { inventory.wood -= cost.wood; inventory.pebble -= cost.pebble; costMet = true; maxWorkers++; updateUnitsPanel(); } }
                   else if (selectedBuilding === 'farm') { cost = farmCost; if (inventory.wood >= cost.wood) { inventory.wood -= cost.wood; costMet = true; } }
                   else if (selectedBuilding === 'mine') { cost = mineCost; if (inventory.pebble >= cost.pebble && inventory.wood >= cost.wood) { inventory.pebble -= cost.pebble; inventory.wood -= cost.wood; costMet = true; } }
                   if(costMet) { tileData.building = selectedBuilding; setTileData(worldX, worldY, tileData); showAlert('alertBuildingBuilt', 2500, true, [buildingKey]); selectedBuilding = null; updateInventoryDisplay(); updateGrid(); updateBuildingsList(); }
                   else { showAlert('alertNotEnoughResources', 3000, true, [buildingKey]); selectedBuilding = null; }
                } else { // Tile not suitable
                     let reasonKey = 'alertCannotBuildNonEmpty'; let reasonArgs = [];
                     if (tileData && tileData.building) { reasonKey = 'alertCannotBuildExists'; reasonArgs = [`building${tileData.building.charAt(0).toUpperCase() + tileData.building.slice(1)}`]; }
                     else if (tileData && tileData.type !== 'empty') { let resourceNameKey = ''; if (tileData.type === 'tree') resourceNameKey = 'tileResourceTree'; else if (tileData.type === 'stone') resourceNameKey = 'tileResourceStone'; else if (tileData.type === 'flint') resourceNameKey = 'tileResourceFlint'; reasonKey = 'alertCannotBuildOnResource'; reasonArgs = [resourceNameKey || tileData.type]; }
                     showAlert(reasonKey, 3000, true, reasonArgs); selectedBuilding = null;
                }
            } else { // Move action to revealed tile
                 moveUnit(gridX, gridY);
            }
        }
    });
    actionButton.addEventListener('click', gatherResource);

    // --- Panel Toggling ---
    function hideAllPanels() { /* ... */ techTree.style.display = 'none'; buildingsList.style.display = 'none'; unitsPanel.style.display = 'none'; logsPanel.style.display = 'none'; }
    researchButton.addEventListener('click', () => { /* ... */ const isVisible = techTree.style.display === 'block'; hideAllPanels(); if (!isVisible) techTree.style.display = 'block'; });
    buildingsButton.addEventListener('click', () => { /* ... */ const isVisible = buildingsList.style.display === 'block'; hideAllPanels(); if (!isVisible) { updateBuildingsList(); buildingsList.style.display = 'block'; } });
    unitsButton.addEventListener('click', () => { /* ... */ const isVisible = unitsPanel.style.display === 'block'; hideAllPanels(); if (!isVisible) { updateUnitsPanel(); unitsPanel.style.display = 'block'; } });
    logsButton.addEventListener('click', () => { /* ... */ const isVisible = logsPanel.style.display === 'block'; hideAllPanels(); if (!isVisible) { updateLogsDisplay(); logsPanel.style.display = 'block'; } });

    // --- Log Filter/Search Listeners ---
    logSearchInput.addEventListener('input', updateLogsDisplay); logFilterCheckbox.addEventListener('change', updateLogsDisplay);

    // --- Research Button Listeners ---
    function handleResearchClick(researchType, buttonElement, completionFlag, progressContainer) { /* ... */ const researchKey = `research${researchType.charAt(0).toUpperCase() + researchType.slice(1)}`; if (buttonElement.disabled || completionFlag) return; if (!activeResearch) { activeResearch = researchType.toLowerCase(); progressContainer.style.display = 'flex'; updateResearchPointsDisplay(); updateResearchProgress(); showAlert("alertResearchStarted", 2500, true, [researchKey]); } else { const activeResearchKey = `research${activeResearch.charAt(0).toUpperCase() + activeResearch.slice(1)}`; showAlert("alertAlreadyResearching", 3000, true, [activeResearchKey]); } }
    settlementResearchBtn.addEventListener('click', () => handleResearchClick('Settlement', settlementResearchBtn, settlementCompleted, settlementResearchProgress));
    agricultureResearchBtn.addEventListener('click', () => handleResearchClick('Agriculture', agricultureResearchBtn, agricultureCompleted, agricultureResearchProgress));
    miningResearchBtn.addEventListener('click', () => handleResearchClick('Mining', miningResearchBtn, miningCompleted, miningResearchProgress));

    // --- Deploy Worker Listener ---
    deployWorkerButton.addEventListener('click', () => { /* ... */ if (deployWorkerButton.disabled) return; const spawnDetails = findSpawnPointNearHouse(); if (spawnDetails) { const newWorker = { id: `unit-${nextUnitId++}`, type: 'worker', worldX: spawnDetails.worldX, worldY: spawnDetails.worldY }; units.push(newWorker); revealArea(newWorker.worldX, newWorker.worldY, REVEAL_RADIUS); showAlert("alertWorkerDeployed", 2000); updateGrid(); updateUnitDisplayBar(); updateUnitsPanel(); } else { showAlert("alertNoSpaceForWorker", 3000); } });

    // --- Grid Hover Highlights ---
    grid.addEventListener('mouseover', (event) => { /* ... */ if (event.target.classList.contains('tile') && !event.target.classList.contains('unknown') && !selectedBuilding && selectedUnitId != null) { highlightEnabled = true; updateGrid(); } });
    grid.addEventListener('mouseout', (event) => { /* ... */ if (highlightEnabled && (!event.relatedTarget || !event.relatedTarget.closest || !event.relatedTarget.closest('#grid'))) { highlightEnabled = false; updateGrid(); } });

    // --- Save/Load Functions ---
    function gatherSaveData() { // Added worldSeed
        return { units: units, nextUnitId: nextUnitId, selectedUnitId: selectedUnitId, inventory: inventory, researchPoints: researchPoints, activeResearch: activeResearch, settlementCompleted: settlementCompleted, agricultureCompleted: agricultureCompleted, miningCompleted: miningCompleted, maxWorkers: maxWorkers, moveCount: moveCount, movesSinceLastCoal: movesSinceLastCoal, colonyName: colonyName, currentLanguage: currentLanguage, eventLogs: eventLogs.map(log => ({ time: log.time, messageKey: log.messageKey || null, args: log.args || [] })), viewOffsetX: viewOffsetX, viewOffsetY: viewOffsetY, worldData: worldData, revealedTiles: Array.from(revealedTiles), worldSeed: worldSeed }; // SAVE SEED
    }
    function saveGame() { /* ... */ try { const saveData = gatherSaveData(); const saveDataJson = JSON.stringify(saveData); const blob = new Blob([saveDataJson], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const safeColonyName = colonyName.replace(/[^a-z0-9]/gi, '_').toLowerCase(); link.download = `tinyciv_${safeColonyName}_save.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showAlert('alertGameSaved', 2000); const timeString = getFormattedTime(); eventLogs.push({ time: timeString, messageKey: 'logGameSaved', args: [], rendered: translations[currentLanguage].logGameSaved }); if (logsPanel.style.display === 'block') { updateLogsDisplay(); } } catch (error) { console.error("Error saving game:", error); if (error instanceof RangeError) { showAlert('alertSaveError', 6000, true, ["Save data too large!"]); } else { showAlert('alertSaveError', 4000); } } }

    function applyLoadedData(data) { // Restore worldSeed
        units = data.units || []; nextUnitId = data.nextUnitId || 0; inventory = data.inventory || { wood: 0, pebble: 0, flint: 0, wheat: 0, coal: 0 }; researchPoints = data.researchPoints || 0; activeResearch = data.activeResearch || null; settlementCompleted = data.settlementCompleted || false; agricultureCompleted = data.agricultureCompleted || false; miningCompleted = data.miningCompleted || false; maxWorkers = data.maxWorkers || 0; moveCount = data.moveCount || 0; movesSinceLastCoal = data.movesSinceLastCoal || 0; colonyName = data.colonyName || "Loaded Colony"; currentLanguage = data.currentLanguage || 'en';
        viewOffsetX = data.viewOffsetX || 0; viewOffsetY = data.viewOffsetY || 0; worldData = data.worldData || {}; revealedTiles = new Set(data.revealedTiles || []);
        worldSeed = data.worldSeed || Date.now(); // Restore seed or generate new if missing
        perlin.seed(worldSeed); // << RE-SEED PERLIN NOISE
        selectedUnitId = data.selectedUnitId !== undefined ? data.selectedUnitId : (units.length > 0 ? units[0].id : null);
         eventLogs = (data.eventLogs || []).map(log => { let renderedMessage = translations[currentLanguage][log.messageKey] || log.messageKey || "?"; if (log.args && log.args.length > 0) { log.args.forEach((arg, index) => { const translatedArg = translations[currentLanguage][arg] || arg; renderedMessage = renderedMessage.replace(`{${index}}`, translatedArg); }); } return { time: log.time, messageKey: log.messageKey, args: log.args, rendered: renderedMessage }; });
        selectedBuilding = null; highlightEnabled = false; hideAllPanels(); updateLanguageUI(); updateInventoryDisplay(); updateResearchPointsDisplay(); updateUnitDisplayBar(); updateUnitCoordsDisplay(); updateGrid(); updateResearchProgress(); updateBuildingsList(); updateUnitsPanel();
        settlementResearchBtn.disabled = settlementCompleted || !!activeResearch; agricultureResearchBtn.disabled = agricultureCompleted || !!activeResearch; miningResearchBtn.disabled = miningCompleted || !agricultureCompleted || !!activeResearch;
        showAlert('alertLoadSuccess', 3000, false, [colonyName]);
    }
    function loadGame(event) { /* ... */ const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const fileContent = e.target.result; const loadedData = JSON.parse(fileContent); if (!loadedData || typeof loadedData.colonyName === 'undefined' || typeof loadedData.units === 'undefined' || typeof loadedData.worldData === 'undefined') { throw new Error(translations[currentLanguage].alertLoadInvalidFormat); } applyLoadedData(loadedData); } catch (error) { console.error("Error loading game:", error); showAlert('alertLoadError', 5000, true, [error.message]); } finally { loadFileInput.value = null; } }; reader.onerror = function() { showAlert('alertReadFileError', 3000); loadFileInput.value = null; }; reader.readAsText(file); }

    // --- Event Listeners for Save/Load ---
    saveButton.addEventListener('click', saveGame); loadButton.addEventListener('click', () => loadFileInput.click()); loadFileInput.addEventListener('change', loadGame);

    // --- UI Language Update Function ---
    function updateLanguageUI() { /* ... */ const lang = translations[currentLanguage]; document.querySelector('h1').textContent = lang.gameTitle; languageSwitchButton.textContent = (currentLanguage === 'en') ? lang.switchToFrench : lang.switchToEnglish; languageSwitchButton.title = lang.switchLanguageTooltip; colonyNameDisplay.textContent = `${lang.colonyLabel} ${colonyName}`; inventoryDisplay.querySelector('h2').textContent = lang.inventoryTitle; inventoryDisplay.querySelector('p:nth-of-type(1)').childNodes[0].nodeValue = `${lang.wood}: `; inventoryDisplay.querySelector('p:nth-of-type(2)').childNodes[0].nodeValue = `${lang.pebble}: `; inventoryDisplay.querySelector('p:nth-of-type(3)').childNodes[0].nodeValue = `${lang.flint}: `; inventoryDisplay.querySelector('p:nth-of-type(4)').childNodes[0].nodeValue = `${lang.wheat}: `; inventoryDisplay.querySelector('p:nth-of-type(5)').childNodes[0].nodeValue = `${lang.coal}: `; actionButton.textContent = lang.gatherButton; researchButton.textContent = lang.researchButton; buildingsButton.textContent = lang.buildingsButton; unitsButton.textContent = lang.unitsButton; logsButton.textContent = lang.logsButton; saveButton.textContent = lang.saveButton; loadButton.textContent = lang.loadButton; if(logsPanel) { logsPanel.querySelector('h2').textContent = lang.logsPanelTitle; logSearchInput.placeholder = lang.logSearchPlaceholder; const filterLabel = logFilterCheckbox.parentElement; if (filterLabel && filterLabel.lastChild.nodeType === Node.TEXT_NODE) { filterLabel.lastChild.nodeValue = ` ${lang.logFilterLabel}`; } else if (filterLabel) { filterLabel.appendChild(document.createTextNode(` ${lang.logFilterLabel}`)); } } researchPointsDisplay.parentElement.childNodes[0].nodeValue = `${lang.researchPointsLabel} `; if(techTree) { techTree.querySelector('h2').textContent = lang.researchPanelTitle; techTree.querySelector('h3').textContent = lang.primitiveAge; settlementResearchBtn.textContent = lang.researchSettlement; settlementResearchBtn.parentElement.querySelector('p').textContent = lang.researchSettlementDesc; agricultureResearchBtn.textContent = lang.researchAgriculture; agricultureResearchBtn.parentElement.querySelector('p').textContent = lang.researchAgricultureDesc; miningResearchBtn.textContent = lang.researchMining; miningResearchBtn.parentElement.querySelector('p').textContent = lang.researchMiningDesc; } if(buildingsList) buildingsList.querySelector('h2').textContent = lang.buildingsPanelTitle; if(unitsPanel) unitsPanel.querySelector('h2').textContent = lang.unitsPanelTitle; updateGrid(); updateUnitDisplayBar(); updateBuildingsList(); updateUnitsPanel(); updateResearchProgress(); checkResource(); if (logsPanel.style.display === 'block') { updateLogsDisplay(); } }

    // --- Event Listener for Language Switch ---
    languageSwitchButton.addEventListener('click', () => { /* ... */ currentLanguage = (currentLanguage === 'en') ? 'fr' : 'en'; eventLogs.forEach(log => { if (log.messageKey) { let renderedMessage = translations[currentLanguage][log.messageKey] || log.messageKey; if (log.args && log.args.length > 0) { log.args.forEach((arg, index) => { const translatedArg = translations[currentLanguage][arg] || arg; renderedMessage = renderedMessage.replace(`{${index}}`, translatedArg); }); } log.rendered = renderedMessage; } }); updateLanguageUI(); });

    // --- Game Start ---
    function startGame() { // <<< MODIFIED initial reveal logic
        currentLanguage = 'en'; const lang = translations[currentLanguage];
        colonyName = prompt(lang.promptColonyName, lang.defaultColonyName); if (!colonyName || colonyName.trim() === "") { colonyName = lang.defaultColonyName; }
        // Reset state
        nextUnitId = 0; inventory = { wood: 0, pebble: 0, flint: 0, wheat: 0, coal: 0 }; researchPoints = 0; activeResearch = null; settlementCompleted = false; agricultureCompleted = false; miningCompleted = false; maxWorkers = 0; selectedBuilding = null; moveCount = 0; movesSinceLastCoal = 0; highlightEnabled = false; eventLogs = [{ time: getFormattedTime(), messageKey: 'logNewGame', args:[colonyName], rendered: lang.logNewGame.replace('{0}', colonyName) }]; worldData = {}; revealedTiles = new Set();
        worldSeed = Date.now(); // Generate seed for new game
        perlin.seed(worldSeed); // Seed the noise generator
        const startWorldX = 5; const startWorldY = 5; units = [{ id: `unit-${nextUnitId++}`, type: 'pawn', worldX: startWorldX, worldY: startWorldY }]; selectedUnitId = units[0].id; viewOffsetX = startWorldX - VIEW_CENTER_OFFSET; viewOffsetY = startWorldY - VIEW_CENTER_OFFSET;
        // Init UI & World
        initializeGridDOM();
        revealArea(startWorldX, startWorldY, REVEAL_RADIUS); // Use REVEAL_RADIUS for initial discovery area
        hideAllPanels();
        updateLanguageUI(); updateInventoryDisplay(); updateResearchPointsDisplay(); updateUnitDisplayBar(); updateUnitCoordsDisplay(); updateGrid(); updateResearchProgress(); updateBuildingsList(); updateUnitsPanel();
        // Init buttons
        settlementResearchBtn.disabled = false; agricultureResearchBtn.disabled = false; miningResearchBtn.disabled = true;
        researchStatusDisplay.textContent = lang.researchStatusInitial; researchStatusDisplay.style.display = 'block';
        showAlert('alertWelcome', 4000, false, [colonyName]);
    }

    // Start
    startGame();

  </script>
</body>
</html>
