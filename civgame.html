<html>
<head>
<title>Tiny Civilization Evolved</title>
<meta charset="UTF-8">
<style>
  /* --- General Styles --- */
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; text-align: center; display: flex; flex-direction: column; align-items: center; background-color: #e8eff5; margin: 0; padding: 20px; color: #333; }
  h1 { color: #2c3e50; margin-bottom: 10px; }

  /* Language Switcher */
  #language-switcher { position: absolute; top: 15px; left: 15px; z-index: 10; }
  #language-switch-button { padding: 8px 12px; font-size: 14px; background-color: #5dade2; color: white; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: background-color 0.2s ease; }
  #language-switch-button:hover { background-color: #3498db; }


  /* --- Unit Display Bar --- */
  #unit-display-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 10px; margin-bottom: 15px; min-height: 40px; background-color: #dde8f0; border-radius: 8px; border: 1px solid #c8d6e1; flex-wrap: wrap; }
  .unit-icon { width: 35px; height: 35px; border: 2px solid #adb5bd; background-color: #ced4da; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; cursor: pointer; transition: all 0.2s ease; position: relative; }
  .unit-icon:hover { border-color: #495057; background-color: #e9ecef; transform: scale(1.05); }
  .unit-icon.selected { border-color: #007bff; box-shadow: 0 0 8px rgba(0, 123, 255, 0.5); transform: scale(1.1); }
  .unit-icon[data-unit-type="pawn"] { background-color: #3498db; color: white; }
  .unit-icon[data-unit-type="worker"] { background-color: #e67e22; color: white; }
  .unit-icon[data-unit-type="scout"] { background-color: #1abc9c; color: white; }

  /* --- Alert Message --- */
  #alert-message { padding: 10px 20px; margin-top: 10px; border-radius: 8px; background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; font-weight: bold; text-align: center; opacity: 0; transition: opacity 0.5s ease-in-out; max-width: 550px; width: 90%; box-sizing: border-box; position: relative; left: 50%; transform: translateX(-50%); display: none; z-index: 20; }
  #alert-message.show { display: block; opacity: 1; }

  /* --- Game Layout --- */
  #game-container { display: flex; justify-content: center; align-items: flex-start; margin-top: 20px; flex-wrap: wrap; gap: 20px; background-color: #ffffff; padding: 30px; border-radius: 16px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); max-width: 1400px; width: 100%; position: relative; }
  #left-container, #right-panel { display: flex; flex-direction: column; align-items: stretch; gap: 15px; flex: 1; min-width: 250px; }
  #middle-controls { display: flex; flex-direction: column; align-items: stretch; gap: 10px; flex: 0 0 auto; width: 150px; }
  #middle-controls button { margin-top: 0; }
  #grid-area { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; min-width: 585px; }
  #grid { display: grid; grid-template-columns: repeat(10, 55px); grid-template-rows: repeat(10, 55px); gap: 5px; padding: 15px; background-color: #b0bec5; border-radius: 12px; border: 1px solid #90a4ae; margin-bottom: 10px; position: relative; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

  /* --- Tiles --- */
  .tile { width: 55px; height: 55px; border: 1px solid #cfd8dc; display: flex; align-items: center; justify-content: center; font-size: 28px; font-weight: normal; cursor: pointer; overflow: hidden; border-radius: 8px; transition: background-color 0.2s ease-in-out, border-color 0.2s ease, box-shadow 0.2s ease; background-color: #eceff1; color: #555; position: relative; line-height: 1; }
  .tile:not(.unknown):hover { transform: scale(1.05); box-shadow: 0 0 8px rgba(0, 0, 0, 0.1); z-index: 1; }
  .tile.unknown { /* Darker Unknown Tile */
    background-color: #78909c; /* Darker shade */
    cursor: default;
    border-color: #546e7a; /* Darker border */
    color: #cfd8dc; /* Lighter text for contrast */
    opacity: 0.85;
  }
  .tile.unknown:hover { /* Prevent hover effects on unknown */
    transform: none;
    box-shadow: none;
    z-index: 0;
  }
  .unit-marker { border-radius: 50%; width: 70%; height: 70%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: white; position: absolute; z-index: 2; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); pointer-events: none; }
  .unit-marker.pawn { background-color: #3498db; } .unit-marker.worker { background-color: #e67e22; } .unit-marker.scout { background-color: #1abc9c; }
  .unit-marker.selected { outline: 3px solid #007bff; outline-offset: 2px; }

  /* Resource & Building Styles */
  .tile.grass { background-color: #aed581; color: #38761d; border-color: #9ccc65; }
  .tile.tree { background-color: #c8e6c9; color: #2e7d32; border-color: #a5d6a7; font-size: 32px; }
  .tile.stone { background-color: #95a5a6; color: #fff; }
  .tile.flint { background-color: #7f8c8d; color: #fff; }
  .tile.water { background-color: #5dade2; cursor: not-allowed; border-color: #3498db; }
  .tile.sand { background-color: #f7dc6f; color: #9a7d0a; border-color: #f1c40f; }
  .tile.house, .tile.farm, .tile.mine, .tile.quarry, .tile.warehouse { text-align: center; line-height: 55px; font-weight: bold; font-size: 10px; }
  .tile.farm { background-color: #f1c40f; color: #333; }
  .tile.mine { background-color: #607d8b; color: white; }
  .tile.house { background-color: #8e44ad; color: white; }
  .tile.quarry { background-color: #a1887f; color: white; border-color: #795548;}
  .tile.warehouse { background-color: #7f8c8d; color: white; border-color: #62757f; }

  /* Highlight Styles */
  .highlight { background-color: rgba(52, 152, 219, 0.2) !important; border: 1px solid #3498db !important; }
  .tile.highlight-house-target { /* Style for target house selection */
       background-color: rgba(46, 204, 113, 0.3) !important; /* Light green highlight */
       border: 2px solid #2ecc71 !important; /* Green border */
       box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
       cursor: crosshair; /* Indicate target selection */
   }

  /* --- Buttons --- */
  button { padding: 12px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 8px; background-color: #3498db; color: white; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); font-weight: 600; }
  button:hover:not(:disabled) { background-color: #2980b9; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); transform: translateY(-1px); }
  button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
  button:disabled { background-color: #bdc3c7; cursor: default; opacity: 0.7; }
  #action-button { background-color: #e67e22; margin-top: 5px; }
  #action-button:hover:not(:disabled) { background-color: #d35400; }
  /* Panel toggle buttons */
  #middle-controls button { background-color: #9b59b6; } #middle-controls button:hover:not(:disabled) { background-color: #8e44ad; }
  #middle-controls #tutorial-button { background-color: #f39c12; } #middle-controls #tutorial-button:hover:not(:disabled) { background-color: #e67e22; }
  #middle-controls #research-button { background-color: #2980b9; } #middle-controls #research-button:hover:not(:disabled) { background-color: #1f618d; }
  #middle-controls #buildings-button { background-color: #16a085; } #middle-controls #buildings-button:hover:not(:disabled) { background-color: #117a65; }
  #middle-controls #units-button { background-color: #27ae60; } /* Green */ #middle-controls #units-button:hover:not(:disabled) { background-color: #229954; }
  #middle-controls #upgrade-button { background-color: #c0392b; } /* Red */ #middle-controls #upgrade-button:hover:not(:disabled) { background-color: #a93226; }
  #middle-controls #logs-button { background-color: #34495e; } #middle-controls #logs-button:hover:not(:disabled) { background-color: #2c3e50; }
  #middle-controls #save-button { background-color: #2ecc71; } #middle-controls #save-button:hover:not(:disabled) { background-color: #27ae60; }
  #middle-controls #load-button { background-color: #f1c40f; } #middle-controls #load-button:hover:not(:disabled) { background-color: #d4ac0d; }
  /* Buttons within panels */
  .panel-content li button { background-color: #f1c40f; color: #333; padding: 8px 15px; font-size: 14px; width: auto; display: inline-block; margin-right: 5px; }
  .panel-content li button:hover:not(:disabled) { background-color: #f39c12; }
  .research-item button { background-color: #2ecc71; margin-bottom: 5px; /* Add space below button */ }
  .research-item button:hover:not(:disabled) { background-color: #27ae60; }
  .research-item.completed button { /* Style for completed research */
      background-color: #95a5a6;
      filter: grayscale(80%);
      cursor: default;
  }
  .research-item.completed button:hover:not(:disabled) { background-color: #95a5a6; }
   .research-item.completed .research-info { opacity: 0.7; } /* Fade info too */

  #units-list li button { background-color: #27ae60; color: white; padding: 8px 15px; font-size: 14px; width: auto; display: inline-block; margin-right: 5px; } /* Style for unit deploy buttons */
  #units-list li button:hover:not(:disabled) { background-color: #229954; } /* Darker green on hover */
  #upgrade-info button { background-color: #c0392b; color: white; padding: 6px 10px; font-size: 13px; width: 100%; box-sizing: border-box; margin-top: 5px; border-radius: 5px; display: block; }
  #upgrade-info button:hover:not(:disabled) { background-color: #a93226; }

  /* --- Panels --- */
  .panel { text-align: left; background-color: #fdfefe; padding: 20px; border-radius: 12px; border: 1px solid #e4e9ed; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); max-height: 350px; overflow-y: auto; display: none; /* Hidden by default */ }
  #inventory { display: block; max-height: none; overflow-y: visible; }
  #logs-panel { max-height: 250px; }
  .panel h2 { font-size: 20px; color: #2c3e50; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
  .panel ul { list-style-type: none; padding: 0; margin: 0; }
  .panel li { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
  .panel li:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
  .panel p.description { font-size: 13px; color: #777; margin-top: 0; margin-bottom: 0; }

  /* Specific Panel Styles */
  #inventory p { font-size: 16px; color: #555; margin-bottom: 8px; line-height: 1.4; } #inventory span { font-weight: bold; color: #333; }
  #tech-tree h3 { font-size: 18px; color: #3498db; margin-bottom: 10px; }
   .research-item .research-info { margin-top: 5px; font-size: 13px; color: #555; }
   .research-item .research-cost { font-weight: bold; margin-bottom: 3px; margin-top: 0; }
   .research-item .description { margin-top: 0; margin-bottom: 0; }
   .panel-content .building-cost { font-size: 13px; font-weight: bold; color: #777; margin-top: 4px; margin-bottom: 2px; }
   .panel-content #buildings-list .description { margin-top: 2px; }

  #logs-list { list-style-type: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.5; color: #555; margin-top: 10px; }
  #logs-list li { padding: 4px 0; border-bottom: 1px dashed #eee; white-space: pre-wrap; } #logs-list li:last-child { border-bottom: none; }
  #logs-list .log-time { display: inline-block; width: 50px; color: #888; margin-right: 5px; }
  #log-search-input { width: 100%; padding: 8px 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 14px; }
  #log-filter-container { display: block; margin-bottom: 10px; font-size: 14px; color: #555; }
  #log-filter-checkbox { margin-right: 5px; vertical-align: middle; }

  /* --- Other UI --- */
  #colony-name-display { font-size: 22px; color: #2c3e50; font-weight: bold; margin-bottom: 0; text-align: left; padding: 10px; background-color: #ecf0f1; border-radius: 8px; }
  #resource-name { margin-top: 15px; font-size: 16px; font-weight: bold; color: #7f8c8d; min-height: 20px; text-align: left; }
  #unit-biome-display-container, #unit-coords-display-container, #unit-exp-display-container, #research-points-display-container { font-size: 16px; font-weight: bold; text-align: left; padding: 10px; border-radius: 8px; margin-bottom: 10px; }
  #unit-biome-display-container { color: #16a085; background-color: #e8f8f5; } #unit-biome-display-container span { font-weight: normal; color: #117a65; text-transform: capitalize; }
  #unit-coords-display-container { color: #34495e; background-color: #ecf0f1; } #unit-coords-display-container span { font-weight: normal; color: #2c3e50; }
  #unit-exp-display-container { color: #e67e22; background-color: #fef5e7; } #unit-exp-display-container span { font-weight: normal; color: #d35400; }
  #research-points-display-container { color: #8e44ad; background-color: #f3eaf7; margin-bottom: 0; } /* Removed margin-bottom */
  #upgrade-info { margin-top: 10px; text-align: left; background-color: #f9ebea; padding: 15px; border-radius: 8px; border: 1px solid #f5b7b1; min-height: 50px; }
  #upgrade-info h4 { font-size: 15px; margin-top: 0; margin-bottom: 10px; color: #a93226; border-bottom: 1px solid #e6b0aa; padding-bottom: 5px;}
  #upgrade-info p { font-size: 13px; color: #555; margin-top: 5px; }
  #research-status-display { font-size: 14px; font-weight: bold; color: #27ae60; margin-top: 10px; min-height: 18px; text-align: left; padding: 5px 10px; background-color: #e8f8f5; border-radius: 6px; border: 1px solid #a3e4d7; }

  /* --- Progress Bars --- */
  .research-progress-container { width: 100%; height: 10px; /* Smaller bar */ border: 1px solid #bdc3c7; margin-top: 5px; /* Less margin */ border-radius: 5px; background-color: #ecf0f1; overflow: hidden; display: none; align-items: center; }
  .research-progress-bar { width: 0%; height: 100%; border-radius: 4px 0 0 4px; transition: width 0.3s ease-in-out; }

  /* --- Tutorial Modal Styles --- */
  #tutorial-modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
  #tutorial-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 650px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); text-align: left; }
  #tutorial-content h2 { text-align: center; color: #2c3e50; margin-top: 0; padding-bottom: 15px; border-bottom: 1px solid #eee; }
  #tutorial-steps { list-style-type: decimal; margin-left: 20px; padding-left: 15px; font-size: 15px; line-height: 1.6; color: #333; }
  #tutorial-steps li { margin-bottom: 12px; }
  #tutorial-steps code { background-color: #ecf0f1; padding: 2px 5px; border-radius: 4px; font-family: Consolas, monospace; color: #e67e22; font-weight: bold; }
  #close-tutorial-button { display: block; margin: 20px auto 0 auto; background-color: #e74c3c; padding: 10px 25px; }
  #close-tutorial-button:hover { background-color: #c0392b; }

  /* --- Unit Choice Modal Styles (REMOVED) --- */

  /* Tooltip Base Style */
  [data-tooltip] { position: relative; cursor: help; }
  [data-tooltip]::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px); background-color: rgba(50, 50, 50, 0.9); color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; pointer-events: none; }
  [data-tooltip]:hover::after { opacity: 1; visibility: visible; }

</style>
</head>
<body>
  <!-- Language Switch Button -->
  <div id="language-switcher">
      <button id="language-switch-button" title="Switch Language / Changer de langue"></button>
  </div>

  <h1>Tiny Civilization Evolved</h1>
  <div id="unit-display-bar"></div>

  <div id="game-container">
    <!-- === LEFT CONTAINER === -->
    <div id="left-container">
      <div id="colony-name-display">Colony Name</div>
      <div id="inventory">
        <h2>Inventory</h2>
        <!-- Inventory items will be generated by JS -->
      </div>
      <button id="action-button" style="display: none;">Gather Resource</button>
      <div id="resource-name"></div>
    </div>

    <!-- === MIDDLE CONTROLS === -->
    <div id="middle-controls">
         <button id="tutorial-button" data-panel-target="tutorial-modal">Tutorial</button>
         <button id="research-button" data-panel-target="tech-tree">Research</button>
         <button id="buildings-button" data-panel-target="buildings-list">Buildings</button>
         <button id="units-button" data-panel-target="units-panel">Units</button> <!-- Panel for deploying units via houses -->
         <button id="upgrade-button" data-panel-target="upgrade-info">Upgrades</button>
         <button id="logs-button" data-panel-target="logs-panel">Logs</button>
         <button id="save-button">Save Game</button>
         <button id="load-button">Load Game</button>
         <input type="file" id="load-file-input" accept=".json" style="display: none;">
    </div>

    <!-- === GRID AREA === -->
    <div id="grid-area">
        <div id="grid" class="grid"></div>
        <div id="alert-message"></div>
    </div>

    <!-- === RIGHT CONTAINER === -->
    <div id="right-panel">
       <div id="unit-biome-display-container">Biome: <span id="unit-biome">Unknown</span></div>
       <div id="unit-coords-display-container">Coords: <span id="unit-coords">(-, -)</span></div>
       <div id="unit-exp-display-container">Exp: <span id="unit-exp">0</span></div>
       <!-- Research Points moved here -->
       <div id="research-points-display-container">Research Points: <span id="research-points">0</span></div>

       <!-- Logs Panel -->
       <div id="logs-panel" class="panel">
           <h2>Event Logs</h2>
           <input type="text" id="log-search-input" placeholder="Search logs...">
           <div id="log-filter-container">
               <label><input type="checkbox" id="log-filter-checkbox"> Hide gather/cost messages</label>
           </div>
           <ul id="logs-list"></ul>
       </div>

       <!-- Other Toggleable Panels -->
       <div id="upgrade-info" class="panel">
           <h4>Unit Upgrades</h4>
           <div class="panel-content">
               <p>Select a unit to see upgrades.</p>
           </div>
       </div>
       <div id="tech-tree" class="panel">
         <h2>Tech Tree</h2>
         <div class="panel-content">
             <h3>Primitive Age</h3>
             <ul id="primitive-tech-list"></ul>
         </div>
       </div>
       <div id="buildings-list" class="panel">
           <h2>Buildings</h2>
           <div class="panel-content">
               <ul></ul>
           </div>
       </div>
       <div id="units-panel" class="panel">
           <h2>Deploy Units</h2> <!-- Changed Title -->
           <div class="panel-content">
               <ul id="units-list"> <!-- Populated by JS to deploy units via houses -->
                   <li>Build houses and research units first!</li>
               </ul>
           </div>
       </div>
       <!-- Static displays -->
       <!-- Research Points was moved up -->
       <div id="research-status-display"></div>
    </div>
  </div>

  <!-- === TUTORIAL MODAL === -->
  <div id="tutorial-modal" style="display: none;">
      <div id="tutorial-content">
          <h2 id="tutorial-title">How to Play (Basics)</h2>
          <ol id="tutorial-steps">
              <!-- Steps will be populated by JS -->
          </ol>
          <button id="close-tutorial-button">Close</button>
      </div>
  </div>

  <!-- === UNIT CHOICE MODAL (REMOVED) === -->


  <script>
    // --- Simplex Noise Library (Minimized) ---
    var SimplexNoise=(function(){var F2=0.5*(Math.sqrt(3.0)-1.0);var G2=(3.0-Math.sqrt(3.0))/6.0;var F3=1.0/3.0;var G3=1.0/6.0;var F4=(Math.sqrt(5.0)-1.0)/4.0;var G4=(5.0-Math.sqrt(5.0))/20.0;function Alea(){var s0=0;var s1=0;var s2=0;var c=1;var mash=Mash();s0=mash(' ');s1=mash(' ');s2=mash(' ');for(var i=0;i<arguments.length;i++){s0-=mash(arguments[i]);if(s0<0){s0+=1;} s1-=mash(arguments[i]);if(s1<0){s1+=1;} s2-=mash(arguments[i]);if(s2<0){s2+=1;}} mash=null;var random=function(){var t=2091639*s0+c*2.3283064365386963e-10;s0=s1;s1=s2;return s2=t-(c=t|0);};random.uint32=function(){return random()*0x100000000;};random.fract53=function(){return random()+(random()*0x200000|0)*1.1102230246251565e-16;};random.version='Alea 0.9';random.args=arguments;return random;} function Mash(){var n=0xefc8249d;var mash=function(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;} return(n>>>0)*2.3283064365386963e-10;};mash.version='Mash 0.9';return mash;} function SimplexNoise(random){if(!random)random=Math.random;this.p=new Uint8Array(256);this.perm=new Uint8Array(512);this.permMod12=new Uint8Array(512);for(var i=0;i<256;i++){this.p[i]=i;} for(i=0;i<255;i++){var r=i+~~(random()*(256-i));var aux=this.p[i];this.p[i]=this.p[r];this.p[r]=aux;} for(i=0;i<512;i++){this.perm[i]=this.p[i&255];this.permMod12[i]=this.perm[i]%12;}} SimplexNoise.prototype={grad3:new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),noise2D:function(xin,yin){var permMod12=this.permMod12;var perm=this.perm;var grad3=this.grad3;var n0=0;var n1=0;var n2=0;var s=(xin+yin)*F2;var i=Math.floor(xin+s);var j=Math.floor(yin+s);var t=(i+j)*G2;var X0=i-t;var Y0=j-t;var x0=xin-X0;var y0=yin-Y0;var i1,j1;if(x0>y0){i1=1;j1=0;}else{i1=0;j1=1;} var x1=x0-i1+G2;var y1=y0-j1+G2;var x2=x0-1.0+2.0*G2;var y2=y0-1.0+2.0*G2;var ii=i&255;var jj=j&255;var t0=0.5-x0*x0-y0*y0;if(t0>=0){var gi0=permMod12[ii+perm[jj]]*3;t0*=t0;n0=t0*t0*(grad3[gi0]*x0+grad3[gi0+1]*y0);} var t1=0.5-x1*x1-y1*y1;if(t1>=0){var gi1=permMod12[ii+i1+perm[jj+j1]]*3;t1*=t1;n1=t1*t1*(grad3[gi1]*x1+grad3[gi1+1]*y1);} var t2=0.5-x2*x2-y2*y2;if(t2>=0){var gi2=permMod12[ii+1+perm[jj+1]]*3;t2*=t2;n2=t2*t2*(grad3[gi2]*x2+grad3[gi2+1]*y2);} return 70.0*(n0+n1+n2);},};SimplexNoise.create=function(seed){if(seed){return new SimplexNoise(new Alea(seed));}else{return new SimplexNoise(Math.random);}};return SimplexNoise;})();
    // --- End Simplex Noise Library ---

    // --- DOM Element References (Cached) ---
    const DOMElements = {
        grid: document.getElementById('grid'), actionButton: document.getElementById('action-button'),
        inventoryDisplay: document.getElementById('inventory'),
        middleControls: document.getElementById('middle-controls'),
        techTree: document.getElementById('tech-tree'), buildingsList: document.getElementById('buildings-list'),
        unitsPanel: document.getElementById('units-panel'), logsPanel: document.getElementById('logs-panel'),
        upgradeInfoDisplay: document.getElementById('upgrade-info'), logsList: document.getElementById('logs-list'),
        logSearchInput: document.getElementById('log-search-input'), logFilterCheckbox: document.getElementById('log-filter-checkbox'),
        resourceNameDisplay: document.getElementById('resource-name'), researchPointsDisplay: document.getElementById('research-points'),
        researchStatusDisplay: document.getElementById('research-status-display'), colonyNameDisplay: document.getElementById('colony-name-display'),
        alertMessageElement: document.getElementById('alert-message'), unitDisplayBar: document.getElementById('unit-display-bar'),
        unitBiomeDisplay: document.getElementById('unit-biome'), unitCoordsDisplay: document.getElementById('unit-coords'),
        unitExpDisplay: document.getElementById('unit-exp'), loadFileInput: document.getElementById('load-file-input'),
        languageSwitchButton: document.getElementById('language-switch-button'),
        tutorialModal: document.getElementById('tutorial-modal'), tutorialTitle: document.getElementById('tutorial-title'),
        tutorialStepsList: document.getElementById('tutorial-steps'), closeTutorialButton: document.getElementById('close-tutorial-button'),
        primitiveTechList: document.getElementById('primitive-tech-list'), buildingsListUl: document.querySelector('#buildings-list ul'),
        unitsListUl: document.getElementById('units-list'), // Reference to units panel UL
        upgradeInfoContent: document.querySelector('#upgrade-info .panel-content'),
        saveButton: document.getElementById('save-button'), loadButton: document.getElementById('load-button'),
        // unitChoiceModal: document.getElementById('unit-choice-modal'), // REMOVED
        // unitChoiceTitle: document.getElementById('unit-choice-title'), // REMOVED
        // unitChoiceButtons: document.getElementById('unit-choice-buttons') // REMOVED
    };

    // --- Game Configuration ---
    const gameConfig = {
        gridSize: 10, viewCenterOffset: 5, revealRadiusBase: 2,
        maxLogEntries: 50, alertDuration: 3000,
        baseInventoryCapacity: { wood: 50, pebble: 50, flint: 30, wheat: 20, coal: 20, iron: 10, copper: 10, nickel: 10, zinc: 10 },
        eventChance: 0.01,
        expPerBuild: 3, expPerResearchComplete: 10, expPerEventDiscovery: 5,
        productionIntervals: { wheat: 5, coal: 7, quarry: 12 },
        noiseScales: { biome: 30.0, feature: 15.0, water: 40.0 },
        noiseThresholds: { biomeDesert: 0.3, lake: -0.3, treeForest: -0.1, flintForest: 0.0, stoneForest: 0.15 },
        desertStoneChance: 0.06,
        maxStartRegenAttempts: 10,
        units: {
            pawn: { nameKey: 'unitPawn', icon: 'P', build: ['house'], move: 1, revealRadius: 2, researchBonus: 1, upgrades: ['movement1', 'autoGather'] },
            worker: { nameKey: 'unitWorker', icon: 'W', build: ['farm', 'mine', 'quarry', 'warehouse'], move: 1, revealRadius: 2, researchBonus: 0, upgrades: ['movement1', 'autoGather'], deployableFromPanel: true, requiredTech: 'settlement' }, // Deployable via House slot
            scout: { nameKey: 'unitScout', icon: 'S', build: [], move: 3, revealRadius: 3, researchBonus: 0, upgrades: ['movement1', 'autoGather'], deployableFromPanel: true, requiredTech: 'exploration' } // Deployable via House slot
        },
        buildings: {
            // House now implicitly provides a slot, tracked via tileData.unitDeployed
            house: { nameKey: 'buildingHouse', cost: { wood: 10, pebble: 5 }, provides: { }, unlockedBy: 'settlement' },
            farm: { nameKey: 'buildingFarm', cost: { wood: 3 }, produces: { resource: 'wheat', interval: 'wheat' }, requires: 'worker', unlockedBy: 'agriculture' },
            mine: { nameKey: 'buildingMine', cost: { pebble: 5, wood: 2 }, produces: { resource: 'coal', interval: 'coal' }, requires: 'worker', unlockedBy: 'mining' },
            quarry: { nameKey: 'buildingQuarry', cost: { pebble: 15, wood: 5 }, produces: { resource: ['iron', 'copper', 'nickel', 'zinc'], interval: 'quarry' }, requires: 'worker', unlockedBy: 'masonry' },
            warehouse: { nameKey: 'buildingWarehouse', cost: { wood: 15, pebble: 10 }, provides: { capacityBonus: 50 }, unlockedBy: 'storage' }
        },
        tech: {
            // Note: 'unlocks' doesn't list units directly anymore, logic handles it via deployableFromPanel/requiredTech
            settlement: { nameKey: 'researchSettlement', cost: 15, unlocks: ['house'], requires: [], age: 'primitive', color: '#8e44ad' },
            agriculture: { nameKey: 'researchAgriculture', cost: 10, unlocks: ['farm'], requires: [], age: 'primitive', color: '#aed581' },
            mining: { nameKey: 'researchMining', cost: 15, unlocks: ['mine'], requires: ['agriculture'], age: 'primitive', color: '#7f8c8d' },
            masonry: { nameKey: 'researchMasonry', cost: 20, unlocks: ['quarry'], requires: ['mining'], age: 'primitive', color: '#bcaaa4' },
            storage: { nameKey: 'researchStorage', cost: 25, unlocks: ['warehouse'], requires: ['masonry'], age: 'primitive', color: '#7f8c8d' },
            exploration: { nameKey: 'researchExploration', cost: 15, unlocks: [], requires: ['settlement'], age: 'primitive', color: '#1abc9c'} // Just enables scout deployment
        },
        upgrades: {
            movement1: { nameKey: 'upgradeMovement1', cost: 10, effect: { moveBonus: 1 }, maxLevel: 1 },
            autoGather: { nameKey: 'upgradeAutoGather', cost: 15, effect: { autoGather: true }, maxLevel: 1 },
        },
        resources: [
             { id: 'wood', nameKey: 'wood' }, { id: 'pebble', nameKey: 'pebble' }, { id: 'flint', nameKey: 'flint' },
             { id: 'wheat', nameKey: 'wheat' }, { id: 'coal', nameKey: 'coal' },
             { id: 'iron', nameKey: 'iron' }, { id: 'copper', nameKey: 'copper' }, { id: 'nickel', nameKey: 'nickel' }, { id: 'zinc', nameKey: 'zinc' }
        ]
    };

    // --- Game State Variables ---
    let gameState = {
        units: [], nextUnitId: 0, selectedUnitId: null,
        inventory: {}, inventoryCapacity: {},
        researchPoints: 0, activeResearch: null, completedTech: new Set(),
        selectedBuilding: null,
        unitToDeploy: null, // Stores type ('worker', 'scout') when selecting target house
        productionProgress: { wheat: 0, coal: 0, quarry: 0 },
        colonyName: "New Colony", currentLanguage: 'en', eventLogs: [],
        viewOffsetX: 0, viewOffsetY: 0, worldData: {}, revealedTiles: new Set(),
        highlightEnabled: false, alertTimeout: null, gameInitialized: false
    };

    // --- Noise Generators ---
    let noise = { biome: null, feature: null, water: null };

    // --- Translations ---
    const translations = {
        en: {
            gameTitle: "Tiny Civilization Evolved", switchLanguageTooltip: "Switch Language / Changer de langue", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colony:",
            inventoryTitle: "Inventory", tutorialButton: "Tutorial", researchButton: "Research", buildingsButton: "Buildings", unitsButton: "Units", upgradeButton: "Upgrades", logsButton: "Logs", saveButton: "Save Game", loadButton: "Load Game",
            wood: "Wood", pebble: "Pebbles", flint: "Flint", wheat: "Wheat", coal: "Coal", iron: "Iron", copper: "Copper", nickel: "Nickel", zinc: "Zinc",
            gatherButton: "Gather Resource", noUnitSelected: "No unit selected", onTile: "On Tile:", emptyTile: "Empty", unknownTile: "Unknown",
            researchPointsLabel: "Research Points:", researchStatusResearching: "⏳ Researching", researchStatusComplete: "✅", researchStatusInitial: "Begin your journey! Select units and move them.",
            water: "Water", sand: "Sand", grass: "Grass", forest: "Forest", desert: "Desert",
            tileResourceTree: "Tree", tileResourceStone: "Stone (Pebbles)", tileResourceFlint: "Flint",
            researchPanelTitle: "Tech Tree", primitiveAge: "Primitive Age",
            researchSettlement: "Settlement", researchSettlementDesc: "Unlocks Houses & Worker deployment via Houses.", // Updated Desc
            researchAgriculture: "Agriculture", researchAgricultureDesc: "Unlocks Farms (Wheat production).",
            researchMining: "Mining", researchMiningDesc: "Unlocks Mines (Coal production). Requires Agriculture.",
            researchMasonry: "Masonry", researchMasonryDesc: "Unlocks Quarries (Metal production). Requires Mining.",
            researchStorage: "Storage", researchStorageDesc: "Unlocks Warehouses (+50 Resource Capacity). Requires Masonry.",
            researchExploration: "Exploration", researchExplorationDesc: "Enables Scout deployment via Houses. Requires Settlement.", // Updated Desc
            buildingsPanelTitle: "Buildings",
            buildingHouse: "House", buildingHouseDesc: "Provides one slot to deploy a Worker or Scout later via the Units panel.", // Updated Desc
            buildingFarm: "Farm", buildingFarmDesc: "Requires Worker. Produces Wheat over time.",
            buildingMine: "Mine", buildingMineDesc: "Requires Worker. Produces Coal over time.",
            buildingQuarry: "Quarry", buildingQuarryDesc: "Requires Worker. Slowly produces Metals.",
            buildingWarehouse: "Warehouse", buildingWarehouseDesc: "Increases Resource Capacity by 50.",
            noBuildingsAvailable: "No buildings available to build yet. Research technology first.",
            unitsPanelTitle: "Deploy Units", // Updated Title
            deployUnitButton: "Deploy {0}", // Key for panel deployment
            noUnitsAvailablePanel: "Research units first!", // Updated key (when houses exist but tech doesn't)
            noUnusedHouses: "No unused houses available to deploy units.", // New Key
            unitPawn: "Pawn", unitWorker: "Worker", unitScout: "Scout",
            deployUnitMax: "Max",
            logsPanelTitle: "Event Logs", logSearchPlaceholder: "Search logs...", logFilterLabel: "Hide gather/cost messages",
            alertWelcome: "Welcome to {0}!", alertGameStarted: "Game started for colony: {0}",
            alertGathered: "Gathered {1} {0}!",
            alertGatheredQuarry: "Quarry produced 1 {0}!", alertGatheredEvent: "Found a cache: +{1} {0}!",
            alertStorageFull: "Storage full for {0}!",
            alertNotEnoughResources: "Not enough resources for {0}!", alertCannotBuildNonEmpty: "Cannot build: Tile is not empty!", alertCannotBuildExists: "Cannot build: {0} already exists here!", alertCannotBuildOnResource: "Cannot build on a {0}!", alertCannotBuildOnTerrain: "Cannot build on {0}!", alertBuildSelected: "Selected: {0}. Click an empty tile to build.", alertBuildingBuilt: "{0} built!", alertSelectUnitToBuild: "No unit selected to perform build action.", alertUnitCannotBuild: "{0} cannot build {1}s!",
            alertResearchStarted: "Started researching {0}.", alertAlreadyResearching: "Already researching: {0}!", alertResearchComplete: "{0} research complete!",
            alertUnitDeployed: "{0} deployed!",
            alertNoSpaceForUnit: "No available space near the selected House to deploy {0}!", // Updated context
            alertSelectUnusedHouse: "Select an unused House (highlighted) to deploy the unit.", // New Alert
            alertInvalidHouseTarget: "Invalid target. Please click an unused House.", // New Alert
            // alertNoSelectedUnitForDeploy: "Select a unit to deploy near.", // REMOVED
            alertGameSaved: "Game Saved!", alertSaveError: "Error saving game. See console for details.", alertLoadSuccess: "Game loaded successfully for colony: {0}!", alertLoadError: "Error loading game: {0}.", alertLoadInvalidFormat: "Invalid save file format.", alertReadFileError: "Error reading file.", alertSaveVersionMismatch: "Save is from an older version and may not load correctly.",
            alertUnitMoveOccupied: "Cannot move unit: Tile is occupied!", alertMoveInvalid: "Cannot move there.", alertSelectedUnit: "Selected Unit: {0} ({1})",
            promptColonyName: "Welcome to Tiny Civilization Evolved! Please name your colony:", defaultColonyName: "New Settlement",
            logGameSaved: "Game state saved.", logNewGame: "New game started for colony:",
            logGainedExp: "{0} ({1}) gained {2} Exp for building {3}.", logGainedExpResearch: "{0} units gained {1} Exp for completing {2}.", logGainedExpEvent: "Unit {0} gained {1} Exp for discovering cache.",
            logCapacityIncreased: "Total capacity for {0} increased to {1}.",
            logInvalidStartRegen: "Invalid start position (surrounded by water). Regenerating map...", logInvalidStartGiveUp: "Could not find valid start position after {0} attempts. Starting anyway.",
            unitExpLabel: "Exp:", upgradeSectionTitle: "Unit Upgrades", upgradeInfoSelectUnit: "Select a unit to see upgrades.",
            upgradeMovement1: "Movement I", upgradeMovement1Desc: "Allows moving +1 tile away (Cost: {0} Exp).",
            upgradeAutoGather: "Auto-Gather", upgradeAutoGatherDesc: "Automatically gathers resources on tile arrival (Cost: {0} Exp).",
            upgradeNoUpgradesAvailable: "No upgrades available or affordable for this unit.",
            alertNotEnoughExp: "Not enough Exp for {0}!", alertUpgradeSuccess: "{0} purchased for unit {1}!", alertUpgradeMaxLevel: "Upgrade {0} is already at max level.",
            unusedHouseTarget: "Target", // Added to house title when targetting
            // Tutorial (Updated Flow)
            tutorialTitle: "How to Play (Basics)",
            tutorialStep1: "Select your starting <code>Pawn</code> (blue 'P').",
            tutorialStep2: "Move by clicking adjacent land tiles.",
            tutorialStep3: "Move onto <code>Tree</code> (🌳) or <code>Stone</code> and click <code>Gather Resource</code>.",
            tutorialStep4: "Gather Wood/Pebbles. Note <code>Inventory</code> limits.",
            tutorialStep5: "Click <code>Research</code> and research <code>Settlement</code>.",
            tutorialStep6: "Once done, click <code>Buildings</code>, select <code>House</code>.",
            tutorialStep7: "Click an empty <code>Grass</code> tile near your Pawn to build.",
            tutorialStep8: "A House provides one slot to deploy a unit later.", // New Flow
            tutorialStep9: "Research <code>Exploration</code> to enable Scout deployment.", // New Flow
            tutorialStep10: "Click the <code>Units</code> button (middle column).", // New Flow
            tutorialStep11: "If tech is researched and an unused House exists, click <code>Deploy Worker/Scout</code>.", // New Flow
            tutorialStep12: "Unused <code>Houses</code> will highlight. Click a highlighted House to deploy the unit nearby.", // New Flow
            tutorialStep13: "Each House can deploy only one unit.", // New Flow
            tutorialStep14: "Research <code>Agriculture</code> for Farms (built by Workers).", // Renumbered
            tutorialStep15: "Research <code>Storage</code> for <code>Warehouses</code> to increase capacity.", // Renumbered
            tutorialStep16: "Units gain <code>Exp</code>. Click <code>Upgrades</code> (right) to spend Exp.", // Renumbered
            closeButton: "Close",
        },
        fr: { /* ... Corresponding French keys - NEED UPDATING FOR NEW FEATURES ... */
            gameTitle: "Mini Civilisation Évoluée", switchLanguageTooltip: "Changer de langue / Switch Language", switchToFrench: "Français", switchToEnglish: "English", colonyLabel: "Colonie :",
            inventoryTitle: "Inventaire", tutorialButton: "Tutoriel", researchButton: "Recherche", buildingsButton: "Bâtiments", unitsButton: "Unités", upgradeButton: "Améliorations", logsButton: "Journaux", saveButton: "Sauvegarder", loadButton: "Charger",
            wood: "Bois", pebble: "Cailloux", flint: "Silex", wheat: "Blé", coal: "Charbon", iron: "Fer", copper: "Cuivre", nickel: "Nickel", zinc: "Zinc",
            gatherButton: "Récolter Ressource", noUnitSelected: "Aucune unité sélectionnée", onTile: "Sur la case :", emptyTile: "Vide", unknownTile: "Inconnu",
            researchPointsLabel: "Points de Recherche :", researchStatusResearching: "⏳ Recherche en cours", researchStatusComplete: "✅", researchStatusInitial: "Commencez votre voyage ! Sélectionnez les unités et déplacez-les.",
            water: "Eau", sand: "Sable", grass: "Herbe", forest: "Forêt", desert: "Désert",
            tileResourceTree: "Arbre", tileResourceStone: "Roche (Cailloux)", tileResourceFlint: "Silex",
            researchPanelTitle: "Arbre Technologique", primitiveAge: "Âge Primitif",
            researchSettlement: "Colonisation", researchSettlementDesc: "Débloque Maisons & déploiement Ouvriers via Maisons.", // Updated fr
            researchAgriculture: "Agriculture", researchAgricultureDesc: "Débloque Fermes (production Blé).",
            researchMining: "Minage", researchMiningDesc: "Débloque Mines (production Charbon). Nécessite Agriculture.",
            researchMasonry: "Maçonnerie", researchMasonryDesc: "Débloque Carrières (production Métal). Nécessite Minage.",
            researchStorage: "Stockage", researchStorageDesc: "Débloque Entrepôts (+50 Capacité Ressource). Nécessite Maçonnerie.",
            researchExploration: "Exploration", researchExplorationDesc: "Permet le déploiement d'Éclaireurs via Maisons. Nécessite Colonisation.", // Updated fr
            buildingsPanelTitle: "Bâtiments",
            buildingHouse: "Maison", buildingHouseDesc: "Fournit un emplacement pour déployer un Ouvrier ou Éclaireur plus tard via le panneau Unités.", // Updated fr
            buildingFarm: "Ferme", buildingFarmDesc: "Nécessite Ouvrier. Produit du Blé.",
            buildingMine: "Mine", buildingMineDesc: "Nécessite Ouvrier. Produit du Charbon.",
            buildingQuarry: "Carrière", buildingQuarryDesc: "Nécessite Ouvrier. Produit des Métaux.",
            buildingWarehouse: "Entrepôt", buildingWarehouseDesc: "Augmente la Capacité de Ressources de 50.",
            noBuildingsAvailable: "Aucun bâtiment à construire. Recherchez d'abord.",
            unitsPanelTitle: "Déployer Unités", // Updated fr
            deployUnitButton: "Déployer {0}", // Added fr
            noUnitsAvailablePanel: "Recherchez des unités d'abord !", // Updated fr
            noUnusedHouses: "Aucune maison inutilisée disponible pour déployer des unités.", // New Key fr
            unitPawn: "Colon", unitWorker: "Ouvrier", unitScout: "Éclaireur",
            deployUnitMax: "Max",
            logsPanelTitle: "Journal des Événements", logSearchPlaceholder: "Rechercher...", logFilterLabel: "Masquer messages récolte/coût",
            alertWelcome: "Bienvenue à {0} !", alertGameStarted: "Partie démarrée pour : {0}",
            alertGathered: "Récolté {1} {0} !",
            alertGatheredQuarry: "Carrière a produit 1 {0} !", alertGatheredEvent: "Cache trouvée : +{1} {0}!",
            alertStorageFull: "Stockage plein pour {0} !",
            alertNotEnoughResources: "Pas assez de ressources pour {0} !", alertCannotBuildNonEmpty: "Construction impossible : Case non vide !", alertCannotBuildExists: "{0} existe déjà ici !", alertCannotBuildOnResource: "Construction impossible sur un(e) {0} !", alertCannotBuildOnTerrain: "Construction impossible sur {0} !", alertBuildSelected: "Sélectionné : {0}. Cliquez une case vide.", alertBuildingBuilt: "{0} construit(e) !", alertSelectUnitToBuild: "Pas d'unité sélectionnée pour construire.", alertUnitCannotBuild: "{0} ne peut pas construire de {1}s !",
            alertResearchStarted: "Recherche commencée pour {0}.", alertAlreadyResearching: "Recherche déjà en cours : {0} !", alertResearchComplete: "Recherche {0} terminée !",
            alertUnitDeployed: "{0} déployé !",
            alertNoSpaceForUnit: "Pas d'espace près de la Maison sélectionnée pour déployer {0} !", // Updated fr
            alertSelectUnusedHouse: "Sélectionnez une Maison inutilisée (surlignée) pour déployer l'unité.", // New Alert fr
            alertInvalidHouseTarget: "Cible invalide. Veuillez cliquer sur une Maison inutilisée.", // New Alert fr
            alertGameSaved: "Partie Sauvegardée !", alertSaveError: "Erreur sauvegarde.", alertLoadSuccess: "Partie chargée : {0} !", alertLoadError: "Erreur chargement : {0}.", alertLoadInvalidFormat: "Format sauvegarde invalide.", alertReadFileError: "Erreur lecture fichier.", alertSaveVersionMismatch: "Sauvegarde d'une ancienne version, peut mal charger.",
            alertUnitMoveOccupied: "Déplacement impossible : Case occupée !", alertMoveInvalid: "Déplacement impossible.", alertSelectedUnit: "Unité sélectionnée : {0} ({1})",
            promptColonyName: "Bienvenue ! Nommez votre colonie :", defaultColonyName: "Nouvelle Colonie",
            logGameSaved: "État sauvegardé.", logNewGame: "Nouvelle partie démarrée :",
            logGainedExp: "{0} ({1}) gagne {2} Exp pour construction de {3}.", logGainedExpResearch: "Unités {0} gagnent {1} Exp pour recherche {2}.", logGainedExpEvent: "Unité {0} gagne {1} Exp pour découverte de cache.",
            logCapacityIncreased: "Capacité totale pour {0} augmentée à {1}.",
            logInvalidStartRegen: "Position départ invalide. Régénération...", logInvalidStartGiveUp: "Position départ non valide après {0} essais.",
            unitExpLabel: "Exp :", upgradeSectionTitle: "Améliorations", upgradeInfoSelectUnit: "Sélectionnez une unité.",
            upgradeMovement1: "Mouvement I", upgradeMovement1Desc: "Permet de se déplacer +1 case (Coût : {0} Exp).",
            upgradeAutoGather: "Récolte Auto", upgradeAutoGatherDesc: "Récolte auto à l'arrivée (Coût : {0} Exp).",
            upgradeNoUpgradesAvailable: "Aucune amélioration disponible/abordable.",
            alertNotEnoughExp: "Pas assez d'Exp pour {0} !", alertUpgradeSuccess: "{0} acheté pour unité {1} !", alertUpgradeMaxLevel: "Amélioration {0} au niveau max.",
            unusedHouseTarget: "Cible", // Added fr
             // Tutorial fr (Updated Flow)
            tutorialTitle: "Comment Jouer (Bases)",
            tutorialStep1: "Sélectionnez votre <code>Colon</code> (bleu 'C').",
            tutorialStep2: "Déplacez-vous sur une case terrestre adjacente vide.",
            tutorialStep3: "Allez sur <code>Arbre</code>/<code>Roche</code> et cliquez <code>Récolter Ressource</code>.",
            tutorialStep4: "Récoltez Bois/Cailloux. Notez les limites d'<code>Inventaire</code>.",
            tutorialStep5: "Cliquez <code>Recherche</code> et recherchez <code>Colonisation</code>.",
            tutorialStep6: "Puis, cliquez <code>Bâtiments</code>, sélectionnez <code>Maison</code>.",
            tutorialStep7: "Cliquez sur une case <code>Herbe</code> vide près du Colon.",
            tutorialStep8: "Une Maison fournit un emplacement pour déployer une unité plus tard.", // New Flow fr
            tutorialStep9: "Recherchez <code>Exploration</code> pour activer le déploiement d'Éclaireurs.", // New Flow fr
            tutorialStep10: "Cliquez sur le bouton <code>Unités</code> (colonne centrale).", // New Flow fr
            tutorialStep11: "Si la tech est recherchée et une Maison inutilisée existe, cliquez <code>Déployer Ouvrier/Éclaireur</code>.", // New Flow fr
            tutorialStep12: "Les <code>Maisons</code> inutilisées seront surlignées. Cliquez une Maison surlignée pour déployer l'unité à proximité.", // New Flow fr
            tutorialStep13: "Chaque Maison ne peut déployer qu'une seule unité.", // New Flow fr
            tutorialStep14: "Recherchez <code>Agriculture</code> pour les Fermes (construites par Ouvriers).", // Renumbered fr
            tutorialStep15: "Recherchez <code>Stockage</code> pour les <code>Entrepôts</code> (+ capacité).", // Renumbered fr
            tutorialStep16: "Unités gagnent <code>Exp</code>. Cliquez <code>Améliorations</code> (droite) pour dépenser l'Exp.", // Renumbered fr
            closeButton: "Fermer",
        }
    };

    // --- Helper Functions ---
    const getLang = () => translations[gameState.currentLanguage] || translations.en;
    const getLangMsg = (key, args = []) => {
        let msg = getLang()[key] || key;
        args.forEach((arg, index) => {
            const translatedArg = getLang()[arg] !== undefined ? getLang()[arg] : arg;
            msg = msg.replace(`{${index}}`, translatedArg);
        });
        return msg;
    };
    const getFormattedTime = () => { const n = new Date(); return `${n.getHours().toString().padStart(2, '0')}:${n.getMinutes().toString().padStart(2, '0')}`; };

    function showAlert(messageKey, duration = gameConfig.alertDuration, logIt = true, args = []) {
        clearTimeout(gameState.alertTimeout);
        const message = getLangMsg(messageKey, args);

        if (logIt) {
            const timeString = getFormattedTime();
            const storedArgs = args.map(arg => (typeof arg === 'number' || typeof arg === 'boolean' || arg === null) ? arg : String(arg));
            gameState.eventLogs.push({ time: timeString, messageKey: messageKey, args: storedArgs, rendered: message });
            if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift();
            if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay();
        }

        DOMElements.alertMessageElement.textContent = message;
        DOMElements.alertMessageElement.style.display = 'block';
        void DOMElements.alertMessageElement.offsetWidth; // Trigger reflow for transition
        DOMElements.alertMessageElement.classList.add('show');

        gameState.alertTimeout = setTimeout(() => {
            DOMElements.alertMessageElement.classList.remove('show');
             DOMElements.alertMessageElement.addEventListener('transitionend', function handleTransitionEnd() {
                 if (! DOMElements.alertMessageElement.classList.contains('show')) {
                      DOMElements.alertMessageElement.style.display = 'none';
                 }
                 DOMElements.alertMessageElement.removeEventListener('transitionend', handleTransitionEnd);
             }, {once: true});
        }, duration);
    }

    function updateLogsDisplay() {
        DOMElements.logsList.innerHTML = '';
        const searchTerm = DOMElements.logSearchInput.value.toLowerCase();
        const hideFiltered = DOMElements.logFilterCheckbox.checked;
        const filteredLogs = gameState.eventLogs.filter(log => {
            const currentRendered = log.rendered || getLangMsg(log.messageKey, log.args);
            const messageLower = currentRendered.toLowerCase();
            const searchMatch = messageLower.includes(searchTerm);
            if (!searchMatch) return false;

            if (hideFiltered) {
                const isGather = log.messageKey === 'alertGathered' || log.messageKey === 'alertGatheredQuarry' || log.messageKey === 'alertGatheredEvent';
                const isCost = log.messageKey === 'alertNotEnoughResources';
                const isExp = log.messageKey === 'logGainedExp' || log.messageKey === 'logGainedExpResearch' || log.messageKey === 'logGainedExpEvent';
                const isStorage = log.messageKey === 'alertStorageFull';
                if (isGather || isCost || isExp || isStorage) return false;
            }
            return true;
        });

        const fragment = document.createDocumentFragment();
        for (let i = filteredLogs.length - 1; i >= 0; i--) {
            const log = filteredLogs[i];
            const logEntry = document.createElement('li');
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${log.time}]`;
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(document.createTextNode(` ${log.rendered || getLangMsg(log.messageKey, log.args)}`));
            fragment.appendChild(logEntry);
        }
        DOMElements.logsList.appendChild(fragment);
    }

    function initializeGridDOM() {
        const fragment = document.createDocumentFragment();
        for (let gy = 0; gy < gameConfig.gridSize; gy++) {
            for (let gx = 0; gx < gameConfig.gridSize; gx++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.gridX = gx;
                tile.dataset.gridY = gy;
                fragment.appendChild(tile);
            }
        }
        DOMElements.grid.innerHTML = '';
        DOMElements.grid.appendChild(fragment);
    }

    // --- World Generation & Visibility ---
    function getTileData(worldX, worldY) { return gameState.worldData[worldY]?.[worldX]; }
    function setTileData(worldX, worldY, data) { if (!gameState.worldData[worldY]) gameState.worldData[worldY] = {}; gameState.worldData[worldY][worldX] = data; }

    function generateTileContent(worldX, worldY) {
        const coordString = `${worldX},${worldY}`;
        if (getTileData(worldX, worldY)) { gameState.revealedTiles.add(coordString); return getTileData(worldX, worldY); }
        gameState.revealedTiles.add(coordString);

        let type = 'unknown';
        let biome = 'forest';

        const biomeNoiseVal = noise.biome.noise2D(worldX / gameConfig.noiseScales.biome, worldY / gameConfig.noiseScales.biome);
        if (biomeNoiseVal >= gameConfig.noiseThresholds.biomeDesert) { biome = 'desert'; }

        const waterNoiseVal = noise.water.noise2D(worldX / gameConfig.noiseScales.water, worldY / gameConfig.noiseScales.water);
        if (waterNoiseVal < gameConfig.noiseThresholds.lake) {
            type = 'water';
        } else {
            const featureNoiseVal = noise.feature.noise2D(worldX / gameConfig.noiseScales.feature, worldY / gameConfig.noiseScales.feature);
            if (biome === 'forest') {
                if (featureNoiseVal < gameConfig.noiseThresholds.treeForest) type = 'tree';
                else if (featureNoiseVal < gameConfig.noiseThresholds.flintForest) type = 'flint';
                else if (featureNoiseVal < gameConfig.noiseThresholds.stoneForest) type = 'stone';
                else type = 'grass';
            } else {
                type = 'sand';
                if (Math.random() < gameConfig.desertStoneChance) type = 'stone';
            }

            let isNearWater = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const neighborWaterNoise = noise.water.noise2D((worldX + dx) / gameConfig.noiseScales.water, (worldY + dy) / gameConfig.noiseScales.water);
                    if (neighborWaterNoise < gameConfig.noiseThresholds.lake) {
                        isNearWater = true; break;
                    }
                }
                if (isNearWater) break;
            }
            if (isNearWater && type !== 'water') { type = 'sand'; }
        }

        // Ensure starting area is clear
        if (worldX === 5 && worldY === 5) { type = 'grass'; biome = 'forest'; }
        else if (Math.abs(worldX - 5) <= 1 && Math.abs(worldY - 5) <= 1) {
             if (type === 'water') type = 'grass'; // Force land near start
             biome = 'forest';
        }


        // Data object now includes unitDeployed for potential houses
        const data = { type: type, building: null, biome: biome, unitDeployed: null };
        setTileData(worldX, worldY, data);
        return data;
    }

    function revealArea(centerX, centerY, radius) {
        let newlyRevealed = false;
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                 if (Math.sqrt(dx * dx + dy * dy) > radius) continue;

                const wx = centerX + dx;
                const wy = centerY + dy;
                const coordString = `${wx},${wy}`;
                if (!gameState.revealedTiles.has(coordString)) {
                     generateTileContent(wx, wy); // Generates tile data if it doesn't exist
                     newlyRevealed = true;
                }
            }
        }
        return newlyRevealed;
    }

    // --- Update Functions ---
     function updateGrid() {
         const tiles = DOMElements.grid.querySelectorAll('.tile');
         const lang = getLang();

         // Clear existing state first
         tiles.forEach(tile => {
             const existingMarker = tile.querySelector('.unit-marker');
             if (existingMarker) existingMarker.remove();
             tile.className = 'tile'; // Reset classes
             tile.textContent = '';
             tile.title = '';
             tile.classList.remove('highlight', 'unknown', 'highlight-house-target'); // Clear highlights
         });

         // Process revealed tiles
         tiles.forEach(tile => {
             const gx = parseInt(tile.dataset.gridX);
             const gy = parseInt(tile.dataset.gridY);
             const worldX = gx + gameState.viewOffsetX;
             const worldY = gy + gameState.viewOffsetY;
             const coordString = `${worldX},${worldY}`;
             const isRevealed = gameState.revealedTiles.has(coordString);

             if (!isRevealed) {
                 tile.classList.add('unknown');
             } else {
                 const data = getTileData(worldX, worldY);
                 let tileTitle = lang.emptyTile;

                 if (data) {
                     tile.classList.add(data.type);
                     tile.classList.add(`biome-${data.biome}`);

                     if (data.building) {
                         const buildingInfo = gameConfig.buildings[data.building];
                         tile.classList.add(data.building);
                         tile.textContent = (buildingInfo?.nameKey ? lang[buildingInfo.nameKey] : data.building).substring(0, 4).toUpperCase();
                         tileTitle = lang[buildingInfo?.nameKey] || data.building;

                         // Highlight unused houses if selecting target
                         if (gameState.unitToDeploy && data.building === 'house' && data.unitDeployed === false) {
                             tile.classList.add('highlight-house-target');
                             tile.classList.add('highlight'); // Optional general highlight too
                             tileTitle += ` (${lang.unusedHouseTarget || 'Target'})`; // Add indicator to title
                         } else if (data.building === 'house' && data.unitDeployed === true) {
                              // Optional: Style for used houses (e.g., slightly faded)
                              // tile.style.opacity = '0.8';
                         }

                     } else if (data.type === 'tree') { tile.textContent = '🌳'; tileTitle = lang.tileResourceTree; }
                     else if (data.type === 'stone') { tileTitle = lang.tileResourceStone; }
                     else if (data.type === 'flint') { tileTitle = lang.tileResourceFlint; }
                     else if (data.type === 'water') { tileTitle = lang.water; }
                     else if (data.type === 'sand') { tileTitle = lang.sand; }
                     else if (data.type === 'grass') { tileTitle = lang.grass; }
                     else { tileTitle = lang.emptyTile; }

                     tile.title = tileTitle; // Set final title
                 } else {
                      tile.classList.add('unknown');
                      console.warn(`Tile data missing for revealed tile at ${worldX}, ${worldY}`);
                 }
             }
         });

         // Place unit markers
         gameState.units.forEach(unit => {
             const unitGridX = unit.worldX - gameState.viewOffsetX;
             const unitGridY = unit.worldY - gameState.viewOffsetY;

             if (unitGridX >= 0 && unitGridX < gameConfig.gridSize && unitGridY >= 0 && unitGridY < gameConfig.gridSize) {
                 const tile = DOMElements.grid.querySelector(`.tile[data-grid-x="${unitGridX}"][data-grid-y="${unitGridY}"]`);
                 if (tile && !tile.classList.contains('unknown')) {
                     const unitInfo = gameConfig.units[unit.type];
                     const marker = document.createElement('div');
                     marker.className = `unit-marker ${unit.type}`;
                     marker.textContent = unitInfo?.icon || unit.type.charAt(0).toUpperCase();
                     const translatedUnitType = lang[unitInfo?.nameKey] || unit.type;
                     if (unit.id === gameState.selectedUnitId) {
                         marker.classList.add('selected');
                     }
                     tile.appendChild(marker);
                     // Append unit info to existing tile title
                     if (tile.title !== lang.emptyTile && !tile.title.startsWith(translatedUnitType)) {
                         tile.title = `${translatedUnitType} (${unit.id}) - ${tile.title}`;
                     } else if (!tile.title.startsWith(translatedUnitType)) {
                         tile.title = `${translatedUnitType} (${unit.id})`;
                     }
                 }
             }
         });

         // Highlight movement for selected unit (only if not selecting a house target)
         const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
         if (gameState.highlightEnabled && selectedUnit && !gameState.unitToDeploy) { // Check we're not deploying
             const unitInfo = gameConfig.units[selectedUnit.type];
             const unitGridX = selectedUnit.worldX - gameState.viewOffsetX;
             const unitGridY = selectedUnit.worldY - gameState.viewOffsetY;

              if (unitGridX >= 0 && unitGridX < gameConfig.gridSize && unitGridY >= 0 && unitGridY < gameConfig.gridSize) {
                  let maxMove = unitInfo?.move || 1;
                  if (selectedUnit.upgrades?.movement1) maxMove += gameConfig.upgrades.movement1.effect.moveBonus;

                  tiles.forEach(tile => {
                     const targetGridX = parseInt(tile.dataset.gridX);
                     const targetGridY = parseInt(tile.dataset.gridY);
                     const targetWorldX = targetGridX + gameState.viewOffsetX;
                     const targetWorldY = targetGridY + gameState.viewOffsetY;
                     const dist = Math.abs(targetGridX - unitGridX) + Math.abs(targetGridY - unitGridY);

                     if (dist > 0 && dist <= maxMove && !tile.classList.contains('unknown')) {
                          const targetData = getTileData(targetWorldX, targetWorldY);
                          const targetOccupied = gameState.units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY);
                          // Don't highlight if it's already a house target highlight
                          if (!targetOccupied && targetData?.type !== 'water' && !tile.classList.contains('highlight-house-target')) {
                              tile.classList.add('highlight');
                          }
                      }
                  });
              }
         }
         checkResource();
     }

    function updateInventoryDisplay() {
        const fragment = document.createDocumentFragment();
        const lang = getLang();
        const title = DOMElements.inventoryDisplay.querySelector('h2');
        DOMElements.inventoryDisplay.innerHTML = '';
        DOMElements.inventoryDisplay.appendChild(title);

        gameConfig.resources.forEach(resInfo => {
            const p = document.createElement('p');
            const currentAmount = gameState.inventory[resInfo.id] || 0;
            const capacity = gameState.inventoryCapacity[resInfo.id] || 0;
            p.innerHTML = `${lang[resInfo.nameKey] || resInfo.id}: <span id="${resInfo.id}-count">${currentAmount}</span> / ${capacity}`;
            fragment.appendChild(p);
        });
        DOMElements.inventoryDisplay.appendChild(fragment);
    }

    function updateResource(resourceId, amount) {
        const currentAmount = gameState.inventory[resourceId] || 0;
        const capacity = gameState.inventoryCapacity[resourceId] || 0;
        const newAmount = Math.max(0, currentAmount + amount);

        if (amount > 0 && newAmount > capacity) {
             gameState.inventory[resourceId] = capacity;
             if (currentAmount < capacity) {
                 showAlert('alertStorageFull', 2000, true, [resourceId]);
             }
             return false;
        } else if (amount < 0 && newAmount < 0) {
             console.warn(`Attempted to spend more ${resourceId} than available.`);
             return false;
        } else {
            gameState.inventory[resourceId] = newAmount;
            updateInventoryDisplay();
            return true;
        }
    }

    function canAfford(cost) {
        return Object.entries(cost).every(([resourceId, amount]) => (gameState.inventory[resourceId] || 0) >= amount);
    }

    function spendResources(cost) {
        if (!canAfford(cost)) return false;
        Object.entries(cost).forEach(([resourceId, amount]) => {
            updateResource(resourceId, -amount);
        });
        return true;
    }

    function updateResearchPointsDisplay() { DOMElements.researchPointsDisplay.textContent = gameState.researchPoints; }

    function updateUnitInfoDisplay() {
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        const lang = getLang();

        if (selectedUnit) {
            DOMElements.unitCoordsDisplay.textContent = `(${selectedUnit.worldX}, ${selectedUnit.worldY})`;
            const tileData = getTileData(selectedUnit.worldX, selectedUnit.worldY);
            DOMElements.unitBiomeDisplay.textContent = tileData ? (lang[tileData.biome] || tileData.biome) : lang.unknownTile;
            DOMElements.unitExpDisplay.textContent = selectedUnit.exp || 0;
        } else {
            DOMElements.unitCoordsDisplay.textContent = `(-, -)`;
            DOMElements.unitBiomeDisplay.textContent = lang.unknownTile;
            DOMElements.unitExpDisplay.textContent = '0';
        }

        DOMElements.upgradeInfoContent.innerHTML = '';
        const upgradeTitle = document.createElement('h4');
        upgradeTitle.textContent = lang.upgradeSectionTitle;
        DOMElements.upgradeInfoContent.appendChild(upgradeTitle);

        if (selectedUnit) {
            const unitConf = gameConfig.units[selectedUnit.type];
            let upgradesAdded = 0;

            (unitConf.upgrades || []).forEach(upgradeId => {
                const upgradeConf = gameConfig.upgrades[upgradeId];
                if (!upgradeConf) return;

                const currentLevel = selectedUnit.upgrades?.[upgradeId] || 0;

                if (currentLevel < upgradeConf.maxLevel) {
                    const cost = upgradeConf.cost;
                    const upgradeButton = document.createElement('button');
                    upgradeButton.dataset.upgradeType = upgradeId;
                    upgradeButton.textContent = `${getLangMsg(upgradeConf.nameKey)} (${cost} Exp)`;
                    upgradeButton.disabled = selectedUnit.exp < cost;
                    upgradeButton.title = getLangMsg(upgradeConf.nameKey + 'Desc', [cost]);
                    upgradeButton.addEventListener('click', handleUpgradeClick);
                    DOMElements.upgradeInfoContent.appendChild(upgradeButton);
                    upgradesAdded++;
                }
            });

            if (upgradesAdded === 0) {
                const noUpgradeText = document.createElement('p');
                noUpgradeText.textContent = lang.upgradeNoUpgradesAvailable;
                DOMElements.upgradeInfoContent.appendChild(noUpgradeText);
            }
        } else {
            const selectUnitText = document.createElement('p');
            selectUnitText.textContent = lang.upgradeInfoSelectUnit;
            DOMElements.upgradeInfoContent.appendChild(selectUnitText);
        }
    }

    function updateResearchUI() {
        const lang = getLang();
        const isResearching = !!gameState.activeResearch;
        DOMElements.primitiveTechList.innerHTML = '';

        Object.entries(gameConfig.tech)
            .filter(([id, tech]) => tech.age === 'primitive')
            .forEach(([id, tech]) => {
                const isCompleted = gameState.completedTech.has(id);
                const canResearch = !isResearching && !isCompleted && tech.requires.every(req => gameState.completedTech.has(req));

                const listItem = document.createElement('li');
                listItem.className = 'research-item';
                if (isCompleted) listItem.classList.add('completed');

                const button = document.createElement('button');
                button.id = `${id}-research`;
                button.dataset.techId = id;
                button.textContent = lang[tech.nameKey] || id;
                button.disabled = !canResearch || isCompleted;
                button.title = lang[tech.nameKey] || id;
                if (isCompleted) {
                    button.textContent += ` ${lang.researchStatusComplete}`;
                }
                button.addEventListener('click', () => handleResearchClick(id));

                const progressContainer = document.createElement('div');
                progressContainer.id = `${id}-research-progress`;
                progressContainer.className = 'research-progress-container';
                progressContainer.style.display = (gameState.activeResearch === id) ? 'flex' : 'none';

                const progressBar = document.createElement('div');
                progressBar.id = `${id}-research-bar`;
                progressBar.className = 'research-progress-bar';
                progressBar.style.backgroundColor = tech.color || '#3498db';

                const infoContainer = document.createElement('div');
                infoContainer.className = 'research-info';

                const costP = document.createElement('p');
                costP.className = 'research-cost';
                costP.textContent = `Cost: ${tech.cost} RP`;

                const descP = document.createElement('p');
                descP.className = 'description';
                descP.textContent = getLangMsg(tech.nameKey + 'Desc');

                progressContainer.appendChild(progressBar);
                listItem.appendChild(button);
                listItem.appendChild(progressContainer);
                infoContainer.appendChild(costP);
                infoContainer.appendChild(descP);
                listItem.appendChild(infoContainer);

                if (gameState.activeResearch === id) {
                    const progress = Math.min(100, tech.cost > 0 ? (gameState.researchPoints / tech.cost) * 100 : 100);
                    progressBar.style.width = progress + '%';
                    DOMElements.researchStatusDisplay.textContent = getLangMsg('researchStatusResearching') + ` ${lang[tech.nameKey] || id}... ${Math.floor(progress)}%`;
                }

                DOMElements.primitiveTechList.appendChild(listItem);
        });

        if (!isResearching && DOMElements.researchStatusDisplay.textContent.startsWith(lang.researchStatusResearching)) {
             DOMElements.researchStatusDisplay.textContent = '';
        } else if (!isResearching && gameState.completedTech.size === 0) {
             DOMElements.researchStatusDisplay.textContent = lang.researchStatusInitial;
        }
         DOMElements.researchStatusDisplay.style.display = DOMElements.researchStatusDisplay.textContent ? 'block' : 'none';
    }


    function updateResearchProgress() {
        if (!gameState.activeResearch) return;
        const techId = gameState.activeResearch;
        const tech = gameConfig.tech[techId];
        if (!tech) { gameState.activeResearch = null; return; }

        const progress = Math.min(100, tech.cost > 0 ? (gameState.researchPoints / tech.cost) * 100 : 100);
        const progressBar = document.getElementById(`${techId}-research-bar`);
        if (progressBar) { progressBar.style.width = progress + '%'; }

        DOMElements.researchStatusDisplay.textContent = getLangMsg('researchStatusResearching') + ` ${getLangMsg(tech.nameKey)}... ${Math.floor(progress)}%`;
        DOMElements.researchStatusDisplay.style.display = 'block';

        if (gameState.researchPoints >= tech.cost) {
            gameState.completedTech.add(techId);
            gameState.activeResearch = null;
            gameState.researchPoints = 0;
            showAlert('alertResearchComplete', 3500, true, [tech.nameKey]);
            DOMElements.researchStatusDisplay.textContent = `${getLangMsg(tech.nameKey)} ${getLangMsg('researchStatusComplete')}`;

            let expGained = false;
            gameState.units.forEach(unit => {
                const unitConf = gameConfig.units[unit.type];
                if (unitConf?.researchBonus > 0) {
                    unit.exp = (unit.exp || 0) + gameConfig.expPerResearchComplete * unitConf.researchBonus;
                    expGained = true;
                }
            });
            if (expGained) {
                logEvent('logGainedExpResearch', ['unitPawn', gameConfig.expPerResearchComplete, tech.nameKey]);
                 if(gameState.units.find(u => u.id === gameState.selectedUnitId)?.type === 'pawn') updateUnitInfoDisplay();
            }
            updateResearchUI();
            updateBuildingsList();
            updateUnitsPanel(); // Update units panel as tech might enable deployment buttons
            updateInventoryCapacity();
            updateResearchPointsDisplay();
        }
    }

    function updateBuildingsList() {
        const listElement = DOMElements.buildingsListUl;
        listElement.innerHTML = '';
        const lang = getLang();
        let availableBuildings = 0;

        Object.entries(gameConfig.buildings).forEach(([id, building]) => {
            if (building.unlockedBy && !gameState.completedTech.has(building.unlockedBy)) {
                return;
            }

            availableBuildings++;
            const listItem = document.createElement('li');
            const button = document.createElement('button');
            const costString = Object.entries(building.cost).map(([res, amount]) => `${amount} ${lang[res] || res}`).join(', ');

            button.textContent = `${lang[building.nameKey] || id}`;
            button.dataset.building = id;
            button.title = lang[building.nameKey] || id;
            button.disabled = !canAfford(building.cost);
            button.addEventListener('click', () => {
                // Only select the building here, cost is spent on placement
                gameState.selectedBuilding = id;
                gameState.unitToDeploy = null; // Cancel unit deploy mode if selecting building
                showAlert('alertBuildSelected', 4000, true, [building.nameKey]);
                gameState.highlightEnabled = true; // Enable generic highlight for placement
                updateGrid();
                updateBuildingsList(); // Refresh button states (affordability)
            });

            const costP = document.createElement('p');
            costP.className = 'building-cost';
            costP.textContent = `Cost: ${costString}`;

            const description = document.createElement('p');
            description.className = 'description';
            description.textContent = getLangMsg(building.nameKey + 'Desc');

            listItem.appendChild(button);
            listItem.appendChild(costP);
            listItem.appendChild(description);
            listElement.appendChild(listItem);
        });

        if (availableBuildings === 0) {
            listElement.innerHTML = `<li>${lang.noBuildingsAvailable}</li>`;
        }
    }

    function updateUnitDisplayBar() {
        DOMElements.unitDisplayBar.innerHTML = '';
        const lang = getLang();
        const fragment = document.createDocumentFragment();

        gameState.units.forEach(unit => {
            const unitInfo = gameConfig.units[unit.type];
            const icon = document.createElement('div');
            icon.className = `unit-icon ${unit.type}`;
            icon.dataset.unitId = unit.id;
            icon.dataset.unitType = unit.type;
            icon.textContent = unitInfo?.icon || unit.type.charAt(0).toUpperCase();
            const translatedUnitType = lang[unitInfo?.nameKey] || unit.type;
            icon.title = `${translatedUnitType} (${unit.id})`;
            if (unit.id === gameState.selectedUnitId) {
                icon.classList.add('selected');
            }
            icon.addEventListener('click', () => {
                gameState.selectedUnitId = unit.id;
                gameState.selectedBuilding = null; // Cancel building placement
                gameState.unitToDeploy = null; // Cancel unit deployment
                gameState.highlightEnabled = false;
                focusOnUnit(unit.id); // Focus will update grid
            });
            fragment.appendChild(icon);
        });
        DOMElements.unitDisplayBar.appendChild(fragment);
    }

    // --- Updated Units Panel (for triggering deployment via houses) ---
     function updateUnitsPanel() {
         const listElement = DOMElements.unitsListUl;
         listElement.innerHTML = ''; // Clear list
         const lang = getLang();
         let deployableUnitsCount = 0;

         // Check if there are any unused houses on revealed tiles
         let hasUnusedHouse = false;
         gameState.revealedTiles.forEach(coordString => {
             if (hasUnusedHouse) return;
             const [x, y] = coordString.split(',').map(Number);
             const data = getTileData(x, y);
             if (data?.building === 'house' && data.unitDeployed === false) {
                 hasUnusedHouse = true;
             }
         });

         if (!hasUnusedHouse) {
             listElement.innerHTML = `<li>${lang.noUnusedHouses}</li>`;
             return; // No point showing buttons if no houses are available
         }

         Object.entries(gameConfig.units).forEach(([unitId, unitConf]) => {
             // Check if deployable from panel AND tech is researched
             if (unitConf.deployableFromPanel && unitConf.requiredTech && gameState.completedTech.has(unitConf.requiredTech)) {
                 deployableUnitsCount++;
                 const listItem = document.createElement('li');
                 const button = document.createElement('button');
                 button.dataset.unitType = unitId;
                 button.textContent = getLangMsg('deployUnitButton', [unitConf.nameKey]);

                 button.addEventListener('click', () => {
                     gameState.unitToDeploy = unitId; // Set the unit type to deploy
                     gameState.selectedBuilding = null; // Cancel building placement
                     gameState.highlightEnabled = true; // Use general highlight for house target selection
                     showAlert('alertSelectUnusedHouse', 4000);
                     updateGrid(); // Update grid to show highlighted houses
                     hideAllPanels(); // Close the panel
                 });

                 listItem.appendChild(button);
                 listElement.appendChild(listItem);
             }
         });

         // If no deployable units found (tech not researched) even if houses exist
         if (deployableUnitsCount === 0 && hasUnusedHouse) {
              listElement.innerHTML = `<li>${lang.noUnitsAvailablePanel}</li>`;
         }
     }


     function updateInventoryCapacity() {
         gameState.inventoryCapacity = { ...gameConfig.baseInventoryCapacity };
         let warehouseBonus = 0;
         gameState.revealedTiles.forEach(coordString => {
             const [x, y] = coordString.split(',').map(Number);
             const data = getTileData(x, y);
             if (data?.building === 'warehouse') {
                 warehouseBonus += gameConfig.buildings.warehouse.provides.capacityBonus || 0;
             }
         });
         for (const resId in gameState.inventoryCapacity) {
             gameState.inventoryCapacity[resId] += warehouseBonus;
         }
         updateInventoryDisplay();
     }

    // --- Gameplay Functions ---
    function checkResource() {
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        let canGather = false;
        let tileName = getLang().noUnitSelected;

        if (selectedUnit) {
            const data = getTileData(selectedUnit.worldX, selectedUnit.worldY);
            tileName = getLang().unknownTile;

            if (data && !data.building) {
                const unitType = selectedUnit.type;
                if (data.type === 'tree' || data.type === 'stone' || data.type === 'flint') {
                    canGather = true;
                }
                const lang = getLang();
                if (data.type === 'tree') { tileName = `${lang.onTile} ${lang.tileResourceTree}`; }
                else if (data.type === 'stone') { tileName = `${lang.onTile} ${lang.tileResourceStone}`; }
                else if (data.type === 'flint') { tileName = `${lang.onTile} ${lang.tileResourceFlint}`; }
                else if (data.type === 'water') { tileName = `${lang.onTile} ${lang.water}`; }
                else if (data.type === 'sand') { tileName = `${lang.onTile} ${lang.sand}`; }
                else if (data.type === 'grass') { tileName = `${lang.onTile} ${lang.grass}`; }
                else { tileName = `${lang.onTile} ${lang.emptyTile}`; }

            } else if (data && data.building) {
                 const bInfo = gameConfig.buildings[data.building];
                 tileName = `${getLang().onTile} ${getLangMsg(bInfo?.nameKey) || data.building}`;
            }
        }

        DOMElements.actionButton.style.display = canGather ? 'inline-block' : 'none';
        DOMElements.resourceNameDisplay.textContent = tileName;
    }

    function triggerRandomEvent(unit) {
        if (Math.random() < gameConfig.eventChance) {
             let foundSpot = false;
             for (let range = 1; range <= 2 && !foundSpot; range++) {
                 for (let dy = -range; dy <= range; dy++) {
                     for (let dx = -range; dx <= range; dx++) {
                         if (Math.abs(dx) + Math.abs(dy) !== range) continue;
                         const tx = unit.worldX + dx;
                         const ty = unit.worldY + dy;
                         const tData = getTileData(tx, ty);
                         const coordString = `${tx},${ty}`;
                         if (gameState.revealedTiles.has(coordString) && tData && tData.type !== 'water' && !tData.building && !gameState.units.some(u => u.worldX === tx && u.worldY === ty)) {
                             const resourceTypes = ['wood', 'pebble', 'flint'];
                             const resource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                             const amount = Math.floor(Math.random() * 5) + 2;
                             if (updateResource(resource, amount)) {
                                 showAlert('alertGatheredEvent', 3000, true, [resource, amount]);
                                 unit.exp = (unit.exp || 0) + gameConfig.expPerEventDiscovery;
                                 logEvent('logGainedExpEvent', [unit.id, gameConfig.expPerEventDiscovery]);
                                 if(unit.id === gameState.selectedUnitId) updateUnitInfoDisplay();
                                 foundSpot = true; break;
                             }
                         }
                     }
                     if (foundSpot) break;
                 }
             }
        }
    }


    function moveUnit(targetGridX, targetGridY) {
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        if (!selectedUnit) return;

        const targetWorldX = targetGridX + gameState.viewOffsetX;
        const targetWorldY = targetGridY + gameState.viewOffsetY;
        const unitInfo = gameConfig.units[selectedUnit.type];

        let maxMove = unitInfo?.move || 1;
        if (selectedUnit.upgrades?.movement1) maxMove += gameConfig.upgrades.movement1.effect.moveBonus;

        const dx = Math.abs(targetWorldX - selectedUnit.worldX);
        const dy = Math.abs(targetWorldY - selectedUnit.worldY);
        if (dx + dy > maxMove) { return; } // Manhattan distance check

        if (!gameState.revealedTiles.has(`${targetWorldX},${targetWorldY}`)) return;
        const targetData = getTileData(targetWorldX, targetWorldY);
        if (!targetData || targetData.type === 'water') { showAlert('alertMoveInvalid', 1500, false); return; }
        const targetOccupied = gameState.units.some(u => u.worldX === targetWorldX && u.worldY === targetWorldY);
        if (targetOccupied) { showAlert("alertUnitMoveOccupied", 2000, false); return; }

        selectedUnit.worldX = targetWorldX;
        selectedUnit.worldY = targetWorldY;
        revealArea(targetWorldX, targetWorldY, unitInfo?.revealRadius || gameConfig.revealRadiusBase);

        if (selectedUnit.upgrades?.autoGather) {
            tryAutoGather(selectedUnit);
        }

        if (gameState.activeResearch) {
            const researchBonus = unitInfo?.researchBonus || 0;
            if (researchBonus > 0) {
                 gameState.researchPoints += researchBonus;
                 updateResearchProgress();
            }
        }
        updateResearchPointsDisplay();

        for (const prodType in gameState.productionProgress) {
            gameState.productionProgress[prodType]++;
            const interval = gameConfig.productionIntervals[prodType];
            if (gameState.productionProgress[prodType] >= interval) {
                produceResources(prodType);
                gameState.productionProgress[prodType] = 0;
            }
        }
        triggerRandomEvent(selectedUnit);

        if (selectedUnit.id === gameState.selectedUnitId) {
            focusOnUnit(selectedUnit.id); // This calls updateGrid indirectly
        } else {
            updateGrid(); // Update grid if the moved unit wasn't selected
        }
    }

    function tryAutoGather(unit) {
        const data = getTileData(unit.worldX, unit.worldY);
        if (data && !data.building && (data.type === 'tree' || data.type === 'stone' || data.type === 'flint')) {
            gatherResource(unit, true);
        }
    }

    function gatherResource(unit = null, auto = false) {
        const targetUnit = unit || gameState.units.find(u => u.id === gameState.selectedUnitId);
        if (!targetUnit) { if (!auto) showAlert("noUnitSelected", 2000); return; }

        const data = getTileData(targetUnit.worldX, targetUnit.worldY);
        if (data && !data.building) {
            let gatheredResourceKey = null;
            let baseTerrain = data.biome === 'desert' ? 'sand' : 'grass';
            let quantity = 1;

            if (data.type === 'tree') gatheredResourceKey = 'wood';
            else if (data.type === 'stone') gatheredResourceKey = 'pebble';
            else if (data.type === 'flint') gatheredResourceKey = 'flint';

            if (gatheredResourceKey) {
                if (updateResource(gatheredResourceKey, quantity)) {
                    data.type = baseTerrain;
                    setTileData(targetUnit.worldX, targetUnit.worldY, data);
                    const langResourceName = getLangMsg(gatheredResourceKey);
                    if (!auto) showAlert('alertGathered', 1500, true, [langResourceName, quantity]);
                    else logEvent('alertGathered', [langResourceName, quantity], `[Auto] ${getLangMsg('alertGathered', [langResourceName, quantity])}`);
                    updateGrid();
                    checkResource();
                } else {
                     if (!auto) showAlert('alertStorageFull', 2000, true, [getLangMsg(gatheredResourceKey)]);
                }
            }
        }
    }

    function produceResources(productionType) {
         let producedCount = 0;
         gameState.revealedTiles.forEach(coordString => {
             const [x, y] = coordString.split(',').map(Number);
             const data = getTileData(x, y);
             if (!data || !data.building) return;
             const buildingConf = gameConfig.buildings[data.building];
             if (!buildingConf || !buildingConf.produces || buildingConf.produces.interval !== productionType) return;

             let canProduce = true; // Basic check for now

             if(canProduce) {
                 if (Array.isArray(buildingConf.produces.resource)) { // Quarry
                     const metalKey = buildingConf.produces.resource[Math.floor(Math.random() * buildingConf.produces.resource.length)];
                     if (updateResource(metalKey, 1)) {
                         if (producedCount === 0) showAlert('alertGatheredQuarry', 2000, true, [metalKey]);
                         producedCount++;
                     } else {
                          if (producedCount === 0) showAlert('alertStorageFull', 2000, true, [metalKey]);
                     }
                 } else { // Farm/Mine
                     const resourceKey = buildingConf.produces.resource;
                      if (updateResource(resourceKey, 1)) {
                          producedCount++;
                      } else {
                           if (producedCount === 0) showAlert('alertStorageFull', 2000, true, [resourceKey]);
                      }
                 }
             }
         });
    }

    // Finds spawn point adjacent to given coordinates (anchor)
    function findSpawnPoint(anchorX, anchorY) {
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const sx = anchorX + dx;
                const sy = anchorY + dy;
                const sData = getTileData(sx, sy);
                const coordString = `${sx},${sy}`;
                const isOccupied = gameState.units.some(u => u.worldX === sx && u.worldY === sy);

                // Check if revealed, is land, not occupied, and no building
                if (gameState.revealedTiles.has(coordString) && sData && (sData.type === 'grass' || sData.type === 'sand' || sData.type === 'empty') && !isOccupied && !sData.building) {
                    return { worldX: sx, worldY: sy }; // Found a valid spot
                }
            }
        }
        return null; // No suitable spot found
    }

    // --- Unit Focusing ---
    function focusOnUnit(unitId) {
        const unit = gameState.units.find(u => u.id === unitId);
        if (!unit) return;
        const unitConf = gameConfig.units[unit.type];
        const newViewOffsetX = unit.worldX - gameConfig.viewCenterOffset;
        const newViewOffsetY = unit.worldY - gameConfig.viewCenterOffset;
        const viewChanged = newViewOffsetX !== gameState.viewOffsetX || newViewOffsetY !== gameState.viewOffsetY;
        gameState.viewOffsetX = newViewOffsetX;
        gameState.viewOffsetY = newViewOffsetY;
        const newlyRevealed = revealArea(unit.worldX, unit.worldY, unitConf?.revealRadius || gameConfig.revealRadiusBase);

        // Update selected unit and related UI
        gameState.selectedUnitId = unitId; // Ensure selectedUnitId is set correctly
        updateUnitDisplayBar();
        updateUnitInfoDisplay();

        // Refresh grid if view changed, area revealed, or selection changed (always refresh to show selection)
        updateGrid(); // Update grid to show selection and potential new tiles
        checkResource(); // Update action button state
    }

    // --- Event Log Helper ---
     function logEvent(messageKey, args = [], renderedOverride = null) {
         const timeString = getFormattedTime();
         const message = renderedOverride !== null ? renderedOverride : getLangMsg(messageKey, args);
         const storedArgs = args.map(arg => (typeof arg === 'number' || typeof arg === 'boolean' || arg === null) ? arg : String(arg));
         gameState.eventLogs.push({ time: timeString, messageKey: messageKey, args: storedArgs, rendered: message });
         if (gameState.eventLogs.length > gameConfig.maxLogEntries) gameState.eventLogs.shift();
         if (DOMElements.logsPanel.style.display === 'block') updateLogsDisplay();
     }

    // --- Event Listeners ---
     function setupEventListeners() {
         DOMElements.grid.addEventListener('click', (event) => {
             const tile = event.target.closest('.tile');
             if (tile && !tile.classList.contains('unknown')) {
                 const gridX = parseInt(tile.dataset.gridX);
                 const gridY = parseInt(tile.dataset.gridY);
                 const worldX = gridX + gameState.viewOffsetX;
                 const worldY = gridY + gameState.viewOffsetY;

                 // *** Handle House Target Selection Click ***
                 if (gameState.unitToDeploy) {
                     const targetData = getTileData(worldX, worldY);
                     if (targetData?.building === 'house' && targetData.unitDeployed === false) {
                         // Valid house target clicked
                         deployUnitNearHouse(gameState.unitToDeploy, worldX, worldY); // Calls updateGrid at the end
                     } else {
                         // Invalid target clicked - cancel deployment mode
                         showAlert('alertInvalidHouseTarget', 2500, true);
                         gameState.unitToDeploy = null;
                         gameState.highlightEnabled = false;
                         updateGrid(); // Remove highlights
                     }
                     return; // Stop further processing of this click
                 }

                 // --- Original Click Logic (if not deploying) ---
                 const clickedUnit = gameState.units.find(u => u.worldX === worldX && u.worldY === worldY);

                 if (clickedUnit) {
                     gameState.selectedUnitId = clickedUnit.id;
                     gameState.selectedBuilding = null; // Cancel building selection
                     gameState.highlightEnabled = false;
                     focusOnUnit(clickedUnit.id); // Focus handles grid update
                     showAlert('alertSelectedUnit', 1500, false, [gameConfig.units[clickedUnit.type]?.nameKey || clickedUnit.type, clickedUnit.id]);
                 } else if (gameState.selectedBuilding) {
                     handlePlaceBuilding(worldX, worldY); // Handles grid update
                 } else if (gameState.selectedUnitId) {
                     moveUnit(gridX, gridY); // Handles grid update
                 }

                 // Update highlight status only if not building and not deploying unit
                  if (!gameState.selectedBuilding && !gameState.unitToDeploy) gameState.highlightEnabled = false;
                  // Grid is generally updated by the actions above, but a final call ensures consistency if needed
                  // updateGrid();
             } else if (tile && tile.classList.contains('unknown') && gameState.unitToDeploy) {
                  // Clicked unknown tile while trying to deploy - cancel
                  showAlert('alertInvalidHouseTarget', 2500, true);
                  gameState.unitToDeploy = null;
                  gameState.highlightEnabled = false;
                  updateGrid(); // Remove highlights
             } else if (!tile) {
                  // Clicked outside grid while trying to deploy - cancel
                  if(gameState.unitToDeploy) {
                     gameState.unitToDeploy = null;
                     gameState.highlightEnabled = false;
                     updateGrid();
                  }
             }
         });

         DOMElements.actionButton.addEventListener('click', () => gatherResource(null, false));
         DOMElements.middleControls.addEventListener('click', (event) => {
             const button = event.target.closest('button[data-panel-target]');
             if (button) { togglePanel(button.dataset.panelTarget); }
         });
         DOMElements.closeTutorialButton.addEventListener('click', () => { DOMElements.tutorialModal.style.display = 'none'; });
         DOMElements.tutorialModal.addEventListener('click', (event) => { if (event.target === DOMElements.tutorialModal) { DOMElements.tutorialModal.style.display = 'none'; } });
         DOMElements.logSearchInput.addEventListener('input', updateLogsDisplay);
         DOMElements.logFilterCheckbox.addEventListener('change', updateLogsDisplay);
         DOMElements.saveButton.addEventListener('click', saveGame);
         DOMElements.loadButton.addEventListener('click', () => DOMElements.loadFileInput.click());
         DOMElements.loadFileInput.addEventListener('change', loadGame);
         DOMElements.languageSwitchButton.addEventListener('click', switchLanguage);

         DOMElements.grid.addEventListener('mouseover', (event) => {
             const tile = event.target.closest('.tile');
             // Highlight potential moves ONLY if a unit is selected AND we are NOT placing a building OR selecting a house target
             if (tile && !tile.classList.contains('unknown') && gameState.selectedUnitId != null && !gameState.selectedBuilding && !gameState.unitToDeploy) {
                 gameState.highlightEnabled = true; updateGrid();
             }
          });
          DOMElements.grid.addEventListener('mouseout', (event) => {
             // Remove highlight when mouse leaves the grid area, only if it was move highlight
             if (gameState.highlightEnabled && !gameState.unitToDeploy && (!event.relatedTarget || !event.relatedTarget.closest || !event.relatedTarget.closest('#grid'))) {
                 gameState.highlightEnabled = false; updateGrid();
             }
          });
          // Unit panel clicks are handled within updateUnitsPanel
     }

    // --- Action Handlers ---
    function togglePanel(targetId) {
         const targetElement = document.getElementById(targetId);
         if (!targetElement) return;

         // Always cancel deploy/build modes when opening panels
         gameState.selectedBuilding = null;
         gameState.unitToDeploy = null;
         gameState.highlightEnabled = false;

         if (targetId === 'tutorial-modal') {
             hideAllPanels();
             targetElement.style.display = 'block';
             updateLanguageUI(); // Update tutorial text
             updateGrid(); // Ensure grid highlights are off
             return;
         }

         const isVisible = targetElement.style.display === 'block';
         hideAllPanels(); // Hide all other panels first
         if (!isVisible) {
             targetElement.style.display = 'block';
             // Update content of the opened panel
             if (targetId === 'tech-tree') updateResearchUI();
             else if (targetId === 'buildings-list') updateBuildingsList();
             else if (targetId === 'units-panel') updateUnitsPanel(); // Refresh deploy buttons
             else if (targetId === 'upgrade-info') updateUnitInfoDisplay();
             else if (targetId === 'logs-panel') updateLogsDisplay();
         }
         updateGrid(); // Ensure grid highlights are off after closing/opening panels
    }

    function hideAllPanels() {
         document.querySelectorAll('.panel:not(#inventory)').forEach(panel => { panel.style.display = 'none'; });
         DOMElements.tutorialModal.style.display = 'none';
         // gameState.unitToDeploy = null; // Reset deploy state when closing panels
         // gameState.selectedBuilding = null; // Reset build state
         // gameState.highlightEnabled = false;
         // updateGrid(); // Update grid to remove highlights
     }
    function handleResearchClick(techId) {
        const tech = gameConfig.tech[techId];
        if (!tech || gameState.completedTech.has(techId) || gameState.activeResearch) {
             if(gameState.activeResearch) showAlert("alertAlreadyResearching", 3000, true, [gameConfig.tech[gameState.activeResearch]?.nameKey || gameState.activeResearch]);
            return;
        }
        if (!tech.requires.every(req => gameState.completedTech.has(req))) { return; }
        gameState.activeResearch = techId;
        gameState.researchPoints = 0;
        updateResearchPointsDisplay(); updateResearchUI();
        showAlert("alertResearchStarted", 2500, true, [tech.nameKey]);
    }

    // REMOVED handleDeployUnitFromPanel

    function handlePlaceBuilding(worldX, worldY) {
        const builderUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        const buildingId = gameState.selectedBuilding;
        if (!builderUnit || !buildingId) { gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return; }

        const buildingConf = gameConfig.buildings[buildingId];
        const builderConf = gameConfig.units[builderUnit.type];
        const lang = getLang();

        if (!buildingConf) { console.error(`Invalid building selected: ${buildingId}`); gameState.selectedBuilding = null; return; }
        if (!builderConf?.build?.includes(buildingId)) {
            showAlert('alertUnitCannotBuild', 3000, true, [builderConf.nameKey, buildingConf.nameKey]);
            gameState.selectedBuilding = null; return;
        }

        const tileData = getTileData(worldX, worldY);
        let canPlace = true; let failReasonKey = ''; let failArgs = [];

        if (!tileData || (tileData.type !== 'grass' && tileData.type !== 'empty')) {
            canPlace = false; failReasonKey = 'alertCannotBuildNonEmpty';
            if (tileData?.type === 'water' || tileData?.type === 'sand') { failReasonKey = 'alertCannotBuildOnTerrain'; failArgs = [tileData.type]; }
            else if (tileData?.type === 'tree' || tileData?.type === 'stone' || tileData?.type === 'flint') { failReasonKey = 'alertCannotBuildOnResource'; failArgs = [lang[`tileResource${tileData.type.charAt(0).toUpperCase() + tileData.type.slice(1)}`] || tileData.type]; }
        } else if (tileData.building) {
            canPlace = false; failReasonKey = 'alertCannotBuildExists'; failArgs = [lang[gameConfig.buildings[tileData.building]?.nameKey] || tileData.building];
        }

        if (!canPlace) {
            showAlert(failReasonKey || 'alertCannotBuildNonEmpty', 3000, true, failArgs);
            gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return;
        }

        if (!spendResources(buildingConf.cost)) {
            showAlert('alertNotEnoughResources', 3000, true, [buildingConf.nameKey]);
            gameState.selectedBuilding = null; gameState.highlightEnabled = false; updateGrid(); return;
        }

        // --- Placement Success ---
        tileData.building = buildingId;
        // Mark house as unused for deployment when built
        if (buildingId === 'house') {
            tileData.unitDeployed = false; // Initialize as unused
        }
        setTileData(worldX, worldY, tileData);
        showAlert('alertBuildingBuilt', 2500, true, [buildingConf.nameKey]);
        gameState.selectedBuilding = null; gameState.highlightEnabled = false; // Clear selection

        builderUnit.exp = (builderUnit.exp || 0) + gameConfig.expPerBuild;
        logEvent('logGainedExp', [builderConf.nameKey, builderUnit.id, gameConfig.expPerBuild, buildingConf.nameKey]);
        if (builderUnit.id === gameState.selectedUnitId) updateUnitInfoDisplay();

        if (buildingConf.provides?.capacityBonus) { updateInventoryCapacity(); }
        updateGrid();
        updateBuildingsList();
        updateUnitsPanel(); // Update panel in case this was the first house
    }

    function handleUpgradeClick(event) {
        const selectedUnit = gameState.units.find(u => u.id === gameState.selectedUnitId);
        if (!selectedUnit || event.target.disabled) return;
        const upgradeId = event.target.dataset.upgradeType;
        const upgradeConf = gameConfig.upgrades[upgradeId]; if (!upgradeConf) return;
        const cost = upgradeConf.cost; const currentLevel = selectedUnit.upgrades?.[upgradeId] || 0;
        if (currentLevel >= upgradeConf.maxLevel) { showAlert('alertUpgradeMaxLevel', 3000, true, [upgradeConf.nameKey]); return; }
        if (selectedUnit.exp >= cost) {
            selectedUnit.exp -= cost;
            if (!selectedUnit.upgrades) selectedUnit.upgrades = {};
             if (upgradeConf.effect.moveBonus) { selectedUnit.upgrades[upgradeId] = (selectedUnit.upgrades[upgradeId] || 0) + 1; }
             else if (upgradeConf.effect.autoGather) { selectedUnit.upgrades[upgradeId] = true; }
            showAlert('alertUpgradeSuccess', 2500, true, [upgradeConf.nameKey, selectedUnit.id]);
            logEvent('alertUpgradeSuccess', [upgradeConf.nameKey, selectedUnit.id]);
            updateUnitInfoDisplay(); updateGrid(); // Refresh UI
        } else { showAlert('alertNotEnoughExp', 3000, true, [upgradeConf.nameKey]); }
    }

    // --- New Function for Deploying Unit at a House ---
     function deployUnitNearHouse(unitType, houseX, houseY) {
         const unitConf = gameConfig.units[unitType];
         const lang = getLang();

         if (!unitConf) {
             console.error("Invalid unit type for house deployment:", unitType);
             gameState.unitToDeploy = null; // Reset state
             gameState.highlightEnabled = false;
             updateGrid();
             return;
         }

         // Find spawn point near the *clicked house*
         const spawnDetails = findSpawnPoint(houseX, houseY);

         if (spawnDetails) {
             // Create and add the new unit
             const newUnit = {
                 id: `unit-${gameState.nextUnitId++}`, type: unitType,
                 worldX: spawnDetails.worldX, worldY: spawnDetails.worldY,
                 exp: 0, upgrades: {}
             };
             gameState.units.push(newUnit);

             // Mark the house as used
             const houseTileData = getTileData(houseX, houseY);
             if (houseTileData) {
                 houseTileData.unitDeployed = true; // Set the flag
                 setTileData(houseX, houseY, houseTileData);
             } else {
                 console.error("Could not find house data to mark as deployed at", houseX, houseY);
             }

             revealArea(newUnit.worldX, newUnit.worldY, unitConf?.revealRadius || gameConfig.revealRadiusBase);
             showAlert("alertUnitDeployed", 2000, true, [unitConf.nameKey]);

         } else {
             // No space available near the house
             showAlert("alertNoSpaceForUnit", 3000, true, [unitConf.nameKey]);
             // Note: House remains unused (unitDeployed stays false)
         }

         // --- Cleanup ---
         gameState.unitToDeploy = null; // Exit deployment mode regardless of success
         gameState.highlightEnabled = false;
         updateGrid(); // Refresh grid (remove highlights, show new unit, update house appearance)
         updateUnitDisplayBar(); // Add new unit icon
         updateUnitsPanel(); // Update panel (deploy button might disable if no more houses)
     }


    // --- Save/Load Functions ---
     function gatherSaveData() {
         // Ensure all relevant state is captured
         const saveData = {
             version: "1.3", // Increment version due to house deployment changes
             gameState: {
                 units: gameState.units, nextUnitId: gameState.nextUnitId, selectedUnitId: gameState.selectedUnitId,
                 inventory: gameState.inventory,
                 researchPoints: gameState.researchPoints, activeResearch: gameState.activeResearch,
                 completedTech: Array.from(gameState.completedTech),
                 productionProgress: gameState.productionProgress,
                 colonyName: gameState.colonyName, currentLanguage: gameState.currentLanguage,
                 eventLogs: gameState.eventLogs.map(log => ({ time: log.time, messageKey: log.messageKey, args: log.args || [] })),
                 viewOffsetX: gameState.viewOffsetX, viewOffsetY: gameState.viewOffsetY,
                 worldData: gameState.worldData, // This now includes unitDeployed flag on house tiles
                 revealedTiles: Array.from(gameState.revealedTiles)
                 // unitToDeploy is transient, not saved
             }
         };
         return saveData;
     }
    function saveGame() {
        try {
            const saveData = gatherSaveData();
            const saveDataJson = JSON.stringify(saveData, null, 2);
            const blob = new Blob([saveDataJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const safeColonyName = gameState.colonyName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'colony';
            link.download = `tinyciv_${safeColonyName}_save_v${saveData.version}.json`;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showAlert('alertGameSaved', 2000); logEvent('logGameSaved');
        } catch (error) { console.error("Error saving game:", error); showAlert('alertSaveError', 4000); }
    }
    function applyLoadedData(data) {
         const requiredVersion = "1.3"; // Update required version for loading check
         if (!data || !data.gameState) { showAlert('alertLoadInvalidFormat', 5000, true); return false; }

         if (data.version !== requiredVersion) {
              showAlert('alertSaveVersionMismatch', 6000, true, [requiredVersion, data.version || 'Unknown']);
              // Decide whether to proceed or return false - for now, allow loading older saves potentially
              // return false;
         }
        const loadedState = data.gameState;
        gameState.units = loadedState.units || [];
        gameState.nextUnitId = loadedState.nextUnitId || 0;
        gameState.selectedUnitId = loadedState.selectedUnitId !== undefined ? loadedState.selectedUnitId : (gameState.units.length > 0 ? gameState.units[0].id : null);
        gameState.inventory = loadedState.inventory || {};
        gameState.researchPoints = loadedState.researchPoints || 0;
        gameState.activeResearch = loadedState.activeResearch || null;
        gameState.completedTech = new Set(loadedState.completedTech || []);
        gameState.productionProgress = loadedState.productionProgress || { wheat: 0, coal: 0, quarry: 0 };
        gameState.colonyName = loadedState.colonyName || "Loaded Colony";
        gameState.currentLanguage = loadedState.currentLanguage || 'en';
        gameState.viewOffsetX = loadedState.viewOffsetX || 0;
        gameState.viewOffsetY = loadedState.viewOffsetY || 0;
        gameState.worldData = loadedState.worldData || {};
        gameState.revealedTiles = new Set(loadedState.revealedTiles || []);
        gameState.eventLogs = (loadedState.eventLogs || []).map(logData => ({
             time: logData.time, messageKey: logData.messageKey, args: logData.args || [],
             rendered: getLangMsg(logData.messageKey, logData.args || [])
         }));
        // Ensure loaded units have expected properties
        gameState.units.forEach(unit => {
             if (unit.exp === undefined) unit.exp = 0;
             if (unit.upgrades === undefined) unit.upgrades = {};
        });
         // Ensure loaded house tiles have unitDeployed property (for backward compatibility if needed)
         Object.values(gameState.worldData).forEach(row => {
             Object.values(row).forEach(tile => {
                 if (tile.building === 'house' && tile.unitDeployed === undefined) {
                      // Assume older saves' houses were used or handle differently?
                      // For simplicity, assume they are used if undefined on load.
                      // tile.unitDeployed = true;
                      // OR assume unused:
                      tile.unitDeployed = false; // More likely intended for loading old saves
                 }
             });
         });

        // Reset transient UI state
        gameState.selectedBuilding = null;
        gameState.unitToDeploy = null;
        gameState.highlightEnabled = false;

        updateInventoryCapacity();
        updateLanguageUI();
        hideAllPanels();
        updateInventoryDisplay(); updateResearchPointsDisplay(); updateUnitDisplayBar();
        updateGrid(); updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay();
        if (gameState.selectedUnitId) { focusOnUnit(gameState.selectedUnitId); }
        showAlert('alertLoadSuccess', 3000, false, [gameState.colonyName]);
        gameState.gameInitialized = true; // Mark game as initialized
        return true;
    }
    function loadGame(event) {
        const file = event.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try { const loadedData = JSON.parse(e.target.result); applyLoadedData(loadedData); }
            catch (error) { console.error("Error loading game:", error); showAlert('alertLoadError', 5000, true, [error.message]); }
            finally { DOMElements.loadFileInput.value = null; }
        };
        reader.onerror = function() { showAlert('alertReadFileError', 3000); DOMElements.loadFileInput.value = null; };
        reader.readAsText(file);
    }

    // --- UI Language Update Function ---
     function updateLanguageUI() {
         const lang = getLang();
         document.title = lang.gameTitle; document.querySelector('h1').textContent = lang.gameTitle;
         DOMElements.languageSwitchButton.textContent = (gameState.currentLanguage === 'en') ? lang.switchToFrench : lang.switchToEnglish;
         DOMElements.languageSwitchButton.title = lang.switchLanguageTooltip;
         DOMElements.colonyNameDisplay.textContent = `${lang.colonyLabel} ${gameState.colonyName}`;
         DOMElements.inventoryDisplay.querySelector('h2').textContent = lang.inventoryTitle;
         DOMElements.actionButton.textContent = lang.gatherButton;
         document.getElementById('tutorial-button').textContent = lang.tutorialButton;
         document.getElementById('research-button').textContent = lang.researchButton;
         document.getElementById('buildings-button').textContent = lang.buildingsButton;
         document.getElementById('units-button').textContent = lang.unitsButton;
         document.getElementById('upgrade-button').textContent = lang.upgradeButton;
         document.getElementById('logs-button').textContent = lang.logsButton;
         DOMElements.saveButton.textContent = lang.saveButton; DOMElements.loadButton.textContent = lang.loadButton;
         DOMElements.logsPanel.querySelector('h2').textContent = lang.logsPanelTitle;
         DOMElements.logSearchInput.placeholder = lang.logSearchPlaceholder;
         const filterLabel = DOMElements.logFilterCheckbox.parentElement; if (filterLabel) filterLabel.childNodes[1].nodeValue = ` ${lang.logFilterLabel}`;
         document.getElementById('research-points-display-container').childNodes[0].nodeValue = `${lang.researchPointsLabel} `;
         document.getElementById('unit-exp-display-container').childNodes[0].nodeValue = `${lang.unitExpLabel} `;
         const techTitle = DOMElements.techTree.querySelector('h2'); if (techTitle) techTitle.textContent = lang.researchPanelTitle;
         const buildTitle = DOMElements.buildingsList.querySelector('h2'); if (buildTitle) buildTitle.textContent = lang.buildingsPanelTitle;
         const unitsTitle = DOMElements.unitsPanel.querySelector('h2'); if (unitsTitle) unitsTitle.textContent = lang.unitsPanelTitle; // Update units panel title
         const upgradeTitleH4 = DOMElements.upgradeInfoDisplay.querySelector('h4'); if (upgradeTitleH4) upgradeTitleH4.textContent = lang.upgradeSectionTitle;

         // Update Tutorial Content (with updated flow)
         DOMElements.tutorialTitle.textContent = lang.tutorialTitle;
         DOMElements.tutorialStepsList.innerHTML = `
              <li>${lang.tutorialStep1}</li> <li>${lang.tutorialStep2}</li>
              <li>${lang.tutorialStep3}</li> <li>${lang.tutorialStep4}</li>
              <li>${lang.tutorialStep5}</li> <li>${lang.tutorialStep6}</li>
              <li>${lang.tutorialStep7}</li> <li>${lang.tutorialStep8}</li>
              <li>${lang.tutorialStep9}</li> <li>${lang.tutorialStep10}</li>
              <li>${lang.tutorialStep11}</li><li>${lang.tutorialStep12}</li>
              <li>${lang.tutorialStep13}</li><li>${lang.tutorialStep14}</li>
              <li>${lang.tutorialStep15}</li><li>${lang.tutorialStep16}</li>`; // Adjusted steps
         DOMElements.closeTutorialButton.textContent = lang.closeButton;

         // Refresh displays that depend on language
         updateInventoryDisplay(); updateGrid(); updateUnitDisplayBar();
         updateResearchUI(); updateBuildingsList(); updateUnitsPanel();
         updateUnitInfoDisplay(); updateLogsDisplay(); checkResource();
     }

    // --- Language Switching ---
     function switchLanguage() {
         gameState.currentLanguage = (gameState.currentLanguage === 'en') ? 'fr' : 'en';
         gameState.eventLogs.forEach(log => { log.rendered = getLangMsg(log.messageKey, log.args); });
         updateLanguageUI();
     }

    // --- Game Start ---
    function initializeGame() {
        if (gameState.gameInitialized && !confirm("Start a new game? Current progress will be lost.")) return;

        const seed = Math.random();
        noise.biome = SimplexNoise.create(seed);
        noise.feature = SimplexNoise.create(seed + 1);
        noise.water = SimplexNoise.create(seed + 2);

        gameState.units = []; gameState.nextUnitId = 0; gameState.selectedUnitId = null;
        gameState.inventory = {}; gameState.inventoryCapacity = {};
        gameState.researchPoints = 0; gameState.activeResearch = null; gameState.completedTech = new Set();
        gameState.selectedBuilding = null; gameState.unitToDeploy = null; // Reset deploy state
        gameState.productionProgress = { wheat: 0, coal: 0, quarry: 0 };
        gameState.eventLogs = []; gameState.worldData = {}; gameState.revealedTiles = new Set();
        gameState.highlightEnabled = false; clearTimeout(gameState.alertTimeout);
        gameState.gameInitialized = false;

        gameConfig.resources.forEach(res => { gameState.inventory[res.id] = 0; });

        gameState.currentLanguage = gameState.currentLanguage || 'en';
        const lang = getLang();
        if (!gameState.colonyName || !DOMElements.colonyNameDisplay.textContent.includes(gameState.colonyName)) {
            gameState.colonyName = prompt(lang.promptColonyName, lang.defaultColonyName) || lang.defaultColonyName;
        }
        logEvent('logNewGame', [gameState.colonyName]);

        const startWorldX = 5, startWorldY = 5; let startValid = false, attemptCount = 0;
        do {
             attemptCount++;
             if (attemptCount > 1) {
                 logEvent('logInvalidStartRegen');
                 const newSeed = Math.random();
                 noise.biome = SimplexNoise.create(newSeed); noise.feature = SimplexNoise.create(newSeed + 1); noise.water = SimplexNoise.create(newSeed + 2);
                 gameState.worldData = {}; gameState.revealedTiles = new Set();
             }
             generateTileContent(startWorldX, startWorldY); // Generate center
             revealArea(startWorldX, startWorldY, 1); // Generate & reveal neighbors

             const startData = getTileData(startWorldX, startWorldY);
             if (startData && startData.type !== 'water') {
                  let hasAdjLand = false;
                  for (let dy=-1; dy<=1; dy++) {
                      for (let dx=-1; dx<=1; dx++) {
                          if(dx===0 && dy===0) continue;
                          const adj = getTileData(startWorldX+dx,startWorldY+dy);
                          if(adj && adj.type !== 'water') { hasAdjLand=true; break; }
                      }
                      if(hasAdjLand) break;
                  }
                  if(hasAdjLand) startValid=true;
             }
             if (!startValid && attemptCount >= gameConfig.maxStartRegenAttempts) {
                 logEvent('logInvalidStartGiveUp', [attemptCount]); startValid=true;
             }
        } while (!startValid);

         gameState.units.push({ id: `unit-${gameState.nextUnitId++}`, type: 'pawn', worldX: startWorldX, worldY: startWorldY, exp: 0, upgrades: {} });
         gameState.selectedUnitId = gameState.units[0].id;
         gameState.viewOffsetX = startWorldX - gameConfig.viewCenterOffset; gameState.viewOffsetY = startWorldY - gameConfig.viewCenterOffset;
         revealArea(startWorldX, startWorldY, gameConfig.units.pawn.revealRadius);

        initializeGridDOM();
        setupEventListeners();
        hideAllPanels();
        updateLanguageUI();
        updateInventoryCapacity();
        updateUnitDisplayBar(); updateResearchPointsDisplay(); updateResearchUI(); updateBuildingsList(); updateUnitsPanel(); updateUnitInfoDisplay();
        DOMElements.researchStatusDisplay.textContent = lang.researchStatusInitial; DOMElements.researchStatusDisplay.style.display = 'block';
        focusOnUnit(gameState.selectedUnitId); // Center view and initial grid update
        showAlert('alertWelcome', 4000, false, [gameState.colonyName]);
        gameState.gameInitialized = true;
    }

    // --- Start Game ---
    document.addEventListener('DOMContentLoaded', initializeGame);

  </script>
</body>
</html>
